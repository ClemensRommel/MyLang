module Util;

enum Optional(T) where
    None(), Some(T);

    fun unwrap() : T := match this do 
        case Some(t) := t;
        case None() := panic("Error: called unwrap on empty Optional");
    end;

    fun map[K](f : Fun(T) : K) : Optional(K) := match this do 
        case None() := None.[K]();
        case Some(t) := Some.[K](f(t));
    end;

    fun expect(e : String) : T := match this do 
        case Some(t) := t;
        case None() := panic(e);
    end;
    fun is_some() : Bool := match this do 
        case Some(?) := true;
        case None() := false;
    end;
    fun is_none() : Bool := match this do 
        case Some(?) := false;
        case None() := true;
    end;
end;

class LateInitialized(A) where
    var field : Optional(A) := None.[A]();

    fun get() : A := match this.field do
        case Some(t) := t;
        case None() := panic("Error: Attempted to access uninitialized field");
    end;

    fun init(t : A) do
        this.field := Some.[A](t);
    end
    fun is_init() : Bool := this.field != None.[A]();
end

fun wrap_linit[T](t : T) : LateInitialized(T) do 
    val linit := LateInitialized.[T]();
    linit.init(t);
    linit
end

fun any[T](list : T[], pred : Fun(T) : Bool) : Bool do
    for t in list do
        if pred(t) do return true; end;
    end;
    false
end

fun snd[A, B](tuple : (A, B)) : B do 
    val (a, b) := tuple;
    b
end;
fun fst[A, B](tuple : (A, B)) : A do 
    val (a, b) := tuple;
    a
end

// Typesafe wrapper around builtin function (Temporary)
fun read_file(path : String) : Optional(String) do 
    val maybe_content := openFile(path);
    if isNull(maybe_content) 
        then None.[String]()
        else Some.[String](maybe_content)
end

fun outputFile(path : String, compiled : String) do 
    val initial := split(path, "\\.").first; // Only file extension can contain . as it is not a valid part of a name
    writeToFile(initial+".java", compiled);
end