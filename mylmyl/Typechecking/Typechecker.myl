module Typechecker;

import Ast;
import Env;
import Util;
import SourceFileGatherer;

fun typecheck(file : SourceFileGatherer.SourceFile) do 
    val tc := Typechecker(file);

    declare_builtins(tc);


    print("== Typechecking "+file.path+" ==");

    for decl in file.ast.decls do 
        check_decl(tc, decl);
    end;
    move_line_up();
end

class Typechecker where 
    var names : Ast.Namespace;
    val return_tys : (Bool, Ast.Type)[] := [(false, Ast.Never())]; // Global variables can't return, so push false first
    val in_loops : Bool[] := [false];
    var is_in_class : Bool := false;
    var is_in_constructor : Bool := false;
    var scope_depth : Number := 0; // 0 means global
    val file : SourceFileGatherer.SourceFile;
    var predeclared_variables : String[] := [];
    
    new(checked_file : SourceFileGatherer.SourceFile) do 
        this.names := checked_file.names;
        this.file := checked_file;
    end

    fun error[A](message : String) : A := panic(message);
    fun require_assigneable(to : Ast.Type, from : Ast.Type, violating_section : Fun() : String) do 
        resolve(this.names, to);
        resolve(this.names, from);
        if from = Ast.Never() do return null; end;
        if !this.types_equal(to, from) do
            this.error.[Void]("" + from+" is not assigneable to "+to+" in "+violating_section());
        end;
    end

    fun require_kind(to : Ast.Kind, from : Ast.Kind, violating : Ast.Type) do 
        if from != to do 
            match to do 
                case ConcreteType() := panic("Expected concrete type, got generic type"+to+" in"+violating);
                case GenericType(parts, part) := panic("Expected generic type"+to+", got concrete type in "+violating);
            end;
        end
    end

    fun open_scope() do 
        this.names := this.names.open_scope();
        this.scope_depth := this.scope_depth + 1;
    end
    fun close_scope() do 
        this.names := this.names.close_scope();
        this.scope_depth := this.scope_depth - 1;
    end

    fun type_of_var(name : String) : Ast.Type := this.names.values.get(name).ty;
    fun is_var_mutable(name : String) : Bool := this.names.values.get(name).is_mutable;

    fun type_info_for(name : String) : Ast.TyInfo := this.names.types.get(name);

    fun var_declared(name : String) : Bool := this.names.values.has(name);
    fun type_declared(name : String) : Bool := this.names.types.has(name);

    fun declare(name : String, ty : Ast.Type, m : Bool) do 
        if this.scope_depth > 0 do // Top level names are already declare
            this.names.values.insert(name, Ast.VarInfo(m, ty, name, this.names));
        end;
    end
    fun declare_type(name : String, ty_info : Ast.TyInfo) := this.names.types.insert(name, ty_info);

    fun is_global() : Bool := this.names.values.outer = Util.None.[Env.Env(Ast.VarInfo)]();

    
    fun types_equal(to : Ast.Type, from : Ast.Type) : Bool := match (to, from) do 
        case (NumberT(), NumberT()) := true;
        case (Any(), ?) := true; // Can assign everything to any
        case (BooleanT(), BooleanT()) := true;
        case (StringT(), StringT()) := true;
        case (VoidT(), VoidT()) := true;
        case (Tuple(tys1), Tuple(tys2)) := if tys1.length = tys2.length then true 
            else do 
                for i in [0..tys1.length] do 
                    if !this.types_equal(tys1[i], tys2[i]) do 
                        return false;
                    end;
                end;
                true
            end;
        case (Name(name1, lenv1), Name(name2, lenv2)) := name1 = name2 
            and if lenv1.is_init() and lenv2.is_init() 
                then if lenv1.get().types = lenv2.get().types then true else do 
                    print("Different namespaces");
                    print_namespace(lenv1.get()); print("other: "); print_namespace(lenv2.get());
                    panic("First: "+name1+" other: "+name2)
                end
                else panic("Cannot compare names from unknown namespace for equality: "+name1+", "+name2);
        case (Function(typparams1, args1, retty1), Function(typparams2, args2, retty2)) := this.types_equal(retty1, retty2)
            and (if typparams1.length != 0 or typparams2.length != 0 then panic("Cannot decide equality of types with type parameters") else true)
            and args1.length = args2.length 
            and do 
                for i in [0..args1.length] do 
                    if !this.types_equal(args1[i], args2[i]) do return false end;
                end;
                true
            end;
        case (ListOf(elem_ty1), ListOf(elem_ty2)) := this.types_equal(elem_ty1, elem_ty2);
        case (Never(), Never()) := true;
        case (ModuleAccess(?, ?, lty), other_ty) := do 
            resolve(this.names, to);
            this.types_equal(lty.get(), other_ty)
        end;
        case (other_ty, ModuleAccess(?, ?, lty)) := do 
            resolve(this.names, from);
            this.types_equal(other_ty, lty.get())
        end;
        case (Applied(a1, params1), Applied(a2, params2)) := this.types_equal(a1, a2) and params1.length = params2.length 
            and do 
                for i in [0..params1.length] do 
                    if !this.types_equal(params1[i], params2[i]) do return false; end;
                end;
                true
            end;
        case ? := false;
    end;
end

fun print_namespace(nmscp : Ast.Namespace) do 
    var env := Util.Some.[Env.Env(Ast.TyInfo)](nmscp.types);
    while val Some(e) := env do 
        print(""+e.bindings.bindings);
        env := e.outer;
    end;
end

fun lazy_str(e : Ast.Expr) : Fun() : String := fun() : String := "" + e;

fun declare_builtins(tc : Typechecker) do 
    tc.names.values.insert("panic", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.Never()), "panic", tc.names));
    tc.names.values.insert("print", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.VoidT()), "print", tc.names));
    tc.names.values.insert("args", Ast.VarInfo(false, Ast.Function([], [], Ast.ListOf(Ast.StringT())), "args", tc.names));
    tc.names.values.insert("join", Ast.VarInfo(false, Ast.Function([], [Ast.StringT(), Ast.ListOf(Ast.StringT())], Ast.StringT()), "join", tc.names));
    tc.names.values.insert("split", Ast.VarInfo(false, Ast.Function([], [Ast.StringT(), Ast.StringT()], Ast.ListOf(Ast.StringT())), "split", tc.names));
    tc.names.values.insert("number", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.NumberT()), "number", tc.names));
    tc.names.values.insert("len", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.NumberT()), "len", tc.names));
    tc.names.values.insert("strip", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.StringT()), "strip", tc.names));
    tc.names.values.insert("matches", Ast.VarInfo(false, Ast.Function([], [Ast.StringT(), Ast.StringT()], Ast.BooleanT()), "matches", tc.names));
    tc.names.values.insert("openFile", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.StringT()), "openFile", tc.names));
    tc.names.values.insert("isNull", Ast.VarInfo(false, Ast.Function([], [Ast.Any()], Ast.BooleanT()), "isNull", tc.names));
    tc.names.values.insert("writeToFile", Ast.VarInfo(false, Ast.Function([], [Ast.StringT(), Ast.StringT()], Ast.VoidT()), "writeToFile", tc.names));
    tc.names.values.insert("replace", Ast.VarInfo(false, Ast.Function([], [Ast.StringT(), Ast.StringT(), Ast.StringT()], Ast.StringT()), "replace", tc.names));
    tc.names.values.insert("move_line_up", Ast.VarInfo(false, Ast.Function([], [], Ast.VoidT()), "move_line_up", tc.names));
end

fun check_stmt(tc : Typechecker, stmt : Ast.Stmt) := match stmt do 
    case ExprStmt(arg) := do 
        infer(tc, arg);
    end;
    case IfStmt(cond, body) := do 
        check(tc, cond, Ast.BooleanT());
        check(tc, body, Ast.VoidT());
    end;
    case Declaration(decl) := check_decl(tc, decl);
    case SetStatement(setter, value) := check_set_stmt(tc, setter, value);
    case EmptyStmt() := do end;
end;

fun check_set_stmt(tc : Typechecker, setter : Ast.Setter, value : Ast.Expr) do 
    val expected_type := infer_setter(tc, setter);
    check(tc, value, expected_type);
    check_mutability(tc, setter);
end

fun check_mutability(tc : Typechecker, setter : Ast.Setter) := match setter do 
    case Variable(name) := do 
        if !tc.is_var_mutable(name) do 
            panic("Error: '"+name+"' is not mutable");
        end;
    end;
    case WildcardSetter() := do end;
    case TupleSetter(parts, ?) := do 
        for part in parts do 
            check_mutability(tc, part);
        end;
    end;
    case IndexSetter(?, ?) := do end; // Can always reassign fields of list
    case Property(obj, name, lt) := do 
        val ClassInfo(class_name, targs, fields, methods, ?, ?) := info_for(tc, lt.get(), fun(ty : Ast.Type) : String := "Cannot reassign to property "+name+" of non_class_type"+ty)
            else panic("Should be unreachable: Non-class info in setter");
        val field_info := fields.get(name);
        if not field_info.is_mutable and not tc.is_in_constructor do 
            panic("Cannot change immutable field "+name+" of class "+class_name);
        end
        if methods.has(name) do panic("Cannot change method "+name+"of class "+class_name+" in: "+setter); end
    end;
end;

fun infer_setter(tc : Typechecker, s : Ast.Setter) : Ast.Type := match s do 
    case Variable(name) := tc.type_of_var(name);
    case WildcardSetter() := do panic("Cannot infer wildcard setter") end;
    case TupleSetter(subsetters, lt) := do 
        val parts : Ast.Type[] := [];
        for setter in subsetters do 
            parts.push(infer_setter(tc, setter));
        end;
        val ty := Ast.Tuple(parts);
        lt.init(ty);
        ty
    end;
    case IndexSetter(indexed, idx) := do 
        check(tc, idx, Ast.NumberT());
        val list_ty := infer(tc, indexed);
        val ListOf(elem_ty) := list_ty else panic("Cannot reassign index of non-list type "+list_ty+" in "+s);
        elem_ty
    end;
    case Property(obj, name, lcty) := do
        val obj_ty := infer(tc, obj);
        lcty.init(obj_ty);
        val (property_ty, aty) := get_property_ty(tc, name, obj_ty, fun() : String := "" + s);
        property_ty
    end;
end;

fun check_declaration_setter(tc : Typechecker, setter : Ast.Setter, ty : Ast.Type, mut : Bool) do 
    match setter do 
        case Variable(name) := do 
            if tc.names.values.has(name) and tc.scope_depth > 0 do 
                panic("Variable '"+name+"' is already declared");
            end
            tc.declare(name, ty, mut);
        end;
        case WildcardSetter() := do end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of "+setter);
            end;
            for i in [0..setters.length] do 
                check_declaration_setter(tc, setters[i], parts[i], mut);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot use property as variable declaration: " + setter);
    end;
end

fun declared_vars_in(pat : Ast.Pattern, ty : Ast.Type, lst : (String, Ast.Type)[]) := match pat do 
    case NumericPattern(?) := do end;
    case StringPattern(?) := do end;
    case BooleanPattern(?) := do end;
    case NamePattern(n) := do lst.push((n, ty)); end;
    case WildcardPattern() := do end;
    case TuplePattern(pats) := do 
        val Tuple(tys) := ty else panic("Error: No tuple type in tuple pattern: "+pat+", "+ty);
        for i in [0..tys.length] do 
            declared_vars_in(pats[i], tys[i], lst);
        end;
    end;
    case ConstructorPattern(name, pats, lenumc, lenum, lenum_info) := do 
        val subst := if val Applied(from, to) := lenum.get() then do 
            val slst := Env.AList.[Ast.Type]();
            val EnumInfo(?, targs, ?, ?, ?, ?) := lenum_info.get() else panic("Cannot match on non-enum-type");
            for i in [0..targs.length] do 
                slst.insert(targs[i].name, to[i]);
            end;
            slst
        end else Env.AList.[Ast.Type]();
        val constr := lenumc.get();
        for i in [0..constr.fields.length] do 
            val field := constr.fields[i];
            val new_ty := substitute(field, subst);
            declared_vars_in(pats[i], new_ty, lst);
        end;
    end;
end;

fun check_decl(tc : Typechecker, decl : Ast.Decl) := match decl do 
    case VarDecl(setter, lt, init, mutable, ?) := do 
        if lt.is_init() then do 
            check_kind(tc, lt.get(), Ast.ConcreteType());
            val ty := resolve(tc.names, lt.get());
            if val Some(e) := init then do 
                check(tc, e, ty);
            end else do
                if not mutable and not tc.is_in_class do 
                    panic("Immutable variable requires initializer: "+setter);
                end
                if not tc.is_in_class do 
                    panic("Variables outside of classes require a initializer: "+setter);
                end
            end;
        end else do
            if val Some(e) := init then do  
                val inferred := infer(tc, e);
                lt.init(inferred); // Infer always returns a concrete type
            end else do 
                panic("Require either an initializer or a type annotation for variable "+setter+"\n"
                    + (if not mutable and not tc.is_in_class then "Immutable variable requires initializer: "+setter else "")
                    + (if not tc.is_in_class then "Variables outside of classes require a initializer: "+setter else ""));
            end;
        end;
        resolve(tc.names, lt.get());
        check_declaration_setter(tc, setter, lt.get(), mutable);
    end;
    case DesugarableDecl(md) := check_decl(tc, md.get());
    case EmptyDecl() := do end;
    case ValElseDeclaration(pat, matched, else_br, is_mut, is_export, ldecl_ty, lmatched_ty, lenv) := do 
        if ldecl_ty.is_init() then do 
            check_kind(tc, ldecl_ty.get(), Ast.ConcreteType());
            val ty := resolve(tc.names, ldecl_ty.get());
            check_pattern(tc, pat, ty);
            check(tc, matched, ty);
            check(tc, else_br, Ast.Never());
            lmatched_ty.init(ty);
            lenv.init(tc.names);
        end else do 
            val matched_ty := infer(tc, matched); // Infer always returns a concrete type
            lmatched_ty.init(matched_ty);
            ldecl_ty.init(matched_ty);
            check_pattern(tc, pat, matched_ty);
            check(tc, else_br, Ast.Never());
            lenv.init(tc.names);
        end;
    end;
    case FunDecl(name, typarams, params, return_type, body, ?, lenv) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) and tc.scope_depth > 0  do 
            panic("Function already declared: '"+name+"'");
        end;
        tc.open_scope();
            for param in typarams do 
                if tc.names.types.has(param.name) do 
                    panic("Type name already declared: "+param.name);
                end
                tc.declare_type(param.name, Ast.TypeParameterInfo(param.name));
            end;
            check_kind(tc, return_type, Ast.ConcreteType());
            val resolved_ret_ty := resolve(tc.names, return_type);
            val fun_type := Ast.Function(typarams, for ty in Ast.param_types(params) yield resolve(tc.names, ty) end, resolved_ret_ty);
            val closed_scope := tc.names;
        tc.close_scope();
        tc.declare(name, fun_type, false);
        tc.open_scope();
        tc.names := closed_scope;
            tc.in_loops.push(false);
            tc.return_tys.push((true, resolved_ret_ty));
            for param in params do 
                declare_param(tc, param);
            end;
            check(tc, body, resolved_ret_ty);
            lenv.init(tc.names);
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.close_scope();
        tc.declare(name, fun_type, false);
        if tc.is_global() and name = "main" and return_type != Ast.VoidT() do 
            panic("Main may not return anything other than Void");
        end
        if tc.is_global() and name = "main" and params != [] do 
            panic("Main may not define any parameters");
        end;
    end;
    case ClassDecl(name, targs, members, constructor, exported, lenv) := do 
        val (info, new_scope) := if tc.scope_depth = 0 then do 
            val declared_info := tc.names.types.get(name); // Pre-created info
            val declared_scope := scope_of_info(declared_info, tc.names);
            (declared_info, declared_scope)
        end else do 
            val created_scope := tc.names.open_scope();
            for t in targs do 
                created_scope.types.insert(t.name, Ast.TypeParameterInfo(t.name));
            end;
            val new_info := Ast.ClassInfo(
                name, 
                targs,
                fields_in_class(members, created_scope),
                methods_in_class(members, created_scope),
                exported,
                created_scope
            );
            (new_info, created_scope)
        end;
        tc.declare_type(name, info);
        tc.open_scope();
        val prev_scope := tc.names;
        tc.names := new_scope; 
            tc.in_loops.push(false);
            tc.return_tys.push((false, Ast.Never()));
            val this_ty := class_constr_ret_ty(targs, name, new_scope);
            tc.declare("this", this_ty, false);
            check_body(tc, members);
            val prev_in_constr := tc.is_in_constructor;
            tc.is_in_constructor := true;
            val constr_type := check_constructor(tc, constructor, targs, name, new_scope);
            tc.is_in_constructor := prev_in_constr;
            val body_env := tc.names;
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.names := prev_scope;
        if tc.names.values.has("this") do print("" + (prev_scope = new_scope) + "" + (tc.names = new_scope)); panic("Still has this after block"); end;
        tc.close_scope();
        lenv.init(body_env);
        
        tc.declare(name, constr_type, false);
    end;
    case EnumDecl(name, targs, variants, members, is_export, lenv) := do 
        val (info, new_scope) := if tc.scope_depth = 0 then do 
            val ty_info := tc.names.types.get(name);
            (ty_info, scope_of_info(ty_info, tc.names))
        end else do 
            val inner_scope := tc.names.open_scope();
            for t in targs do 
                inner_scope.types.insert(t.name, Ast.TypeParameterInfo(t.name));
            end;
            val funs := methods_in_class(members, inner_scope);
            (Ast.EnumInfo(name, targs, variants, funs, is_export, tc.names), inner_scope)
        end;
        disallow_fields_in_enum(tc, members, name);
        
        tc.declare_type(name, info);
        declare_enum_constructors(tc, name, targs, variants, new_scope);
        tc.open_scope();
        val prev_scope := tc.names;
        tc.names := new_scope;
            tc.in_loops.push(false);
            tc.return_tys.push((false, Ast.Never()));
            tc.declare("this", class_constr_ret_ty(targs, name, new_scope), false);
            check_body(tc, members);
            val body_env := tc.names;
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.names := prev_scope;
        tc.close_scope();
        lenv.init(body_env);
    end;
end;

fun declare_enum_constructors(tc : Typechecker, name : String, targs : Ast.TypeParameter[], variants : Ast.EnumConstructor[], scope : Ast.Namespace) do 
    for constr in variants do 
        for field in constr.fields do 
            check_kind(tc, field, Ast.ConcreteType());
            resolve(scope, field);
        end;
        tc.declare(constr.name, Ast.Function(targs, constr.fields, class_constr_ret_ty(targs, name, scope)), false);
    end;
end

fun disallow_fields_in_enum(tc : Typechecker, members : Ast.Decl[], name : String) do 
    for member in members do 
        if val VarDecl(setter, ?, ?, ?, ?) := member then do 
            panic("Error: Fields are not allowed as members of enums (in enum "+name+"): "+setter);
        end else do end;
    end;
end

fun fields_in_class(members : Ast.Decl[], scope : Ast.Namespace) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case VarDecl(setter, ty, ?, m, ?) := do 
                gather_types(setter, ty.get(), m, types, scope);
            end;
            case ? := do end;
        end;
    end;
    types
end
fun gather_types(setter : Ast.Setter, ty : Ast.Type, mutable : Bool, list : Env.AList(Ast.VarInfo), scope : Ast.Namespace) do 
    match setter do 
        case Variable(name) := list.insert(name, Ast.VarInfo(mutable, ty, name, scope));
        case WildcardSetter() := do end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of field "+setter);
            end;
            for i in [0..setters.length] do 
                gather_types(setters[i], parts[i], mutable, list, scope);
            end;
        end;
        case Property(?, ?, ?) := do end;
    end
end

fun methods_in_class(members : Ast.Decl[], scope : Ast.Namespace) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case FunDecl(name, typarams, params, ret_ty, body, ?, lenv) := do
                val fun_ty := Ast.Function(typarams, Ast.param_types(params), ret_ty);
                types.insert(name, Ast.VarInfo(false, fun_ty, name, scope));
            end;
            case ClassDecl(name, ?, ?, ?, ?, ?) := do panic("Error: Do not allow class as member of another class or enum: "+name); end;
            case EnumDecl(name, ?, ?, ?, ?, ?) := do panic("Error: Do not allow enum as member of another class or enum: "+name); end;
            case ? := do end;
        end;
    end;
    types
end

fun check_body(tc : Typechecker, body : Ast.Decl[]) do 
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    for member in body do 
        check_decl(tc, member);
    end;
    tc.is_in_class := prev_in_class;

end

fun check_constructor(tc : Typechecker, constructor : Util.Optional(Ast.Constructor), targs : Ast.TypeParameter[], className : String, scope : Ast.Namespace) : Ast.Type do
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    val result := if val Some(constr) := constructor then do 
        tc.open_scope();
            for param in constr.params do 
                declare_param(tc, param);
            end;
            check(tc, constr.body, Ast.VoidT());
            constr.lenv.init(tc.names);
        tc.close_scope();
        Ast.Function(targs, Ast.param_types(constr.params), class_constr_ret_ty(targs, className, scope))
    end else do 
        Ast.Function(targs, [], class_constr_ret_ty(targs, className, scope))
    end;
    tc.is_in_class := prev_in_class;
    result
end

fun class_constr_ret_ty(targs : Ast.TypeParameter[], className : String, nmspc : Ast.Namespace) : Ast.Type do 
    if targs.length = 0 then do 
        Ast.Name(className, Util.wrap_linit.[Ast.Namespace](nmspc))
    end else do
        val ty_params : Ast.Type[] := [];
        for arg in targs do 
            ty_params.push(Ast.Name(arg.name, Util.wrap_linit.[Ast.Namespace](nmspc)));
        end;
        Ast.Applied(Ast.Name(className, Util.wrap_linit.[Ast.Namespace](nmspc)), ty_params)
    end
end

fun declare_param(tc : Typechecker, param : Ast.Parameter) := match param do 
    case NormalParam(name, ty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) then do 
            panic("Parameter already declared: '"+name+"'");
        end else do 
            check_kind(tc, ty, Ast.ConcreteType());
            resolve(tc.names, ty);
            tc.declare(name, ty, false);
        end
    end;
end;

fun info_for(tc : Typechecker, ty : Ast.Type, error_message : Fun(Ast.Type) : String) : Ast.TyInfo do 
    match ty do 
        case Applied(aty, params) := info_for(tc ,aty, error_message);
        case Name(name, lenv) := lenv.get().types.get(name);
        case ModuleAccess(path, name, lty) := do resolve(tc.names, ty); info_for(tc, lty.get(), fun(other_ty : Ast.Type) : String := error_message(ty)) end;
        case ? := panic(error_message(ty));
    end
end

// resolve funktioniert über side effects (d.h. der parameter wird verändert),
// gibt den parameter aber zurück
// Macht auch das was require_types_exist tut
fun resolve(names : Ast.Namespace, ty : Ast.Type) : Ast.Type do 
    match ty do 
        case NumberT() := do end;
        case Any() := do end;
        case BooleanT() := do end;
        case StringT() := do end;
        case VoidT() := do end;
        case Tuple(parts) := do for part in parts do resolve(names, part) end; end;
        case Name(name, lenv) := do
            if !lenv.is_init() do // Name belongs to current scope
                if !names.types.has(name) do panic("Unknown type "+name+": available: "+names.types.bindings.bindings); end
                val info := names.types.get(name);
                lenv.init(scope_of_info(info, names));
            end;
            if !lenv.get().types.has(name) do // Typ existiert nicht im ziel / derzeitigen scope
                panic("Unknown type "+name);
            end
        end;
        //TODO: Generics
        case Function(typarams, params, ret_ty) := do 
            for param in params do resolve(names, param); end;
            resolve(names, ret_ty);
        end;
        case ListOf(tys) := do resolve(names, tys); end;
        case ModuleAccess(path, name, laccessed) := if laccessed.is_init() then do end else do 
            if !has_imported_module(names, path) do
                panic("Unknown module "+SourceFileGatherer.path_to_module(path)+" in "+ty);
            end;
            val imported_names := get_imported_module(names, path);
            if !imported_names.types.has(name) do  // Type is not declared
                panic("Module "+join(".", path)+" does not declare "+name);
            end
            val ty_info := imported_names.types.get(name); 
            if !is_type_exported(ty_info) do  // Type is not visible from this module
                panic("Module "+join(".", path)+" does not export "+name);
            end
            val scope := scope_of_info(ty_info, imported_names);
            laccessed.init(Ast.Name(name, Util.wrap_linit.[Ast.Namespace](scope)));
        end;
        case Applied(applied, params) := do 
            for param in params do resolve(names, param); end;
            resolve(names, applied);
        end;
        case Never() := do end;
    end;
    ty
end

fun scope_of_info(info : Ast.TyInfo, fallback : Ast.Namespace) : Ast.Namespace := match info do 
    case TypeParameterInfo(name) := fallback.env_defined_in(name);
    case ClassInfo(?, ?, ?, ?, ?, scope) := scope;
    case EnumInfo(?, ?, ?, ?, ?, scope) := scope;
end;

fun is_type_exported(info : Ast.TyInfo) : Bool := match info do 
    case ClassInfo(?, ?, ?, ?, exported, ?) := exported;
    case EnumInfo(?, ?, ?, ?, exported, ?) := exported;
end;

fun check(tc : Typechecker, e : Ast.Expr, t : Ast.Type) := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := check(tc, content.get(), t);
    case NumberLiteral(?) := tc.require_assigneable(t, Ast.NumberT(), lazy_str(e));
    case Boolean(?) := tc.require_assigneable(t, Ast.BooleanT(), lazy_str(e));
    case StringLiteral(?) := tc.require_assigneable(t, Ast.StringT(), lazy_str(e));
    case NullLiteral() := tc.require_assigneable(t, Ast.VoidT(), lazy_str(e));
    case ThisExpr() := do 
        if not tc.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        tc.require_assigneable(t, tc.type_of_var("this"), lazy_str(e));
    end;
    case Identifier(name, lty) := do 
        lty.init(t);
        tc.require_assigneable(t, tc.type_of_var(name), lazy_str(e));
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
    end;
    case BinaryOperation(op, lhs, rhs) := tc.require_assigneable(t, infer_binary(tc, op, lhs, rhs), lazy_str(e));
    case UnaryOperation(op, operand) := tc.require_assigneable(t, infer_unary(tc, op, operand), lazy_str(e));
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        linit.init(t);
        check(tc, cond, Ast.BooleanT());
        check(tc, thenBr, t);
        check(tc, elseBr, t);
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(tc, matched);
        lmatchty.init(matched_ty);
        tc.open_scope();
            check_pattern(tc, pat, matched_ty);
            check(tc, thenBr, t);
            lrety.init(t);
            lenv.init(tc.names);
        tc.close_scope();
        check(tc, elseBr, t);
    end;
    case BlockExpr(stmts, end_expr, lt, lenv) := do 
        check_block(tc, t, stmts, end_expr, e, lenv);
        lt.init(t);
    end;
    case ForExpr(setter, iterated, body, lenv, lt, lit) := check_for(tc, t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := check_while(tc, t, cond, body, lenv, lty);
    case WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty) := check_while_val(tc, t, pat, matched, body, lmatched_ty, lenv, lty);
    case FunctionCall(callee, fargs) := do 
        val callee_type := infer(tc, callee);
        // TODO: Generics
        val Function(typarams, param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        tc.require_assigneable(t, ret_type, lazy_str(e));
        if param_types.length != fargs.length do 
            panic("Error: tried to call function "+callee+" with "+fargs.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..fargs.length] do 
            check(tc, fargs[i], param_types[i]);
        end
    end;
    case InstantiationExpr(instantiated, typarams, lty) := tc.require_assigneable(t, infer(tc, e), lazy_str(e));
    case FunctionExpr(params, return_type, body, lenv) := tc.require_assigneable(
        t, 
        infer_function(
            tc, 
            params, 
            return_type, 
            body,
            lenv),
        lazy_str(e));
    case TupleExpr(subexprs, lt) := do 
        val Tuple(subtypes) := t else panic("Cannot use expression "+e+" with non-tuple-type "+t);
        lt.init(t);
        if subexprs.length != subtypes.length do 
            panic("Expected tuple of length "+subtypes.length+" in "+e);
        end
        for i in [0..subexprs.length] do 
            check(tc, subexprs[i], subtypes[i]);
        end;
    end;
    case ListExpr(subexprs, lt) := do 
        val ListOf(et) := t else panic("Expected "+t+", got expression of list type: "+e);
        for subexpr in subexprs do 
            check(tc, subexpr, et);
        end;
        lt.init(Ast.ListOf(et));
    end;
    case RangeExpr(start, end_expr) := do
        check(tc, start, Ast.NumberT());
        check(tc, end_expr, Ast.NumberT());
        tc.require_assigneable(t, Ast.ListOf(Ast.NumberT()), lazy_str(e));
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do
        val infered_type := infer(tc, e);
        tc.require_assigneable(t, infered_type, lazy_str(e));
    end;
    case IndexExpr(lst, idx, llist_ty) := do
        check(tc, idx, Ast.NumberT());
        val list_ty := infer(tc, lst);
        llist_ty.init(list_ty);
        tc.require_assigneable(t, match list_ty do case StringT() := Ast.StringT(); case ListOf(et) := et; end, lazy_str(e));
    end;
    case MatchExpr(matched, arms, lmty, lty) := do
        val matched_ty := infer(tc, matched);
        lmty.init(matched_ty);
        for (pattern, expr, lenv) in arms do
            tc.open_scope(); 
                check_pattern(tc, pattern, matched_ty);
                check(tc, expr, t);
                lenv.init(tc.names);
            tc.close_scope();
        end;
        lty.init(t);
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(t);
        val (can_return, return_ty) := tc.return_tys.last;
        if !can_return do panic("Cannot return outside of functions or methods: "+e) end
        check(tc, ret, return_ty);
    end;
    case Break(lty) := do 
        if !tc.in_loops.last do panic("Cannot break outside of loops"); end;
        lty.init(t);
    end;
end;

fun check_pattern(tc : Typechecker, pattern : Ast.Pattern, matched_ty : Ast.Type) do 
    fun pat_str() : String := "" + pattern;
    match pattern do 
        case NumericPattern(?) := do 
            tc.require_assigneable(Ast.NumberT(), matched_ty, pat_str);
        end;
        case StringPattern(?) := do 
            tc.require_assigneable(Ast.StringT(), matched_ty, pat_str);
        end;
        case BooleanPattern(?) := do 
            tc.require_assigneable(Ast.BooleanT(), matched_ty, pat_str);
        end;
        case NamePattern(name) := do 
            if tc.names.values.has(name) do 
                panic("Variable already declared: "+name+" in pattern");
            end;
            tc.declare(name, matched_ty, false);
        end;
        case WildcardPattern() := do end; // Wildcard is ok for everything
        case TuplePattern(patterns) := do 
            if val Tuple(parts) := matched_ty then do
                if parts.length != patterns.length do 
                    panic("Expected tuple of length "+patterns.length+", got tuple of "+parts.length+" in pattern "+pat_str());
                end;
                for i in [0..parts.length] do 
                    check_pattern(tc, patterns[i], parts[i]);
                end;
            end else do 
                panic("Cannot match on non-tuple-type "+matched_ty+" in pattern "+pattern);
            end;
        end;
        case ConstructorPattern(name, subpatterns, lconstr, lenum_ty, linf) := do 
            lenum_ty.init(matched_ty);
            var typarams : Ast.Type[] := [];
            val inf := if val Applied(a, params) := matched_ty 
                then do 
                    typarams := params;
                    info_for(tc, a, fun(ty : Ast.Type) : String := "Cannot match on non-enum-type" + matched_ty+" in "+pattern)
                end
                else info_for(tc, matched_ty, fun(ty : Ast.Type) : String := "Cannot match on non-enum-type "+matched_ty+" in "+pattern);
            val EnumInfo(enum_name, targs, constructors, methods, exported, scope) := inf
            else panic("Cannot match on non-enum type "+matched_ty+"in "+pattern);
            linf.init(inf);
            val subst := if typarams.length != 0 then do 
                val s : Env.AList(Ast.Type) := Env.AList.[Ast.Type]();
                if typarams.length != targs.length do panic("Expected "+targs.length+" type parameters, got "+typarams.length); end;
                for i in [0..typarams.length] do 
                    s.insert(targs[i].name, typarams[i]);
                end;
                s
            end else Env.AList.[Ast.Type]();
            for constr in constructors do 
                if constr.name = name do 
                    val tys := for ty in constr.fields yield substitute(resolve(scope, ty), subst) end;
                    lconstr.init(Ast.EnumConstructor(constr.name, tys));
                    val constr_params := constr.fields;
                    if constr_params.length != subpatterns.length do 
                        panic("Expected "+constr_params.length+" parameters, got "+subpatterns.length+" in "+pattern);
                    end;
                    for i in [0..constr_params.length] do 
                        check_pattern(tc, subpatterns[i], tys[i]);
                    end;
                    return null;
                end;
            end;
            panic("Enum "+enum_name+" has no constructor of name "+name);
        end;
    end;
end

fun get_property_ty(tc : Typechecker, name : String, ty : Ast.Type, err_str : Fun() : String) : (Ast.Type, Ast.AccessType) := match ty do  
    case ListOf(elem_ty) := builtin_list_property(elem_ty, name, err_str);
    case Applied(app_ty, typarams) := do 
        val (unsub_ty, acc) := get_property_ty(tc, name, app_ty, err_str);
        val inf := info_for(tc, app_ty, fun(wrong_ty : Ast.Type) : String := "Cannot read property of non-class-type "+wrong_ty+" in expression "+err_str());
        val declared_typarams := typarams_of(inf);
        if typarams.length != declared_typarams.length do panic("Expected "+declared_typarams.length+" type parameters, got "+typarams.length+" in "+ty); end;
        val substitutes := Env.AList.[Ast.Type]();
        for i in [0..typarams.length] do 
            substitutes.insert(declared_typarams[i].name, typarams[i]);
        end;
        val resulting := substitute(unsub_ty, substitutes);
        (resulting, acc)
    end;
    case ? := get_property_of_info(info_for(tc, ty, fun(wrong_ty : Ast.Type) : String := "Cannot read property of non-class-type "+wrong_ty+"in expression "+err_str()), name, err_str);
end;

fun typarams_of(inf : Ast.TyInfo) : Ast.TypeParameter[] := match inf do 
    case ClassInfo(?, params, ?, ?, ?, ?) := params;
    case EnumInfo(?, params, ?, ?, ?, ?) := params;
    case TypeParameterInfo(?) := [];
end;

fun get_property_of_info(class_info : Ast.TyInfo, name : String, err_str : Fun() : String) : (Ast.Type, Ast.AccessType) do 
    match class_info do 
        case ClassInfo(class_name, targs, fields, methods, exported, nmspc) := do 
            if fields.has(name) then do 
                val ty := resolve(nmspc, fields.get(name).ty);
                (ty, Ast.FieldAccess())
            end else if methods.has(name) then do 
                val ty := resolve(nmspc, methods.get(name).ty);
                (ty, Ast.MethodAccess())
            end else panic("Type "+class_name+" has no field or method called "+name)
        end;
        case EnumInfo(enum_name, targs, ?, methods, exported, nmspc) := do 
            if methods.has(name) then do 
                (resolve(nmspc, methods.get(name).ty), Ast.MethodAccess())
            end else panic("Type "+enum_name+" has no method called "+name)
        end;
    end
end

fun builtin_list_property(elem_ty : Ast.Type, name : String, err_str : Fun() : String) : (Ast.Type, Ast.AccessType) := match name do 
    case "length" := (Ast.NumberT(), Ast.FieldAccess());
    case "first" := (elem_ty, Ast.FieldAccess());
    case "last" := (elem_ty, Ast.FieldAccess());
    case "push" := (Ast.Function([], [elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "pop" := (Ast.Function([], [], elem_ty), Ast.MethodAccess());
    // Peekt auf das letzte element. für das erste kann first verwendet werden
    case "peek" := (Ast.Function([], [], elem_ty), Ast.MethodAccess()); 
    case "dequeue" := (Ast.Function([], [], elem_ty), Ast.MethodAccess()); // Entfernt das erste element
    case "prepend" := (Ast.Function([], [elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "append" := (Ast.Function([], [Ast.ListOf(elem_ty)], Ast.VoidT()), Ast.MethodAccess());
end;

fun check_block(
    tc : Typechecker, 
    t : Ast.Type, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    total : Ast.Expr, 
    lenv : Util.LateInitialized(Ast.Namespace))
do 
    tc.open_scope();
        for stmt in stmts do 
            check_stmt(tc, stmt);
        end;
        if val Some(e) := end_expr then do 
            check(tc, e, t);
        end else do 
            tc.require_assigneable(t, Ast.VoidT(), lazy_str(total));
        end;
        lenv.init(tc.names);
    tc.close_scope();
end

fun check_for(
    tc : Typechecker, 
    result_ty : Ast.Type,
    setter : Ast.Setter, 
    iterated : Ast.Expr,
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Ast.Namespace), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        tc.in_loops.push(true);
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, setter, elem_ty, false);
        if val VoidT() := result_ty then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(e_ty) := result_ty then do 
            check(tc, body, e_ty);
        end else do 
            val body_ty := infer(tc, body);
            tc.error.[Void]("Expected "+result_ty+", got "+Ast.ListOf(body_ty));
        end;
        lenv.init(tc.names);
        lt.init(result_ty);
        tc.in_loops.pop();
    tc.close_scope();
end

fun check_while(
    tc : Typechecker,  
    expected : Ast.Type, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Ast.Namespace), 
    lty : Util.LateInitialized(Ast.Type)) 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        tc.in_loops.push(true);
        if val VoidT() := expected then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := expected then do 
            check(tc, body, elem_ty);
        end else do 
            val elem_ty := infer(tc, body);
            tc.error.[Void]("Expected "+expected+", got "+Ast.ListOf(elem_ty)+" in "+ Ast.WhileExpr(cond, body, lenv, lty));
        end;
        lty.init(expected); // The resulting type of the entire expression, not the element type
        lenv.init(tc.names);
        tc.in_loops.pop();
    tc.close_scope();
end

fun check_while_val(
    tc : Typechecker, 
    expected : Ast.Type, 
    pat : Ast.Pattern, 
    matched : Ast.Expr, 
    body : Ast.Expr, 
    lmatched_ty : Util.LateInitialized(Ast.Type), 
    lenv : Util.LateInitialized(Ast.Namespace), 
    lty : Util.LateInitialized(Ast.Type)) 
do 
    val matched_ty := infer(tc, matched);
    lmatched_ty.init(matched_ty);
    tc.open_scope();
        tc.in_loops.push(true);
        check_pattern(tc, pat, matched_ty);
        if val VoidT() := expected then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := expected then do
            check(tc, body, elem_ty);
        end else do 
            val elem_ty := infer(tc, body);
            tc.error.[Void]("Expected "+expected+", got "+Ast.ListOf(elem_ty)+" in "+Ast.WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty));
        end;
        lty.init(expected);
        lenv.init(tc.names);
        tc.in_loops.pop();
    tc.close_scope();
end

// Return type is always fully resolved
fun infer(t : Typechecker, e : Ast.Expr) : Ast.Type := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := infer(t, content.get());
    case NumberLiteral(?) := Ast.NumberT();
    case Boolean(?) := Ast.BooleanT();
    case StringLiteral(?) := Ast.StringT();
    case NullLiteral() := Ast.VoidT();
    case ThisExpr() := do 
        if not t.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        t.type_of_var("this")
    end;
    case Identifier(name, lty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
        val res := t.type_of_var(name);
        lty.init(res);
        res
    end;
    case BinaryOperation(op, lhs, rhs) := infer_binary(t, op, lhs, rhs);
    case UnaryOperation(op, operand) := infer_unary(t, op, operand);
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        check(t, cond, Ast.BooleanT());
        val ret_type := infer(t, thenBr);
        check(t, elseBr, ret_type);
        linit.init(ret_type);
        ret_type
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(t, matched);
        lmatchty.init(matched_ty);
        t.open_scope();
            check_pattern(t, pat, matched_ty);
            val resulting_ty := infer(t, thenBr);
            lrety.init(resulting_ty);
            lenv.init(t.names);
        t.close_scope();
        check(t, elseBr, resulting_ty);
        resulting_ty
    end;
    case FunctionExpr(params, return_type, body, lenv) := infer_function(t, params, return_type, body, lenv);
    case BlockExpr(stmts, end_expr, lt, lenv) := infer_block(t, stmts, end_expr, lt, lenv);
    case ForExpr(setter, iterated, body, lenv, lt, lit) := infer_for(t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := infer_while(t, cond, body, lenv, lty);
    case WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty) := infer_while_val(t, pat, matched, body, lmatched_ty, lenv, lty);
    case FunctionCall(callee, fargs) := do 
        val callee_type := infer(t, callee);
        // TODO: Generics
        val Function(typarams, param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        if param_types.length != fargs.length do 
            panic("Error: tried to call function "+callee+" with "+fargs.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..fargs.length] do 
            check(t, fargs[i], param_types[i]);
        end;
        ret_type
    end;
    case InstantiationExpr(instantiated, typarams, lty) := do 
        val instantiated_ty := infer(t, instantiated);
        val Function(expected_typarams, valparams, retty) := instantiated_ty 
            else panic("Cannot instantiate non-generic type: "+instantiated_ty);
        if typarams.length != expected_typarams.length do 
            panic("Error: Expected "+expected_typarams.length
                  +" type parameters, got "+typarams.length+" type parameters in "+e);
        end 
        val typaram_substitutes : Env.AList(Ast.Type) := Env.AList.[Ast.Type]();
        for i in [0..typarams.length] do 
            typaram_substitutes.insert(expected_typarams[i].name, typarams[i]);
        end;
        val sty := substitute(instantiated_ty, typaram_substitutes);
        lty.init(sty);
        sty
    end;
    case TupleExpr(subexprs, lt) := do 
        val types : Ast.Type[] := [];
        for expr in subexprs do 
            types.push(infer(t, expr));
        end;
        val resulting := Ast.Tuple(types);
        lt.init(resulting);
        resulting
    end;
    case ListExpr(subexprs, lt) := do 
        val lty : Ast.Type := if subexprs.length = 0 then 
            panic("Cannot infer type of empty list")
        else if subexprs.length = 10 then 
            Ast.ListOf(infer(t, subexprs.first))
        else do 
            val ty := infer(t, subexprs.first);
            for i in [1..subexprs.length] do 
                check(t, subexprs[i], ty);
            end;
            Ast.ListOf(ty)
        end;
        lt.init(lty);
        lty
    end;
    case RangeExpr(start, end_expr) := do 
        check(t, start, Ast.NumberT());
        check(t, end_expr, Ast.NumberT());
        Ast.ListOf(Ast.NumberT())
    end;
    case PropertyExpr(obj, name, la, lt, lft) := if val Module(path) := accessed_object(t, obj) then do  
        val imported_names := get_imported_module(t.names, path);
        val accessed_globals := imported_names.values;
        la.init(Ast.ModuleAccessed());
        lt.init(Ast.Never());
        if !accessed_globals.has(name) do 
            panic("Module "+join(".", path)+" does not declare "+name);
        end;
        val accessed := accessed_globals.get(name);
        if !accessed.is_exported do 
            panic("Module "+join(".", path)+" does not export "+name);
        end
        lft.init(accessed.ty);
        resolve(accessed.scope, accessed.ty)
    end else do 
        val obj_ty := infer(t, obj);
        lt.init(obj_ty);

        val (member_ty, acc_ty) := get_property_ty(t, name, obj_ty, lazy_str(e));
        lft.init(member_ty);
        la.init(acc_ty);
        member_ty
    end;
    case IndexExpr(lst, idx, llist_ty) := do
        check(t, idx, Ast.NumberT());
        val list_ty := infer(t, lst);
        llist_ty.init(list_ty);
        val et := match list_ty do 
            case ListOf(elem_ty) := elem_ty;
            case StringT() := list_ty;
            case ? := panic("Require indexed object to be a list or string, not "+list_ty+" in "+e);
        end;
        et
    end;
    case MatchExpr(matched, arms, lmty, lty) := do 
        val matched_ty := infer(t, matched);
        if arms.length = 0 do 
            panic("Cannot infer type of match with out arms: "+e);
        end;
        lmty.init(matched_ty);
        var resulting := Util.None.[Ast.Type]();
        for (pattern, expr, lenv) in arms do 
            t.open_scope();
                check_pattern(t, pattern, matched_ty);
                fun infer_match_ty() do 
                    val ty := infer(t, expr);
                    resulting := Util.Some.[Ast.Type](ty);
                end;
                if val Some(ty) := resulting then do 
                    if val VoidT() := ty then do 
                        infer_match_ty();
                    end else do 
                        check(t, expr, ty);
                    end;
                end else do 
                    infer_match_ty();
                end;
                lenv.init(t.names);
            t.close_scope();
        end;
        if val Some(typ) := resulting then do 
            lty.init(typ);
            typ
        end else do 
            panic("Could not infer resulting type of "+e)
        end
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(Ast.Never());
        val (can_return, return_ty) := t.return_tys.last;
        if !can_return do panic("Cannot return outside of functions and methods: "+e); end;
        check(t, ret, return_ty);
        Ast.Never()
    end;
    case Break(lty) := do 
        if !t.in_loops.last do panic("Cannot break outside of loops"); end;
        lty.init(Ast.Never());
        Ast.Never()
    end;
end;

fun substitute(ty : Ast.Type, substitutes : Env.AList(Ast.Type)) : Ast.Type := match ty do 
    case NumberT() := ty;
    case Any() := ty;
    case BooleanT() := ty;
    case StringT() := ty;
    case VoidT() := ty;
    case Tuple(tys) := Ast.Tuple(for t in tys yield substitute(t, substitutes) end);
    // tylevelparams has to be either [] or the types we substitute, because you cant return generic functions
    case Function(tylevelparams, argtypes, rettype) := 
        Ast.Function([], 
                     for t in argtypes yield substitute(t, substitutes) end, 
                     substitute(rettype, substitutes));
    case ListOf(elem_ty) := Ast.ListOf(substitute(elem_ty, substitutes));
    case ModuleAccess(?, ?, ?) := ty;
    case Never() := ty;
    case Name(name, lenv) := if substitutes.has(name) 
            then substitutes.get(name)
            else ty; // Not a type parameter to be replaced, leave it alone
    case Applied(ap, params) := Ast.Applied(substitute(ap, substitutes), for t in params yield substitute(t, substitutes) end);
end;

fun get_imported_module(names : Ast.Namespace, path : String[]) : Ast.Namespace :=
    if path.length = 1 and names.imported_modules.has(path[0]) 
        then names.imported_modules.get(path[0])
        else names.imported_modules.get(SourceFileGatherer.path_to_module(path));

fun has_imported_module(names : Ast.Namespace, path : String[]) : Bool := 
    (path.length = 1 and names.imported_modules.has(path[0]))
    or names.imported_modules.has(SourceFileGatherer.path_to_module(path));

fun accessed_object(tc : Typechecker, expr : Ast.Expr) : Ast.AccessedObjectType do 
    val Module(path) := Ast.get_as_path(expr) else return Ast.NormalObject(); // Expression has to be a path
    if has_imported_module(tc.names, path) then // Expression is an imported object
        Ast.Module(path)
    else 
        Ast.NormalObject()
end

fun infer_function(
    t : Typechecker,
    params : Ast.Parameter[], 
    return_type : Ast.Type,
    body : Ast.Expr,
    lenv : Util.LateInitialized(Ast.Namespace)) : Ast.Type
do 
    t.open_scope();
        t.in_loops.push(false);
        for param in params do 
            declare_param(t, param);
        end;
        check_kind(t, return_type, Ast.ConcreteType());
        check(t, body, return_type);
        lenv.init(t.names);
        t.in_loops.pop();
    t.close_scope();
    Ast.Function([], Ast.param_types(params), return_type)
end

fun infer_block(
    t : Typechecker, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    lt : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Ast.Namespace)) : Ast.Type
do 
    t.open_scope();
        for stmt in stmts do 
            check_stmt(t, stmt);
        end;
        var result_type := Ast.VoidT();
        if val Some(e) := end_expr then do 
            result_type := infer(t, e);
        end else do end;
        lenv.init(t.names);
    t.close_scope();
    lt.init(result_type);
    result_type
end

fun infer_for(
    tc : Typechecker, 
    loop_var : Ast.Setter, 
    iterated : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Ast.Namespace), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        tc.in_loops.push(true);
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, loop_var, elem_ty, false);
        val resulting_elem_ty := infer(tc, body);
        lenv.init(tc.names);
        tc.in_loops.pop();
    tc.close_scope();
    val resulting := Ast.ListOf(resulting_elem_ty);
    lt.init(resulting);
    resulting
end

fun infer_while(
    tc : Typechecker, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Ast.Namespace), 
    lty : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        tc.in_loops.push(true);
        val elem_ty := infer(tc, body);
        val resulting := Ast.ListOf(elem_ty);
        lenv.init(tc.names);
        lty.init(resulting);
        tc.in_loops.pop();
    tc.close_scope();
    resulting
end

fun infer_while_val(
    tc : Typechecker,
    pat : Ast.Pattern,
    matched : Ast.Expr,
    body : Ast.Expr,
    lmatched_ty : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Ast.Namespace), 
    lty : Util.LateInitialized(Ast.Type)) : Ast.Type
do 
    val matched_ty := infer(tc, matched);
    lmatched_ty.init(matched_ty);
    tc.open_scope();
        tc.in_loops.push(true);
        check_pattern(tc, pat, matched_ty);
        val elem_ty := infer(tc, body);
        val resulting := Ast.ListOf(elem_ty);
        lenv.init(tc.names);
        lty.init(resulting);
        tc.in_loops.pop();
    tc.close_scope();
    resulting
end

fun infer_binary(t : Typechecker, op : Ast.BinOp, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type := match op do 
    case Add(lty) := do 
        val lhs_type := infer(t, lhs);
        match lhs_type do 
            case NumberT() := do 
                check(t, rhs, Ast.NumberT());
                lty.init(Ast.NumberT());
                Ast.NumberT()
            end;
            case StringT() := do 
                check(t, rhs, Ast.Any());
                lty.init(Ast.StringT());
                Ast.StringT()
            end;
            case ? := do 
                t.error.[Ast.Type]("Invalid left type for +: "+lhs_type)
            end;
        end
    end;
    case LessThan() := infer_numeric_comparison(t, lhs, rhs);
    case LessEqual() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterThan() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterEqual() := infer_numeric_comparison(t, lhs, rhs);
    case Equals() := infer_equality(t, lhs, rhs);
    case NotEquals() := infer_equality(t, lhs, rhs);
    case And() := infer_boolean_operator(t, lhs, rhs);
    case Or() := infer_boolean_operator(t, lhs, rhs);
    case Xor() := infer_boolean_operator(t, lhs, rhs);
    case ? := do 
        check(t, lhs, Ast.NumberT());
        check(t, rhs, Ast.NumberT());
        Ast.NumberT()
    end;
end;

fun infer_boolean_operator(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.BooleanT());
    check(t, rhs, Ast.BooleanT());
    Ast.BooleanT()
end

fun infer_numeric_comparison(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.NumberT());
    check(t, rhs, Ast.NumberT());
    Ast.BooleanT()
end

fun infer_equality(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    val compared_type := infer(t, lhs);
    check(t, rhs, compared_type);
    Ast.BooleanT()
end

fun infer_unary(t : Typechecker, op : Ast.UnOp, operand : Ast.Expr) : Ast.Type do 
    val op_type := match op do 
        case Not() := Ast.BooleanT();
        case ? := Ast.NumberT();
    end;
    check(t, operand, op_type);
    op_type 
end

fun check_kind(tc : Typechecker, ty : Ast.Type, kind : Ast.Kind) do 
    match ty do 
        case NumberT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case BooleanT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case StringT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case VoidT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case Any() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case Function(typarams, params, ret_ty) := do 
            tc.open_scope();
                for param in typarams do 
                    tc.declare_type(param.name, Ast.TypeParameterInfo(param.name));
                end;
                for param in params do 
                    check_kind(tc, param, Ast.ConcreteType());
                end;
                check_kind(tc, ret_ty, Ast.ConcreteType());
            tc.close_scope();
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case ListOf(elem_type) := do 
            check_kind(tc, elem_type, Ast.ConcreteType());
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Never() := do 
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Tuple(parts) := do 
            for part in parts do 
                check_kind(tc, part, Ast.ConcreteType());
            end;
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Name(name, lenv) := do
            val variable_kind := kind_of(tc, ty);
            tc.require_kind(kind, variable_kind, ty);
        end;
        case ModuleAccess(path, name, lty) := do 
            val member_kind := kind_of(tc, ty);
            tc.require_kind(kind, member_kind, ty);
        end;
        case Applied(a1, params) := do 
            for param in params do 
                check_kind(tc, param, Ast.ConcreteType());
            end;
            check_kind(tc, a1, generic_kind(params.length));
        end;
    end
end

fun generic_kind(param_count: Number) : Ast.Kind do 
    val generic_params : Ast.Kind[] := [];
    for i in [0..param_count] do generic_params.push(Ast.ConcreteType()); end;
    Ast.GenericType(generic_params, Ast.ConcreteType())
end

fun kind_of(tc : Typechecker, ty : Ast.Type) : Ast.Kind do
    match resolve(tc.names, ty) do 
        case NumberT() := Ast.ConcreteType();
        case BooleanT() := Ast.ConcreteType();
        case StringT() := Ast.ConcreteType();
        case VoidT() := Ast.ConcreteType();
        case Any() := Ast.ConcreteType();
        case Tuple(tys) := Ast.ConcreteType();
        case Name(name, lenv) := do 
            val info := info_for(tc, ty, fun(this_ty : Ast.Type) : String := "Cannot infer kind of type "+this_ty);
            val kind := kind_of_info(tc, info);
            kind
        end;
        case ModuleAccess(?, ?, lty) := kind_of(tc, lty.get());
    end
end

fun kind_of_info(tc : Typechecker, info : Ast.TyInfo) : Ast.Kind := match info do 
    case TypeParameterInfo(?) := Ast.ConcreteType(); // Type parameters cannot be generic (no higher kinded types)
    case ClassInfo(name, targs, fields, methods, exported, ?) := if targs.length = 0 then Ast.ConcreteType() else generic_kind(targs.length); 
    case EnumInfo(name, targs, constructors, methods, exported, ?) := if targs.length = 0 then Ast.ConcreteType() else generic_kind(targs.length); 
end;