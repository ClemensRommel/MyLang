module Compiler;

import Ast;
import Env;
import Analyze;
import Util;

class Compiler where 
    var buf : String := "";
    var indent_level : Number := 0;
    var counter : Number := 0;

    var is_class : Bool := true;
    var is_static : Bool := true;
    var expect_ref_ty : Bool := false; // Wether we're currently compiling a type that is a type parameter

    val types_to_compile : CompilationTask[] := [];
    val compiled_types : (String, Ast.Type)[] := [];

    var current_env : Env.Env(Ast.VarInfo);

    var env : Env.Env(VariableInfo) := Env.Env.[VariableInfo]();

    new(globals : Env.Env(Ast.VarInfo)) do 
        this.current_env := globals;
    end

    fun append(str : String) do
        this.buf := this.buf + str;
    end

    fun newline() do 
        this.append("\n");
        for i in [0..this.indent_level] do 
            this.append("    ");
        end;
    end

    fun indent() do 
        this.indent_level := this.indent_level + 1;
    end
    
    fun dedent() do 
        if this.indent_level <= 0 do 
            panic("Error: Negative Indent impossible");
        end;
        this.indent_level := this.indent_level - 1; 
    end

    fun strip_trailing() do 
        this.buf := strip(this.buf);
    end

    fun new_var() : String do 
        val c := this.counter;
        this.counter := this.counter + 1;
        "__a" + c 
    end

    fun enqueue_type(t : Ast.Type, type_name : String) do 
        match t do 
            case Function(args, ret) := do 
                this.types_to_compile.push(CreateFunctionalInterface(args, ret, type_name));
            end;
            case Tuple(parts) := do 
                this.types_to_compile.push(CreateTupleType(parts, type_name));
            end;
        end;
    end
    
    fun get_enqueued_type(t : Ast.Type) : Util.Optional(String) do
        for task in this.types_to_compile do 
            match task do 
                case CreateFunctionalInterface(args, ret, name) := do
                    if t = Ast.Function(args, ret) do 
                        return Util.Some.[String](name);
                    end;
                end;
                case CreateTupleType(parts, name) := do 
                    if t = Ast.Tuple(parts) do 
                        return Util.Some.[String](name);
                    end;
                end;
                case ? := do end;
            end;
        end;
        for (name, ty) in this.compiled_types do 
            if ty = t do 
                return Util.Some.[String](name);
            end;
        end;
        Util.None.[String]()
    end

    fun open_scope(env : Env.Env(Ast.VarInfo)) : ScopeInfo do 
        val previous_is_class := this.is_class;
        val previous_is_static := this.is_static;
        val previous_env := this.current_env;
        this.current_env := env;
        this.env := this.env.open_scope();
        this.is_class := false;
        this.is_static := false;
        ScopeInfo(previous_is_class, previous_env, previous_is_static)
    end

    fun close_scope(sci : ScopeInfo) do 
        this.is_static := sci.previous_is_static;
        this.is_class := sci.previous_is_class;
        this.current_env := sci.previous_env;
        this.env := this.env.close_scope();
    end
end

class ScopeInfo where 
    val previous_is_class : Bool;
    val previous_env : Env.Env(Ast.VarInfo);
    val previous_is_static : Bool;
    new(pic : Bool, penv : Env.Env(Ast.VarInfo), pis : Bool) do 
        this.previous_is_class := pic;
        this.previous_env := penv;
        this.previous_is_static := pis;
    end
end

enum CompilationTask where 
    CreateTupleType(Ast.Type[], String),
    CreateFunctionalInterface(Ast.Type[], Ast.Type, String);
end;

enum Target where 
    Ignore(), UsedDirectly(), Return(), AssignTo(Ast.Setter);
end

class VariableInfo where 
    var is_no_fc_fn : Bool := false;
    var is_constructor : Bool := false;
    var is_upvalue : Bool := false;
end

fun compile(ast : Ast.Program, globals : Env.Env(Ast.VarInfo)) : String do 
    val c := Compiler(globals);
    import_implicits(c);
    c.append("class Main {");
    c.indent(); c.newline();
    for decl in ast.decls do 
        compile_decl(c, decl);
    end;
    compile_enqueued_types(c);
    c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.buf
end

fun import_implicits(c : Compiler) do 
    c.append("import static std.codegen.Functions.*;");
    c.newline();
    c.append("import std.codegen.*;");
    c.newline();
    c.newline();
    c.append("import java.util.ArrayList;");
    c.newline();

    c.newline();
end

fun compile_stmt(c : Compiler, stmt : Ast.Stmt) := match stmt do 
    case ExprStmt(expr) := do 
        val arg := compile_expr(c, expr, Ignore());
    end;
    case PrintStmt(expr) := do 
        val arg := compile_expr(c, expr, UsedDirectly());
        c.append("System.out.println(");c.append(arg);c.append(");");
        c.newline();
    end;
    case Declaration(decl) := compile_decl(c, decl);
    case SetStatement(setter, expr) := compile_expr(c, expr, AssignTo(setter));
end;

fun compile_decl(c : Compiler, decl : Ast.Decl) := match decl do 
    case VarDecl(setter, lt, init, mutable, ?) := compile_var_decl(c, setter, lt, init, mutable);
    case FunDecl(name, params, return_type, body, ?, lenv) := compile_fun_decl(c, name, params, return_type, body, lenv);
    case ClassDecl(name, members, opt_constr, ?, lenv) := compile_class_decl(c, name, members, opt_constr, lenv.get());
end;



fun compile_class_decl(c : Compiler, name : String, members : Ast.Decl[], constr : Util.Optional(Ast.Constructor), env : Env.Env(Ast.VarInfo)) do
    if c.is_class do 
        c.append("public ");
    end;
    if c.is_static do 
        c.append("static ");
    end
    c.append("class "+name+" {");
    c.indent(); c.newline();
    val prv := c.open_scope(env);
    c.is_class := true;
    for member in members do 
        compile_decl(c, member);
    end
    compile_constructor(c, constr, name);
    c.strip_trailing(); c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    val info := VariableInfo();
    info.is_constructor := true;
    info.is_no_fc_fn := true;
    c.env.insert(name, info);
end

fun compile_constructor(c : Compiler, constr : Util.Optional(Ast.Constructor), name : String) do
    val Some(construct) := constr else return null;
    c.append("public "+name);
    c.append("(");
    var needs_comma := false;
    for param in construct.params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.append(compile_type(c, ty)); c.append(" "+name);
            end;
        end;
        needs_comma := true;
    end 
    c.append(") ");
    compile_expr(c, construct.body, Ignore());
end

fun compile_variables(c : Compiler, setter : Ast.Setter, ty : Ast.Type, is_global : Bool, mutable : Bool, is_upvalue : Bool) do 
    match setter do 
        case Variable(name) := do 
            if c.is_class do c.append("public "); end;
            if c.is_static do c.append("static "); end;
            if !mutable do c.append("final "); end;
            val ty_compiled := if is_upvalue then compile_upvalue_type(c, ty) else compile_type(c, ty);
            c.append(ty_compiled); c.append(" "); c.append(name); 
            if is_upvalue do 
                c.append(" = new ");
                c.append(ty_compiled);
                c.append("()");
            end;
            c.append(";");
            c.newline();
        end;
        case TupleSetter(parts, ?) := do 
            val Tuple(types) := ty else panic("Non-tuple type in tuple setter "+setter);
            for i in [0..parts.length] do 
                compile_variables(c, parts[i], types[i], is_global, mutable, is_upvalue);
            end;
        end;
        case Property(?, ?, ?) := panic("Unreachable: Cannot assign to field of object in declaration");
    end;
end

fun compile_var_decl(c : Compiler, setter : Ast.Setter, lt : Util.LateInitialized(Ast.Type), init : Util.Optional(Ast.Expr), mutable : Bool) do
    if c.is_class then do
        compile_variables(c, setter, lt.get(), true, mutable, false);
        if val Some(e) := init then do 
            if c.is_static do c.append("static "); end;
            c.append("{");
            c.indent(); c.newline();
            val initializer := compile_expr(c, e, AssignTo(setter));
            c.strip_trailing();
            c.dedent(); c.newline();
            c.append("}");
        end else do end;
        c.newline();
        // Global variables are not pre-analyzed for captures, because they cannot be captured
    end else do
        val is_upvalue := setter_is_upvalue(c, setter);
        compile_variables(c, setter, lt.get(), false, mutable, is_upvalue);
        if val Some(e) := init then do
            compile_expr(c, e, AssignTo(setter));
        end else do end;
    end;
    declare_variables(c, setter);
end

fun declare_variables(c : Compiler, setter : Ast.Setter) do 
    match setter do 
        case Variable(name) := c.env.insert_if_missing(name, VariableInfo());
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                declare_variables(c, part);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot declare property as variable: Unreachable");
    end;
end

fun setter_is_upvalue(c : Compiler, setter : Ast.Setter) : Bool :=
    match setter do 
        case Variable(name) := c.env.has(name) and c.env.get(name).is_upvalue;
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                if setter_is_upvalue(c, part) do return true end;
            end
            false
        end;
        case Property(?, ?, ?) := false;
    end;

fun compile_fun_decl(
    c : Compiler, 
    name : String, 
    params : Ast.Parameter[], 
    return_type : Ast.Type, 
    body : Ast.Expr,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)))
do 
    val info := VariableInfo();
    info.is_no_fc_fn := c.is_class; // Local functions cannot be compiled directly but to lambdas
    c.env.insert(name, info); // Functions can never be captured, so unconditionally insert info
    val is_main := c.is_static and name = "main" and return_type = Ast.VoidT();
    if c.is_class then do 
        c.append("public ");
        if c.is_static do c.append("static "); end; 
        if is_main then do 
            c.append("void");
        end else do
            c.append(compile_type(c, return_type)); 
        end;
        c.append(" ");
    end else do
        val ty := c.current_env.get(name).ty;
        if val Function(?, ?) := ty then do end else panic("Unreachable: Function is being compiled that has non-function-type");
        if Analyze.mentions_var(body, name) then do // Check if body mentions name (means its recursive)
            info.is_upvalue := true; // Recursive local functions have to be compiled as upvalues due to being compiled as lambdas
            c.append("final "); c.append(compile_upvalue_type(c, ty)); c.append(name); c.append(" = "); c.append("new Upvalue<>();"); c.newline();
        end else do
            c.append("final " + compile_type(c, ty) + " ");
        end;
    end;
    c.append(maybe_upvalue(c, name));
    if !c.is_class do 
        c.append(" = ");
    end
    c.append("(");
    var needs_comma := false;
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.env.insert(name, VariableInfo());
                c.append(compile_type(c, ty)); c.append(" "); c.append(name);
            end;
        end;
        needs_comma := true;
    end;
    c.append(") ");
    if !c.is_class do 
        c.append("-> ");
    end
    val prv := c.open_scope(lenv.get());
    c.is_class := false;
    c.is_static := false;
    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;
    if !body_is_block do c.append(" {"); c.indent(); c.newline(); end;
    val body := compile_expr(c, body, if is_main then Ignore() else Return());
    c.strip_trailing();
    if !body_is_block do c.dedent(); c.newline(); c.append("}"); end;
    c.newline();
    c.close_scope(prv);
    if is_main do 
        c.append("
    public static void main(String[] args) {
        main();
    }");
        c.newline();
    end;
    if !c.is_class do 
        c.append(";");
        c.newline();
    end;
end

// For side-effect-free expressions that dont write to the compiler but only return strings
fun use_with_target(c : Compiler, expr : String, target : Target) : String do 
    match target do 
        case Ignore() := ""; 
        case UsedDirectly() := expr;
        case AssignTo(setter) := do 
            assign(c, setter, expr)
        end;
        case Return() := do 
            return_stmt(c, expr)
        end;
    end
end

fun compile_expr(c : Compiler, expr : Ast.Expr, target : Target) : String := match expr do 
    case NumberLiteral(n) := use_with_target(c, if n % 1 = 0 then n + ".0" else n+"", target);
    case StringLiteral(str) := do 
        var resulting := str;
        resulting := replace(resulting, "\\", "\\\\");
        resulting := replace(resulting, "\n", "\\n");
        resulting := replace(resulting, "\t", "\\t");
        resulting := replace(resulting, "\r", "\\r");
        resulting := replace(resulting, "\"", "\\\"");
        resulting := replace(resulting, "\0", "\\0");
        resulting := "\"" + resulting + "\"";
        use_with_target(c, resulting, target)
    end;
    case ThisExpr() := use_with_target(c, "this", target);
    case TupleExpr(subexprs, lt) := compile_tuple(c, subexprs, lt.get(), target);
    case ListExpr(subexprs, lt) := compile_list_literal(c, subexprs, lt.get(), target);
    case Boolean(b) := use_with_target(c, if b then "true" else "false", target);
    case NullLiteral() := use_with_target(c, "null", target);
    case Identifier(name) := compile_identifier(c, name, target);
    case BinaryOperation(op, left, right) := compile_binary(c, op, left, right, target);
    case UnaryOperation(op, operand) := compile_unary(c, op, operand, target);
    case IfExpr(lt, cond, thenBr, elseBr) := compile_if(c, lt, cond, thenBr, elseBr, target);
    case BlockExpr(stmts, end_expr, lt, lenv) := compile_block(c, stmts, end_expr, lt.get(), lenv, target);
    case FunctionCall(callee, args) := compile_call(c, callee, args, target);
    case FunctionExpr(params, return_type, body, lenv) := compile_function_expr(c, params, return_type, body, lenv.get(), target);
    case PropertyExpr(obj, name, la, lt, lft) := compile_property(c, obj, name, la.get(), lt.get(), lft.get(), target);
    case IndexExpr(lst, idx) := compile_index(c, lst, idx, target);
end;

fun compile_index(c : Compiler, lst : Ast.Expr, idx : Ast.Expr, target : Target) : String do
    if val Ignore() := target then do
        compile_expr(c, lst, Ignore());
        compile_expr(c, idx, Ignore());
        ""
    end else do
        val indexed := compile_expr(c, lst, UsedDirectly());
        val index := compile_expr(c, idx, UsedDirectly());
        use_with_target(c, indexed+".get(__toIndex("+index+"))", target)
    end
end

fun compile_list_literal(c : Compiler, exprs : Ast.Expr[], lty : Ast.Type, target : Target) : String do 
    if val Ignore() := target then do 
        for expr in exprs do 
            compile_expr(c, expr, Ignore());
        end;
        ""
    end else do 
        val Variable(name) := if val AssignTo(s) := target then s else Ast.Variable(c.new_var()) else panic("invalid target for lists: "+target);
        if val AssignTo(?) := target then do end else do 
            val compiled_ty := compile_type(c, lty);
            c.append(compiled_ty); c.append(" ");
        end;
        c.append(name+" = new ArrayList<>("+exprs.length+");"); c.newline();
        for expr in exprs do 
            val field := compile_expr(c, expr, UsedDirectly());
            c.append(""+name+".add("+field+");"); c.newline();
        end
        if val AssignTo(?) := target then "" else use_with_target(c, name, target)
    end
end

fun compile_property(c : Compiler, obj : Ast.Expr, name : String, at : Ast.AccessType, obj_ty : Ast.Type, field_ty : Ast.Type, target : Target) : String do 
    if target = Ignore() then do 
        compile_expr(c, obj, target)
    end else do // Target cannot be Ignore
        match at do 
            case FieldAccess() := do 
                val subexpr := compile_expr(c, obj, UsedDirectly());
                val fieldAccess := subexpr + "." + name;
                use_with_target(c, fieldAccess, target)
            end;
            case MethodAccess() := do 
                val temp_var := c.new_var();
                c.append("final "); c.append(compile_type(c, obj_ty)); c.append(" "); c.append(temp_var); c.append(";"); c.newline();
                compile_expr(c, obj, AssignTo(Ast.Variable(temp_var)));
                val methodAccess := temp_var + "::"+name; // Create method reference. Let java create lambda
                match target do 
                    case AssignTo(s) := assign(c, s, methodAccess);
                    case Return() := return_stmt(c, methodAccess);
                    case UsedDirectly() := do 
                        val resulting_var := c.new_var();
                        c.append("final "); c.append(compile_type(c, field_ty)); c.append(" "); c.append(resulting_var); c.append(" = "); c.append(methodAccess); c.append(";"); c.newline();
                        resulting_var
                    end;
                end
            end;
        end
    end
end

fun compile_tuple(c : Compiler, subexprs : Ast.Expr[], ty : Ast.Type, target : Target) : String do 
    val subexpr_target := match target do 
        case Ignore() := Ignore();
        case ? := UsedDirectly();
    end;
    val exprs := for expr in subexprs yield compile_expr(c, expr, subexpr_target) end;
    if target = Ignore() do 
        return "";
    end
    val tuple_type := compile_type(c, ty); // Name of the corresponding tuple type (will be created and will have a constructor)
    var name := "";
    val setter := if val AssignTo(s) := target then s else do 
        name := c.new_var();
        c.append("final "+tuple_type+" "+name+";");
        c.newline();
        Ast.Variable(name)
    end;
    var buf := "new "+tuple_type+"(";
    var needs_comma := false;
    for expr in exprs do 
        if needs_comma do 
            buf := buf + ", ";
        end 
        buf := buf + expr;
        needs_comma := true;
    end;
    buf := buf + ")";
    assign(c, setter, buf);
    if val Return() := target then do 
        c.append("return "); c.append(name); c.append(";"); c.newline();
        ""
    end else name
end

fun compile_binary(
    c : Compiler, 
    op : Ast.BinOp, 
    left : Ast.Expr,
    right : Ast.Expr,
    target : Target
) : String 
do 
    if Ignore() = target do // Don't need to compile the operation 
        compile_expr(c, left, Ignore());
        compile_expr(c, right, Ignore());
        return "";
    end;
    val operation := do 
        val lhs := compile_expr(c, left, UsedDirectly());
        val rhs := compile_expr(c, right, UsedDirectly());
        val op := compile_bin_op(op);
        "" + lhs + " " + op + " " + rhs
    end;
    match target do 
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
        case UsedDirectly() := "(" + operation + ")";
    end
end

fun compile_unary(c : Compiler, op : Ast.UnOp, operand : Ast.Expr, target : Target) : String do 
    if target = Ignore() do 
        compile_expr(c, operand, Ignore());
        return "";
    end;
    val operation := do 
        val operand_comp := compile_expr(c, operand, UsedDirectly());
        val op_c := compile_un_op(op);
        op_c + operand_comp
    end;
    match target do 
        case UsedDirectly() := "(" + operation + ")";
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
    end
end

fun compile_function_expr(
    c : Compiler,
    params : Ast.Parameter[],
    return_type : Ast.Type,
    body : Ast.Expr,
    env : Env.Env(Ast.VarInfo),
    target : Target) : String
do 
    if Ignore() = target do return ""; end;
    val complete_ty := Ast.Function(param_types(params), return_type);
    var name := "";
    val temp_var := match target do 
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case Return() := Ast.Variable("");
        case AssignTo(setter) := setter;
    end;
    match target do 
        case UsedDirectly() := do 
            c.append("final "); c.append(compile_type(c, complete_ty)); c.append(" "); c.append(name); c.append(" = (");
        end;
        case AssignTo(Variable(n)) := do 
            c.append(n); c.append(" = (");
        end;
        case Return() := do 
            c.append("return (");
        end;
    end;
    val prv := c.open_scope(env);
    var needs_comma := false;
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.env.insert(name, VariableInfo());
                c.append(compile_type(c, ty)); c.append(" "); c.append(name);
            end;
        end;
        needs_comma := true;
    end; 

    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;

    c.append(") -> ");
    if !body_is_block do 
        c.append("{");
        c.indent(); c.newline();
    end
    
    compile_expr(c, body, Return());
    c.strip_trailing();
    if !body_is_block then do
        c.dedent(); c.newline();
        c.append("};"); c.newline();
    end else do 
        c.append(";"); c.newline();
    end;

    c.close_scope(prv);
    name
end

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := for param in params yield 
    match param do 
        case NormalParam(name, ty) := ty;
    end
end;

fun maybe_upvalue(c : Compiler, name : String) : String := 
    if c.env.has(name) and c.env.get(name).is_upvalue then 
        name + ".value"
    else 
        name;

fun compile_identifier(c : Compiler, fname : String, target : Target) : String do
    if Ignore() = target do // Identifier has no side effects, so ignore means nothing has to be compiled
        return "";
    end;
    if val Function(args, ret_type) := c.current_env.get(fname).ty then do
        if !c.env.get(fname).is_no_fc_fn do // Value is a first class function already
            // Value might be an upvalue
            return use_with_target(c, maybe_upvalue(c, fname), target); // No lambda has to be created
        end;
        // Value is a first class function and therefore cannot be an upvalue
        val ty := compile_type(c, c.current_env.get(fname).ty);
        var name := "";
        val temp_var := match target do 
            case Return() := Ast.Variable("");
            case UsedDirectly() := do 
                name := c.new_var();
                Ast.Variable(name)
            end;
            case AssignTo(setter) := setter;
        end;
        match target do 
            case Return() := do 
                c.append("return ");
            end;
            case UsedDirectly() := do 
                c.append(ty); c.append(" "); c.append(name); c.append(" = ");
            end;
            case AssignTo(Variable(x)) := do 
                c.append(x); c.append(" = ");
            end;
        end;
        c.append("(");
        val params : String[] := [];
        var needs_comma := false;
        for param in args do 
            if needs_comma do 
                c.append(", ");
            end;
            val arg_name := c.new_var();
            c.append(compile_type(c, param)); c.append(" "); c.append(arg_name);
            params.push(arg_name);
            needs_comma := true;
        end;
        c.append(") -> "); if c.env.get(fname).is_constructor do c.append("new "); end; c.append(fname); c.append("(");
        needs_comma := false;
        for param in params do 
            if needs_comma do 
                c.append(", ");
            end
            c.append(param);
        end;
        c.append(");");
        c.newline();
        name
    end else do 
        // Normal variable, might be an upvalue
        use_with_target(c, maybe_upvalue(c, fname), target)
    end
end

fun create_enqueued_type(c : Compiler, ty : Ast.Type) : String do 
    if val Some(name) := c.get_enqueued_type(ty) then do 
        name 
    end else do 
        val type_name := c.new_var();
        c.enqueue_type(ty, type_name);
        type_name
    end
end

fun compile_call(c : Compiler, callee : Ast.Expr, args : Ast.Expr[], target : Target) : String do 
    val callee_compiled := if val Identifier(name) := callee then do 
        val info := c.env.get(name);
        if info.is_no_fc_fn then 
            name 
        else if info.is_constructor then 
            "new " + name
        else
            compile_expr(c, callee, UsedDirectly()) + ".call"
    end else if val PropertyExpr(obj, name, la, lt, lft) := callee then do 
        val obj_expr := compile_expr(c, obj, UsedDirectly());
        if val MethodAccess() := la.get() then obj_expr + "." + name else obj_expr + "." + name  + ".call"
    end else do 
        compile_expr(c, callee, UsedDirectly()) + ".call"
    end;
    val args_compiled := for arg in args yield 
        compile_expr(c, arg, UsedDirectly())
    end;
    var str := "";
    str := str + callee_compiled + "(";
    var needs_comma := false;
    for arg in args_compiled do 
        if needs_comma do 
            str := str + ", ";
        end;
        str := str + arg;
        needs_comma := true;
    end;
    str := str + ")";
    match target do 
        case Ignore() := do c.append("ignore("); c.append(str); c.append(");"); c.newline(); "" end;
        case Return() := do 
            return_stmt(c, str)
        end;
        case UsedDirectly() := str;
        case AssignTo(setter) := do 
            assign(c, setter, str)
        end;
    end
end

fun compile_block(
    c : Compiler, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    t : Ast.Type,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)),
    target : Target) : String 
do 
    var name := "";
    var var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter; 
    end;
    if target = UsedDirectly() do 
        c.append("final "); 
        c.append(compile_type(c, t)); 
        c.append(" "); 
        c.append(name);
        c.append(";"); 
        c.newline(); 
    end;
    c.append("{"); c.indent(); c.newline();
    val prv := c.open_scope(lenv.get());
    val captures := Analyze.analyze_captures(stmts, end_expr);
    for (name, is_captured) in captures.bindings do 
        if is_captured do 
            val info := VariableInfo();
            info.is_upvalue := true;
            c.env.insert(name, info); // Mark as upvalue
        end
    end;
    for stmt in stmts do 
        compile_stmt(c, stmt);
    end;
    if val Some(e) := end_expr then do 
        val resulting_target := match target do 
            case Ignore() := Ignore();
            case Return() := Return();
            case UsedDirectly() := AssignTo(var_name);
            case AssignTo(?) := AssignTo(var_name);
        end;
        val ? := compile_expr(c, e, target);
    end else do 
        match target do 
            case Ignore() := Ignore();
            case Return() := c.append("return null;");
            case UsedDirectly() := do 
                name := "null"; // Just user null as inline expression 
            end; 
            case AssignTo(setter) := do 
                assign(c, setter, "null");
            end;
        end;
    end;
    c.strip_trailing();
    c.dedent(); c.newline();
    c.append("}");
    c.close_scope(prv);
    name
end

fun compile_bin_op(op : Ast.BinOp) : String := match op do 
    case Add() := "+";
    case Sub() := "-";
    case Mul() := "*";
    case Div() := "/";
    case Mod() := "%";
    case LessThan() := "<";
    case LessEqual() := "<=";
    case Equals() := "==";
    case NotEquals() := "!=";
    case GreaterThan() := ">";
    case GreaterEqual() := ">=";
    case And() := "&&";
    case Or() := "||";
    case Xor() := "^";
end;

fun compile_un_op(op : Ast.UnOp) : String := match op do 
    case Plus()  := "+";
    case Minus() := "-";
    case Not()   := "!";
end;

fun compile_if(
    c : Compiler, 
    lt : Util.LateInitialized(Ast.Type),
    cond : Ast.Expr, 
    thenBr : Ast.Expr, 
    elseBr : Ast.Expr,
    target : Target) : String do 
    var name := "";
    val var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter;
    end;
    if target = UsedDirectly() do
        c.append("final "); c.append(compile_type(c, lt.get())); c.append(" "); c.append(name); c.append(";"); c.newline();
    end;
    val prev_buf := c.buf; // Safe buffer before if to backtrack in case the if is not necessare
    c.buf := "";
    val branch_target := match target do 
        case Ignore() := Ignore();
        case Return() := Return();
        case ? := AssignTo(var_name);
    end;
    val cond_expr := compile_expr(c, cond, UsedDirectly());
    val cond_buf := c.buf;
    c.buf := "";
    c.append("if("); c.append(cond_expr); c.append(") {"); c.indent(); c.newline();
    val if_buf := c.buf;
    c.buf := "";
    val thenBrExpr := compile_expr(c, thenBr, branch_target);
    val thenIsIgnored := thenBrExpr = "" and c.buf = "";
    c.strip_trailing();c.dedent();c.newline(); c.append("} else {"); c.indent();c.newline();
    val else_buf := c.buf;
    c.buf := "";
    val elseBrExpr := compile_expr(c, elseBr, branch_target);
    val elseIsIgnored := elseBrExpr = "" and c.buf = "";
    c.strip_trailing();c.dedent(); c.newline(); c.append("}"); c.newline();
    val end_buf := c.buf;
    c.buf := prev_buf; // Restore previous buffer
    if thenIsIgnored and elseIsIgnored and Ignore() = target then do // Both branches can be ignored
        c.append(compile_expr(c, cond, Ignore())); // Recompile condition as ignored
        c.newline();
    end else do 
        c.append(cond_buf + if_buf + else_buf + end_buf); // Create whole branch in buffer
    end;
    name
end

fun compile_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := if c.expect_ref_ty then "Double" else "double";
    case BooleanT() := if c.expect_ref_ty then "Boolean" else "boolean";
    case StringT() := "String";
    case VoidT() := "Void";
    case ListOf(et) := do 
        val pref_expect_ref_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        val result := "ArrayList<"+compile_type(c, et)+">";
        c.expect_ref_ty := pref_expect_ref_ty;
        result
    end;
    case Function(?, ?) := create_enqueued_type(c, t);
    case Tuple(?) := create_enqueued_type(c, t);
    case Name(name) := name; // Classes are compiled with their name
end;

fun compile_upvalue_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := "NumberUpvalue";
    case BooleanT() := "BooleanUpvalue";
    case ? := "Upvalue<"+compile_type(c, t)+">";
end;

fun compile_enqueued_types(c : Compiler) do 
    while c.types_to_compile != [] do 
        val task := c.types_to_compile.pop();
        compile_task(c, task);
    end
end

fun compile_task(c : Compiler, task : CompilationTask) do 
    match task do 
        case CreateFunctionalInterface(args, ret_ty, name) := do
            c.append("@FunctionalInterface static interface "); c.append(name); c.append(" {");
            c.indent(); c.newline();
            c.append(compile_type(c, ret_ty));
            c.append(" call(");
            var needs_comma := false;
            for arg in args do 
                if needs_comma do 
                    c.append(", ");
                end
                c.append(compile_type(c, arg)); c.append(" ");c.append(c.new_var());
                needs_comma := true;
            end
            c.append(");");
            c.dedent(); c.newline();
            c.append("}");
            c.newline();
            c.compiled_types.push((name, Ast.Function(args, ret_ty)));
        end;
        case CreateTupleType(parts, name) := do 
            c.append("static record "); c.append(name); c.append("(");
            var counter := 0;
            var needs_comma := false;
            for ty in parts do 
                if needs_comma do 
                    c.append(", ");
                end
                c.append(compile_type(c, ty)); c.append(" "); c.append("field"+counter);
                counter := counter + 1;
                needs_comma := true;
            end;
            c.append(") {");
            c.indent(); c.newline();
            c.append("public String toString() {");
            c.indent(); c.newline();
            c.append("StringBuilder builder = new StringBuilder();");
            c.newline();
            c.append("builder.append(\"(\");");
            c.newline();
            needs_comma := false;
            for i in [0..counter] do 
                if needs_comma do 
                    c.append("builder.append(\", \");");
                    c.newline();
                end;
                c.append("builder.append("); c.append("field"+i); c.append(");");
                c.newline();
                needs_comma := true;
            end; 
            c.append("builder.append(\")\");");
            c.newline();
            c.append("return builder.toString();");
            c.dedent(); c.newline();
            c.append("}");
            c.dedent(); c.newline();
            c.append("}");
            c.newline();
        end;
    end;
end

fun assign(c : Compiler, to : Ast.Setter, from : String) : String do 
    match to do 
        case Variable(name) := do 
            c.append(maybe_upvalue(c, name));
            c.append(" = ");
            c.append(from);
            c.append(";");
            c.newline();
        end;
        case TupleSetter(parts, t) := do 
            val temp_var := c.new_var();
            c.append("final "); c.append(compile_type(c, t.get())); c.append(" "); c.append(temp_var);
            c.append(" = "); c.append(from); c.append(";"); c.newline();
            for i in [0..parts.length] do 
                assign(c, parts[i], temp_var+".field"+i+"()");
            end;
        end;
        case Property(obj, name, ct) := do 
            val object := compile_expr(c, obj, UsedDirectly());
            c.append(object); c.append("."); c.append(name); c.append(" = "); c.append(from); c.append(";"); c.newline();
        end;
    end;
    ""
end

fun return_stmt(c : Compiler, expr : String) : String do 
    c.append("return "); c.append(expr); c.append(";"); c.newline();
    ""
end 
