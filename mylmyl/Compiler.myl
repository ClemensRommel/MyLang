module Compiler;

import Ast;
import Env;
import Analyze;
import Util;
import NameGen;
import SourceFileGatherer;

class Compiler where 
    var buf : String := "";
    var indent_level : Number := 0;
    var name_gen : NameGen.NameGenerator;

    var is_class : Bool := true;
    var is_static : Bool := true;
    var is_generated_interface : Bool := false;
    var expect_ref_ty : Bool := false; // Wether we're currently compiling a type that is a type parameter

    val types_to_compile : CompilationTask[] := [];
    val compiled_types : (String, Ast.Type)[] := [];

    var current_env : Env.Env(Ast.VarInfo);

    var env : Env.Env(VariableInfo) := Env.Env.[VariableInfo]();

    val all_modules : Env.AList(Env.Env(VariableInfo));

    val loop_labels : String[] := [];

    new(globals : Env.Env(Ast.VarInfo), nameg : NameGen.NameGenerator, modules : Env.AList(Env.Env(VariableInfo))) do 
        this.current_env := globals;
        this.name_gen := nameg;
        this.all_modules := modules;

        declare_builtins(this);
    end

    fun append(str : String) do
        this.buf := this.buf + str;
    end

    fun newline() do 
        this.append("\n");
        for i in [0..this.indent_level] do 
            this.append("    ");
        end;
    end

    fun indent() do 
        this.indent_level := this.indent_level + 1;
    end
    
    fun dedent() do 
        if this.indent_level <= 0 do 
            panic("Error: Negative Indent impossible");
        end;
        this.indent_level := this.indent_level - 1; 
    end

    fun strip_trailing() do 
        this.buf := strip(this.buf);
    end

    fun new_var() : String := this.name_gen.next_name();

    fun enqueue_type(t : Ast.Type, type_name : String) do 
        match t do 
            case Function(args, ret) := do 
                this.types_to_compile.push(CreateFunctionalInterface(args, ret, type_name));
            end;
            case Tuple(parts) := do 
                this.types_to_compile.push(CreateTupleType(parts, type_name));
            end;
        end;
    end
    
    fun get_enqueued_type(t : Ast.Type) : Util.Optional(String) do
        for task in this.types_to_compile do 
            match task do 
                case CreateFunctionalInterface(args, ret, name) := do
                    if t = Ast.Function(args, ret) do 
                        return Util.Some.[String](name);
                    end;
                end;
                case CreateTupleType(parts, name) := do 
                    if t = Ast.Tuple(parts) do 
                        return Util.Some.[String](name);
                    end;
                end;
                case ? := do end;
            end;
        end;
        for (name, ty) in this.compiled_types do 
            if ty = t do 
                return Util.Some.[String](name);
            end;
        end;
        Util.None.[String]()
    end

    fun open_scope(env : Env.Env(Ast.VarInfo)) : ScopeInfo do 
        val previous_is_class := this.is_class;
        val previous_is_static := this.is_static;
        val previous_env := this.current_env;
        val previous_is_generated_interface := this.is_generated_interface;
        this.current_env := env;
        this.env := this.env.open_scope();
        this.is_class := false;
        this.is_static := false;
        this.is_generated_interface := false;
        ScopeInfo(previous_is_class, previous_env, previous_is_static, previous_is_generated_interface)
    end

    fun close_scope(sci : ScopeInfo) do 
        this.is_static := sci.previous_is_static;
        this.is_class := sci.previous_is_class;
        this.current_env := sci.previous_env;
        this.is_generated_interface := sci.previous_is_generated_interface;
        this.env := this.env.close_scope();
    end
end

class ScopeInfo where 
    val previous_is_class : Bool;
    val previous_env : Env.Env(Ast.VarInfo);
    val previous_is_static : Bool;
    val previous_is_generated_interface : Bool;
    new(pic : Bool, penv : Env.Env(Ast.VarInfo), pis : Bool, pigi : Bool) do 
        this.previous_is_class := pic;
        this.previous_env := penv;
        this.previous_is_static := pis;
        this.previous_is_generated_interface := pigi;
    end
end

enum CompilationTask where 
    CreateTupleType(Ast.Type[], String),
    CreateFunctionalInterface(Ast.Type[], Ast.Type, String);
end;

enum Target where 
    Ignore(), UsedDirectly(), Return(), AssignTo(Ast.Setter);
end

class VariableInfo where 
    var is_no_fc_fn : Bool := false;
    var is_constructor : Bool := false;
    var is_upvalue : Bool := false;
end

fun declare_builtins(c : Compiler) do 
    c.env.insert("panic", do val panic_info := VariableInfo(); panic_info.is_no_fc_fn := true; panic_info end);
end

fun gather_global_variable_info(files : Env.AList(SourceFileGatherer.SourceFile)) : Env.AList(Env.Env(VariableInfo)) do 
    val list := Env.AList.[Env.Env(VariableInfo)]();
    for (?, file) in files.bindings do 
        val env := Env.Env.[VariableInfo]();
        gather_variable_info(env, file.ast.decls);
        list.insert(file.path, env);
    end
    list
end

fun compile(file : SourceFileGatherer.SourceFile, name_gen : NameGen.NameGenerator, infos : Env.AList(Env.Env(VariableInfo))) : String do 
    val c := Compiler(file.globals_env.get(), name_gen, infos);
    c.env := infos.get(file.path);
    val path_parts := split(file.path, "/"); // Parts of path
    val file_name_parts := split(path_parts.last, "\\."); // Name before extension
    val file_name := file_name_parts.first;
    declare_package(c, path_parts);
    import_implicits(c);
    compile_imports(c, file.ast.imports);
    c.append("public class "+file_name+" {");
    c.indent(); c.newline();
    for decl in file.ast.decls do 
        compile_decl(c, decl);
    end;
    compile_enqueued_types(c);
    c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.buf
end

fun gather_variable_info(env : Env.Env(VariableInfo), decls : Ast.Decl[]) do 
    fun gather_info(decl : Ast.Decl) do 
        match decl do 
            case DesugarableDecl(mutdecl) := gather_info(mutdecl.get());
            case FunDecl(name, ?, ?, ?, ?, ?) := do 
                val info := VariableInfo();
                info.is_no_fc_fn := true; // Global functions cant be lambdas
                env.insert(name, info);
            end;
            case ClassDecl(name, ?, ?, ?, ?) := do 
                val info := VariableInfo();
                info.is_constructor := true;
                info.is_no_fc_fn := true;
                env.insert(name, info);
            end;
            case EnumDecl(?, constrs, ?, ?, ?) := do 
                for constr in constrs do 
                    val info := VariableInfo();
                    info.is_constructor := true;
                    info.is_no_fc_fn := true;
                    env.insert(constr.name, info);
                end;
            end;
            case VarDecl(setter, ?, ?, ?, ?) := do 
                gather_info_for_setter(env, setter);
            end;
            case ValElseDeclaration(pat, ?, ?, ?, ?, ?, ?, ?) := do 
                gather_info_for_pattern(env, pat);
            end;
        end;
    end
    for decl in decls do 
        gather_info(decl);
    end
end

fun gather_info_for_setter(env : Env.Env(VariableInfo), setter : Ast.Setter) do 
    match setter do 
        case Variable(name) := do env.insert(name, VariableInfo()); end; //Globals cant be upvalues
        case TupleSetter(parts, ?) := do for part in parts do gather_info_for_setter(env, part); end; end;
        case Property(?, ?, ?) := do end;
    end;
end

fun gather_info_for_pattern(env : Env.Env(VariableInfo), pat : Ast.Pattern) do 
    match pat do 
        case NumericPattern(?) := do end;
        case StringPattern(?) := do end;
        case BooleanPattern(?) := do end;
        case NamePattern(name) := do env.insert(name, VariableInfo()); end;
        case WildcardPattern() := do end;
        case TuplePattern(parts) := do for part in parts do gather_info_for_pattern(env, part); end; end;
        case ConstructorPattern(?, parts, ?) := do for part in parts do gather_info_for_pattern(env, part); end; end;
    end;
end;

fun declare_package(c : Compiler, path : String[]) do 
    if path.length > 1 do 
        c.append("package ");
        for i in [0..path.length - 1] do 
            c.append(path[i]);
        end
        c.append(";"); c.newline(); 
        c.newline();
    end
end

fun import_implicits(c : Compiler) do 
    c.append("import static std.runtime.Functions.*;");
    c.newline();
    c.append("import std.runtime.*;");
    c.newline();
    c.newline();
    c.append("import java.util.ArrayList;");
    c.newline();

    c.newline();
end

fun compile_imports(c : Compiler, imports : Ast.Import[]) do 
    for i in imports do 
        match i do 
            case BasicImport(parts) := do 
                if parts.length > 1 do // Classes without package before them dont need to be imported
                    c.append("import ");
                    var needs_dot := false;
                    for part in parts do 
                        if needs_dot do c.append("."); end;
                        c.append(part);
                        needs_dot := true;
                    end;
                    c.append(";"); c.newline();
                end;
            end;
        end;
    end;
    c.newline();
end

fun compile_stmt(c : Compiler, stmt : Ast.Stmt) := match stmt do 
    case ExprStmt(expr) := do 
        val arg := compile_expr(c, expr, Ignore());
    end;
    case EmptyStmt() := do end;
    case PrintStmt(expr) := do 
        if val NullLiteral() := expr then do 
            c.append("System.out.println(\"null\");"); c.newline();
        end else do 
            val arg := compile_expr(c, expr, UsedDirectly());
            c.append("System.out.println(");c.append(arg);c.append(");");
            c.newline();
        end
    end;
    case Declaration(decl) := compile_decl(c, decl);
    case SetStatement(setter, expr) := compile_expr(c, expr, AssignTo(setter));
end;

fun compile_decl(c : Compiler, decl : Ast.Decl) := match decl do 
    case DesugarableDecl(md) := compile_decl(c, md.get());
    case VarDecl(setter, lt, init, mutable, ?) := compile_var_decl(c, setter, lt, init, mutable);
    case FunDecl(name, params, return_type, body, ?, lenv) := compile_fun_decl(c, name, params, return_type, body, lenv);
    case ClassDecl(name, members, opt_constr, ?, lenv) := compile_class_decl(c, name, members, opt_constr, lenv.get());
    case EnumDecl(name, variants, members, ?, lenv) := compile_enum_decl(c, name, variants, members, lenv.get());
end;

fun compile_enum_decl(c : Compiler, name : String, variants : Ast.EnumConstructor[], members : Ast.Decl[], env : Env.Env(Ast.VarInfo)) do 
    val prefix := (if c.is_class then "public " else "") + (if c.is_static then "static " else "");
    c.append(prefix);
    c.append(" sealed interface "); c.append(name); c.append(" {");
    c.indent(); c.newline();
    val prv := c.open_scope(env);
    c.is_class := true;
    c.is_generated_interface := true;
    for member in members do 
        compile_decl(c, member);
    end;
    c.strip_trailing(); c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    for variant in variants do 
        compile_enum_variant(c, name, prefix, variant);
    end;
end

fun compile_enum_variant(c : Compiler, name : String, prefix : String, variant : Ast.EnumConstructor) do 
    c.append(prefix); c.append(" record "); c.append(variant.name); c.append("(");
    var i := 0;
    var need_comma := false;
    for field in variant.fields do 
        if need_comma do c.append(", "); end;
        c.append(compile_type(c, field)); c.append(" __field"+i); 
        i := i + 1; need_comma := true; 
    end; 
    c.append(") implements "); c.append(name); c.append(" {");
    c.indent(); c.newline();
    c.append("@Override public String toString() {"); c.indent(); c.newline();
        c.append("StringBuilder __builder = new StringBuilder();"); c.newline();
        c.append("__builder.append(\""+variant.name+"(\");"); c.newline();
        var needs_comma := false;
        for i in [0..variant.fields.length] do 
            if needs_comma do c.append("__builder.append(\", \");"); end;
            c.append("__builder.append(__field"+i+"());"); c.newline();
            needs_comma := true;
        end;
        c.append("__builder.append(\")\");"); c.newline();
        c.append("return __builder.toString();"); c.dedent(); c.newline();
        c.append("} "); c.dedent(); c.newline();
    c.append("}"); c.newline();
    val info := VariableInfo();
    info.is_constructor := true;
    info.is_no_fc_fn := true;
    c.env.insert(variant.name, info);
end

fun compile_class_decl(
    c : Compiler, 
    name : String, 
    members : Ast.Decl[], 
    constr : Util.Optional(Ast.Constructor), 
    env : Env.Env(Ast.VarInfo)) 
do
    if c.is_class do 
        c.append("public ");
    end;
    if c.is_static do 
        c.append("static ");
    end
    c.append("class "+name+" {");
    c.indent(); c.newline();
    val prv := c.open_scope(env);
    c.is_class := true;
    for member in members do 
        compile_decl(c, member);
    end
    compile_constructor(c, constr, name);
    c.strip_trailing(); c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    val info := VariableInfo();
    info.is_constructor := true;
    info.is_no_fc_fn := true;
    c.env.insert(name, info);
end

fun compile_constructor(c : Compiler, constr : Util.Optional(Ast.Constructor), name : String) do
    val Some(construct) := constr else return null;
    c.append("public "+name);
    c.append("(");
    var needs_comma := false;
    for param in construct.params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.append(compile_type(c, ty)); c.append(" "+name);
            end;
        end;
        needs_comma := true;
    end 
    c.append(") ");
    compile_expr(c, construct.body, Ignore());
end

fun compile_variables(
    c : Compiler, 
    setter : Ast.Setter, 
    ty : Ast.Type, 
    is_global : Bool, 
    mutable : Bool, 
    is_upvalue : Bool) 
do 
    match setter do 
        case Variable(name) := do 
            if c.is_class do c.append("public "); end;
            if c.is_static do c.append("static "); end;
            if !mutable do c.append("final "); end;
            val ty_compiled := if is_upvalue then compile_upvalue_type(c, ty) else compile_type(c, ty);
            c.append(ty_compiled); c.append(" "); c.append(name); 
            if is_upvalue do 
                c.append(" = new ");
                c.append(ty_compiled);
                c.append("()");
            end;
            c.append(";");
            c.newline();
        end;
        case TupleSetter(parts, ?) := do 
            val Tuple(types) := ty else panic("Non-tuple type in tuple setter "+setter);
            for i in [0..parts.length] do 
                compile_variables(c, parts[i], types[i], is_global, mutable, is_upvalue);
            end;
        end;
        case Property(?, ?, ?) := panic("Unreachable: Cannot assign to field of object in declaration");
    end;
end

fun compile_var_decl(
    c : Compiler, 
    setter : Ast.Setter, 
    lt : Util.LateInitialized(Ast.Type), 
    init_mut : Util.Optional(Ast.Expr), 
    mutable : Bool) 
do
    val init := if val Some(e) := init_mut then Util.Some.[Ast.Expr](e) else Util.None.[Ast.Expr]();
    if c.is_class then do
        compile_variables(c, setter, lt.get(), true, mutable, false);
        if val Some(e) := init then do 
            if c.is_static do c.append("static "); end;
            c.append("{");
            c.indent(); c.newline();
            val initializer := compile_expr(c, e, AssignTo(setter));
            c.strip_trailing();
            c.dedent(); c.newline();
            c.append("}");
        end else do end;
        c.newline();
        // Global variables are not pre-analyzed for captures, because they cannot be captured
    end else do
        val is_upvalue := setter_is_upvalue(c, setter);
        compile_variables(c, setter, lt.get(), false, mutable, is_upvalue);
        if val Some(e) := init then do
            compile_expr(c, e, AssignTo(setter));
        end else do end;
    end;
    declare_variables(c, setter);
end

fun declare_variables(c : Compiler, setter : Ast.Setter) do 
    match setter do 
        case Variable(name) := c.env.insert_if_missing(name, VariableInfo());
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                declare_variables(c, part);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot declare property as variable: Unreachable");
    end;
end

fun setter_is_upvalue(c : Compiler, setter : Ast.Setter) : Bool :=
    match setter do 
        case Variable(name) := c.env.has(name) and c.env.get(name).is_upvalue;
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                if setter_is_upvalue(c, part) do return true end;
            end
            false
        end;
        case Property(?, ?, ?) := false;
    end;

fun compile_fun_decl(
    c : Compiler, 
    name : String, 
    params : Ast.Parameter[], 
    return_type : Ast.Type, 
    body : Ast.Expr,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)))
do 
    val info := VariableInfo();
    info.is_no_fc_fn := c.is_class; // Local functions cannot be compiled directly but to lambdas
    c.env.insert(name, info); // Functions can never be captured, so unconditionally insert info
    val is_main := c.is_static and name = "main" and return_type = Ast.VoidT();
    if c.is_class then do 
        c.append("public ");
        if c.is_static do c.append("static "); end; 
        if c.is_generated_interface do c.append("default "); end;
        if is_main then do 
            c.append("void");
        end else do
            c.append(compile_type(c, return_type)); 
        end;
        c.append(" ");
    end else do
        val ty := c.current_env.get(name).ty;
        if val Function(?, ?) := ty then do end 
               else panic("Unreachable: Function is being compiled that has non-function-type");
        if Analyze.mentions_var(body, name) then do // Check if body mentions name (means its recursive)
            info.is_upvalue := true; // Recursive local functions have to be compiled as upvalues due to being compiled as lambdas
            c.append("final "); c.append(compile_upvalue_type(c, ty)); c.append(name); 
            c.append(" = "); c.append("new Upvalue<>();"); c.newline();
        end else do
            c.append("final " + compile_type(c, ty) + " ");
        end;
    end;
    c.append(maybe_upvalue(c, name));
    if !c.is_class do 
        c.append(" = ");
    end
    c.append("(");
    var needs_comma := false;
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.env.insert(name, VariableInfo());
                c.append(compile_type(c, ty)); c.append(" "); c.append(name);
            end;
        end;
        needs_comma := true;
    end;
    c.append(") ");
    if !c.is_class do 
        c.append("-> ");
    end
    val prv := c.open_scope(lenv.get());
    c.is_class := false;
    c.is_static := false;
    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;
    if !body_is_block do c.append(" {"); c.indent(); c.newline(); end;
    val body := compile_expr(c, body, if is_main then Ignore() else Return());
    c.strip_trailing();
    if !body_is_block do c.dedent(); c.newline(); c.append("}"); end;
    c.newline();
    c.close_scope(prv);
    if is_main do 
        c.append("
    public static void main(String[] args) {
        main();
    }");
        c.newline();
    end;
    if !c.is_class do 
        c.append(";");
        c.newline();
    end;
end

// For side-effect-free expressions that dont write to the compiler but only return strings
fun use_with_target(c : Compiler, expr : String, target : Target) : String do 
    match target do 
        case Ignore() := ""; 
        case UsedDirectly() := expr;
        case AssignTo(setter) := do 
            assign(c, setter, expr)
        end;
        case Return() := do 
            return_stmt(c, expr)
        end;
    end
end

fun escape_string(str : String) : String do 
    var resulting := str;
    resulting := replace(resulting, "\\", "\\\\");
    resulting := replace(resulting, "\n", "\\n");
    resulting := replace(resulting, "\t", "\\t");
    resulting := replace(resulting, "\r", "\\r");
    resulting := replace(resulting, "\"", "\\\"");
    resulting := replace(resulting, "\0", "\\0");
    resulting := "\"" + resulting + "\"";
    resulting
end

fun compile_expr(c : Compiler, expr : Ast.Expr, target : Target) : String := match expr do 
    case DesugarableExpr(content) := compile_expr(c, content.get(), target);
    case NumberLiteral(n) := use_with_target(c, if n % 1 = 0 then n + ".0" else n+"", target);
    case StringLiteral(str) := do 
        use_with_target(c, escape_string(str), target)
    end;
    case ThisExpr() := use_with_target(c, "this", target);
    case TupleExpr(subexprs, lt) := compile_tuple(c, subexprs, lt.get(), target);
    case ListExpr(subexprs, lt) := compile_list_literal(c, subexprs, lt.get(), target);
    case RangeExpr(start, end_expr) := compile_range_expr(c, start, end_expr, target);
    case Boolean(b) := use_with_target(c, if b then "true" else "false", target);
    case NullLiteral() := use_with_target(c, "null", target);
    case Identifier(name, lty) := compile_identifier(c, name, lty.get(), target);
    case BinaryOperation(op, left, right) := compile_binary(c, op, left, right, target);
    case UnaryOperation(op, operand) := compile_unary(c, op, operand, target);
    case IfExpr(lt, cond, thenBr, elseBr) := compile_if(c, lt, cond, thenBr, elseBr, target);
    case BlockExpr(stmts, end_expr, lt, lenv) := compile_block(c, stmts, end_expr, lt.get(), lenv, target);
    case ForExpr(loop_var, iterated, body, lenv, lt, lit) := compile_for(c, loop_var, 
                                                                         iterated, body, 
                                                                         lenv.get(), lt.get(), lit.get(), 
                                                                         target);
    case WhileExpr(cond, body, lenv, lty) := compile_while(c, cond, body, lenv.get(), lty.get(), target);
    case FunctionCall(callee, args) := compile_call(c, callee, args, target);
    case FunctionExpr(params, return_type, body, lenv) := compile_function_expr(c, params, return_type, body, lenv.get(), target);
    case PropertyExpr(obj, name, la, lt, lft) := compile_property(c, obj, name, la.get(), lt.get(), lft.get(), target);
    case IndexExpr(lst, idx) := compile_index(c, lst, idx, target);
    case MatchExpr(matched, arms, lmatchty, lretty) := compile_match(c, matched, arms, lmatchty.get(), lretty.get(), target);
    case ReturnExpr(ret, lty) := compile_return(c, ret, lty.get(), target);
    case Break(lty) := compile_break(c, lty.get(), target);
end;

fun compile_break(c : Compiler, expected_ty : Ast.Type, target : Target) : String do 
    c.append("if(true) break "+c.loop_labels.last+";"); c.newline();
    use_with_target(c, default_value(expected_ty), target)
end

fun compile_return(c : Compiler, ret : Ast.Expr, needed_ty : Ast.Type, target : Target) : String do 
    
    c.append("if(true) "); // Suppress unreachable code error
    compile_expr(c, ret, Return());
    use_with_target(c, default_value(needed_ty), target)
end

fun default_value(ty : Ast.Type) : String := match ty do 
        case NumberT() := "0.0"; 
        case BooleanT() := "false"; 
        case StringT() := "\"\""; 
        case VoidT() := "null";
        case Tuple(?) := "null"; 
        case Name(?, ?) := "null"; // Types that are refered to by name are objects, so nullable
        case Function(?, ?) := "null"; 
        case ListOf(?) := "null"; 
        case Never() := "null";
    end;

fun compile_match(
    c : Compiler, 
    matched : Ast.Expr, 
    arms : (Ast.Pattern, Ast.Expr, Util.LateInitialized(Env.Env(Ast.VarInfo)))[], 
    matched_ty : Ast.Type, 
    ret_ty : Ast.Type, 
    target : Target) : String 
do 
    val matched_compiled := compile_expr(c, matched, UsedDirectly());
    val arm_target := if val UsedDirectly() := target then do 
        val temp_var := c.new_var();
        c.append("final "); c.append(compile_type(c, ret_ty)); c.append(" "); c.append(temp_var); c.append(";"); c.newline();
        AssignTo(Ast.Variable(temp_var))
    end else target;
    c.append("switch("); 
    if val NumberT() := matched_ty then do 
        c.append("(Double) "); 
    end else do end; 
    c.append(matched_compiled); c.append(") {"); c.indent(); c.newline();
    for (patt, expr, lenv) in arms do 
        val prv := c.open_scope(lenv.get());
        c.append("case "); compile_pattern(c, patt, matched_ty); c.append(" -> {"); c.indent(); c.newline(); 
        compile_expr(c, expr, arm_target); c.strip_trailing(); 
        c.dedent(); c.newline(); c.append("}"); c.newline();
        c.close_scope(prv);
    end;
    c.dedent(); c.newline(); c.append("}"); c.newline();
    if val UsedDirectly() := target then do 
        val AssignTo(Variable(temp)) := arm_target else panic("Unreachable: Invalid arm target");
        temp
    end else ""
end;

fun compile_pattern(c : Compiler, pattern : Ast.Pattern, matched_ty : Ast.Type) do 
    if val StringPattern(str) := pattern then do 
        c.append(escape_string(str));
    end else if val BooleanPattern(b) := pattern then do 
        c.append(""+b);
    end else if val NumericPattern(n) := pattern then do 
        val temp := c.new_var();
        c.append("Double "+temp+" when "+temp+" == "+n);
    end else if val NamePattern(n) := pattern then do 
        val prv_box_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        c.append(compile_type(c, matched_ty)); c.append(" "); c.append(n);
        c.expect_ref_ty := prv_box_ty;
    end else do 
        val guard_queue : String[] := [];
        compile_complex_pattern(c, pattern, guard_queue, matched_ty);
        if guard_queue.length > 0 do 
            c.append(" when ");
            var needs_and := false;
            for guard in guard_queue do 
                if needs_and do c.append(" && "); end;
                c.append(guard);
                needs_and := true;
            end
        end
    end;
end

fun compile_complex_pattern(
    c : Compiler, 
    pattern : Ast.Pattern, 
    guard_queue : String[], 
    matched_ty : Ast.Type) := match pattern do 
    case NumericPattern(n) := do 
        val variable := c.new_var(); 
        c.append("var "+variable); 
        guard_queue.push(variable+" == "+n); 
    end;
    case StringPattern(str) := do 
        val variable := c.new_var();
        c.append("String "+variable);
        guard_queue.push(variable+".equals("+escape_string(str)+")");
    end;
    case BooleanPattern(b) := do 
        val variable := c.new_var();
        c.append(compile_type(c, matched_ty)+" "+variable);
        guard_queue.push(if b then variable else "!"+variable);
    end;
    case NamePattern(n) := c.append(compile_type(c, matched_ty)+" "+n);
    case WildcardPattern() := c.append(compile_type(c, matched_ty)+" "+c.new_var());
    case ConstructorPattern(name, subpatterns, constr) := do 
        c.append(name); c.append("(");
        var needs_comma := false;
        for i in [0..subpatterns.length] do 
            if needs_comma do c.append(", ");  end;
            compile_complex_pattern(c, subpatterns[i], guard_queue, constr.get().fields[i]);
            needs_comma := true;
        end;
        c.append(")");
    end;
    case TuplePattern(subpatterns) := do 
        c.append(compile_type(c, matched_ty));
        c.append("(");
        var needs_comma := false;
        val Tuple(subtys) := matched_ty else panic("No tuple type in tuple pattern");
        for i in [0..subpatterns.length] do 
            if needs_comma do c.append(", "); end;
            compile_complex_pattern(c, subpatterns[i], guard_queue, subtys[i]);
            needs_comma := true;
        end;
        c.append(")");
    end;
end;

fun compile_range_expr(c : Compiler, start : Ast.Expr, end_expr : Ast.Expr, target : Target) : String do
    if val Ignore() := target then do 
        compile_expr(c, start, Ignore());
        compile_expr(c, end_expr, Ignore());
        ""
    end else do 
        val start_compiled := compile_expr(c, start, UsedDirectly());
        val end_compiled := compile_expr(c, end_expr, UsedDirectly());
        use_with_target(c, "__range("+start_compiled+", "+end_compiled+")", target)
    end
end

fun compile_for(
    c : Compiler, 
    loop_var : Ast.Setter, 
    iterated : Ast.Expr, 
    body : Ast.Expr, 
    env : Env.Env(Ast.VarInfo), 
    result_ty : Ast.Type, 
    iterated_elem_ty : Ast.Type,
    target : Target) : String 
do 
    val internal_loop_var := c.new_var();
    val list_var := if target != Ignore() and result_ty != Ast.VoidT() then do 
        val res_var := c.new_var();
        c.append("final "); c.append(compile_type(c, result_ty)); c.append(" "+res_var+";"); c.newline();
        res_var
    end else "";
    if target != Ignore() and result_ty != Ast.VoidT() do 
        assign(c, Ast.Variable(list_var), "new ArrayList<>()");
    end

    val loop_label := c.new_var();
    c.loop_labels.push(loop_label);

    if val RangeExpr(start_expr, end_expr) := iterated then do 
        val start_var := c.new_var();
        c.append("final double "+start_var+";"); compile_expr(c, start_expr, AssignTo(Ast.Variable(start_var)));
        val end_var := c.new_var();
        c.append("final double "+end_var+";"); compile_expr(c, end_expr, AssignTo(Ast.Variable(end_var)));
        c.append("if("+start_var+" < "+end_var+") "); c.newline();
        c.append(loop_label+": for(double "+internal_loop_var+" = "+start_var+"; "); 
        c.append(internal_loop_var+ " < "+end_var+"; "+internal_loop_var+"++) {");
        c.indent(); c.newline();
    end else do 
        val iterated_compiled := compile_expr(c, iterated, UsedDirectly());
        c.append(loop_label+": for(var "+internal_loop_var+" : "+iterated_compiled+") {"); c.indent(); c.newline();
    end;
        val prv := c.open_scope(env);
        val BlockExpr(stmts, end_expr, ?, ?) := body else panic("Internal error: non-block-expression as body of for");
        // Dont have to scan loop variables for captures as they aren't mutable
        val captures := Analyze.analyze_captures(stmts, end_expr); 
        for (name, is_captured) in captures.bindings do 
            if is_captured do 
                val info := VariableInfo();
                info.is_upvalue := true;
                c.env.insert(name, info); // Mark as upvalue
            end
        end;
        compile_variables(c, loop_var, iterated_elem_ty, false, false, false);
        assign(c, loop_var, internal_loop_var);
        val result := compile_expr(c, body, if val Ignore() := target then Ignore() else UsedDirectly());
        if target != Ignore() and result_ty != Ast.VoidT() do 
            c.append(list_var); c.append(".add("+result+");"); c.newline();
        end
        c.close_scope(prv);
        c.dedent(); c.newline();
    c.append("}");
    c.loop_labels.pop();
    c.newline();
    use_with_target(c, if result_ty = Ast.VoidT() then "null" else list_var, target)
end

fun compile_while(
    c : Compiler, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    env : Env.Env(Ast.VarInfo), 
    result_ty : Ast.Type, 
    target : Target) : String 
do 
    val list_var := if target != Ignore() and result_ty != Ast.VoidT() then do 
        val res_var := c.new_var();
        c.append("final "); c.append(compile_type(c, result_ty)); c.append(" "+res_var+";"); c.newline();
        res_var
    end else "";
    if target != Ignore() and result_ty != Ast.VoidT() do 
        assign(c, Ast.Variable(list_var), "new ArrayList<>()");
    end
    val loop_label := c.new_var();
    c.loop_labels.push(loop_label);
    c.append(loop_label+": while(true) {"); c.indent(); c.newline();
        val cond_compiled := compile_expr(c, cond, UsedDirectly());
        if val Boolean(b) := cond then do if !b do c.append("break;"); end; end else do c.append("if(!"+cond_compiled+") { break; }"); c.newline(); end;
        val prv := c.open_scope(env);
        val BlockExpr(stmts, end_expr, ?, ?) := body else panic("Internal error: non-block-expression as body of while");
        val captures := Analyze.analyze_captures(stmts, end_expr); // There are no loop variables
        for (name, is_captured) in captures.bindings do 
            if is_captured do 
                val info := VariableInfo();
                info.is_upvalue := true;
                c.env.insert(name, info); // Mark as upvalue
            end
        end;
        val result := compile_expr(c, body, if val Ignore() := target then Ignore() else UsedDirectly());
        if target != Ignore() and result_ty != Ast.VoidT() do 
            c.append(list_var); c.append(".add("+result+");"); c.newline();
        end
        c.close_scope(prv);
        c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.loop_labels.pop();
    use_with_target(c, if result_ty = Ast.VoidT() then "null" else list_var, target)
end

fun compile_index(c : Compiler, lst : Ast.Expr, idx : Ast.Expr, target : Target) : String do
    if val Ignore() := target then do
        compile_expr(c, lst, Ignore());
        compile_expr(c, idx, Ignore());
        ""
    end else do
        val indexed := compile_expr(c, lst, UsedDirectly());
        val index := compile_expr(c, idx, UsedDirectly());
        use_with_target(c, indexed+".get(__toIndex("+index+"))", target)
    end
end

fun compile_list_literal(c : Compiler, exprs : Ast.Expr[], lty : Ast.Type, target : Target) : String do 
    if val Ignore() := target then do 
        for expr in exprs do 
            compile_expr(c, expr, Ignore());
        end;
        ""
    end else do 
        val Variable(name) := if val AssignTo(s) := target then s else Ast.Variable(c.new_var()) 
                                else panic("invalid target for lists: "+target);
        if val AssignTo(?) := target then do end else do 
            val compiled_ty := compile_type(c, lty);
            c.append(compiled_ty); c.append(" ");
        end;
        c.append(name+" = new ArrayList<>("+exprs.length+");"); c.newline();
        for expr in exprs do 
            val field := compile_expr(c, expr, UsedDirectly());
            c.append(""+name+".add("+field+");"); c.newline();
        end
        if val AssignTo(?) := target then "" else use_with_target(c, name, target)
    end
end

fun compile_property(
    c : Compiler, 
    obj : Ast.Expr,
    name : String, 
    at : Ast.AccessType, 
    obj_ty : Ast.Type, 
    field_ty : Ast.Type, 
    target : Target) : String 
do 
    if target = Ignore() then do 
        compile_expr(c, obj, target)
    end else do // Target cannot be Ignore
        match at do 
            case FieldAccess() := do
                val subexpr := compile_expr(c, obj, UsedDirectly());
                val fieldAccess := if val ListOf(?) := obj_ty 
                    then builtin_list_property(name, subexpr) 
                    else subexpr + "." + name;
                use_with_target(c, fieldAccess, target)
            end;
            case MethodAccess() := do 
                val temp_var := c.new_var();
                c.append("final "); c.append(compile_type(c, obj_ty)); c.append(" "); c.append(temp_var); c.append(";"); c.newline();
                compile_expr(c, obj, AssignTo(Ast.Variable(temp_var)));
                val methodAccess := if val ListOf(?) := obj_ty 
                    then builtin_list_method(c, temp_var, name) 
                    else temp_var + "::"+name; // Create method reference. Let java create lambda
                match target do 
                    case AssignTo(s) := assign(c, s, methodAccess);
                    case Return() := return_stmt(c, methodAccess);
                    case UsedDirectly() := do 
                        val resulting_var := c.new_var();
                        c.append("final "); c.append(compile_type(c, field_ty)); c.append(" "); c.append(resulting_var); 
                        c.append(" = "); c.append(methodAccess); c.append(";"); c.newline();
                        resulting_var
                    end;
                end
            end;
            case ModuleAccessed() := do 
                val Module(path) := Ast.get_as_path(obj) else panic("Unknown module access: "+obj);
                val mod_path := SourceFileGatherer.path_to_module(path);
                val mod_info := c.all_modules.get(mod_path);
                val accessed_info := mod_info.get(name);
                val access_compiled := if accessed_info.is_constructor 
                    then join(".", path)+"."+name+"::new"
                    else if accessed_info.is_no_fc_fn
                        then join(".", path)+"::"+name 
                        else join(".", path)+"."+name;
                use_with_target(c, access_compiled, target)
            end;
        end
    end
end

fun builtin_list_property(name : String, subexpr : String) : String := match name do 
    case "length" := "(double) ("+subexpr+".size())";
    case "first" := subexpr+".get(0)";
    case "last" := subexpr+".get("+subexpr+".size() - 1)";
end;

fun builtin_list_method(c : Compiler, tempvar : String, method : String) : String := match method do 
    case "push" := do 
        val arg := c.new_var();
        "(var "+arg+") -> {"+tempvar+".add("+arg+"); return null;}"
    end;
    case "pop" := "() -> "+tempvar+".remove("+tempvar+".size() - 1)";
    case "peek" := "() -> "+tempvar+".get("+tempvar+".size() - 1)";
    case "dequeue" := "() -> "+tempvar+".remove(0)";
    case "prepend" := do 
        val arg := c.new_var();
        "(var "+arg+") -> "+tempvar+".add(0, "+arg+")"
    end;
    case "append" := do 
        val arg := c.new_var();
        "(var "+arg+") -> "+tempvar+".addAll("+arg+")"
    end;
end;

fun builtin_list_method_call(c : Compiler, obj : String, acc : String, args : Ast.Expr[], target : Target) : String do 
    val args_compiled : String[] := for arg in args yield 
        compile_expr(c, arg, UsedDirectly())
    end;

    val res_expr := match acc do 
        case "push" := obj+".add("+(args_compiled[0]+")");
        case "pop" := obj+".remove("+obj+".size() - 1)";
        case "peek" := obj+".get("+obj+".size() - 1)";
        case "dequeue" := obj+".remove(0)";
        case "prepend" := obj+".add(0, "+(args_compiled[0]+")");
        case "append" := obj+".addAll("+(args_compiled[0]+")");
    end;

    match target do 
        case Ignore() := do 
            c.append(res_expr); c.append(";");
            c.newline();
            ""
        end;
        case Return() := return_stmt(c, res_expr);
        case UsedDirectly := do 
            val temp_var := c.new_var();
            c.append("var "+temp_var+" = "+res_expr+";"); c.newline();
            temp_var
        end;
        case AssignTo(s) := assign(c, s, res_expr);
    end
end

fun compile_tuple(c : Compiler, subexprs : Ast.Expr[], ty : Ast.Type, target : Target) : String do 
    val subexpr_target := match target do 
        case Ignore() := Ignore();
        case ? := UsedDirectly();
    end;
    val exprs := for expr in subexprs yield compile_expr(c, expr, subexpr_target) end;
    if target = Ignore() do 
        return "";
    end
    // Name of the corresponding tuple type (will be created and will have a constructor)
    val tuple_type := compile_type(c, ty); 
    var name := "";
    val setter := if val AssignTo(s) := target then s else do 
        name := c.new_var();
        c.append("final "+tuple_type+" "+name+";");
        c.newline();
        Ast.Variable(name)
    end;
    var buf := "new "+tuple_type+"(";
    var needs_comma := false;
    for expr in exprs do 
        if needs_comma do 
            buf := buf + ", ";
        end 
        buf := buf + expr;
        needs_comma := true;
    end;
    buf := buf + ")";
    assign(c, setter, buf);
    if val Return() := target then do 
        c.append("return "); c.append(name); c.append(";"); c.newline();
        ""
    end else name
end

fun compile_binary(
    c : Compiler, 
    op : Ast.BinOp, 
    left : Ast.Expr,
    right : Ast.Expr,
    target : Target
) : String 
do 
    if is_lazy_op(op) do 
        return compile_lazy_binary(c, op, left, right, target);
    end
    if Ignore() = target do // Don't need to compile the operation 
        compile_expr(c, left, Ignore());
        compile_expr(c, right, Ignore());
        return "";
    end;
    val operation := do 
        val lhs := compile_expr(c, left, UsedDirectly());
        val rhs := compile_expr(c, right, UsedDirectly());
        val op := compile_bin_op(op);
        "" + lhs + " " + op + " " + rhs
    end;
    match target do 
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
        case UsedDirectly() := "(" + operation + ")";
    end
end

fun is_lazy_op(op : Ast.BinOp) : Bool := match op do case And() := true; case Or() := true; case ? := false; end;

fun compile_lazy_binary(c : Compiler, op : Ast.BinOp, left : Ast.Expr, right : Ast.Expr, target : Target) : String do 
    val prefix := if val And() := op then "" else "!";
    val default_result := if val And() := op then "false" else "true";
    val lft := compile_expr(c, left, UsedDirectly());
    match target do
        case Ignore() := do 
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, Ignore());
            c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
        case Return() := do
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, Return()); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            c.append("return "+default_result+";"); c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
        case UsedDirectly() := do 
            val res_var := c.new_var();
            c.append("final boolean "+res_var+";"); c.newline();
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, AssignTo(Ast.Variable(res_var))); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            c.append(res_var + " =  "+default_result+";"); c.dedent(); c.newline();
            c.append("}"); c.newline();
            res_var
        end;
        case AssignTo(to) := do 
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, target); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            assign(c, to, default_result); c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
    end
end

fun compile_unary(c : Compiler, op : Ast.UnOp, operand : Ast.Expr, target : Target) : String do 
    if target = Ignore() do 
        compile_expr(c, operand, Ignore());
        return "";
    end;
    val operation := do 
        val operand_comp := compile_expr(c, operand, UsedDirectly());
        val op_c := compile_un_op(op);
        op_c + operand_comp
    end;
    match target do 
        case UsedDirectly() := "(" + operation + ")";
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
    end
end

fun compile_function_expr(
    c : Compiler,
    params : Ast.Parameter[],
    return_type : Ast.Type,
    body : Ast.Expr,
    env : Env.Env(Ast.VarInfo),
    target : Target) : String
do 
    if Ignore() = target do return ""; end;
    val complete_ty := Ast.Function(param_types(params), return_type);
    var name := "";
    val temp_var := match target do 
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case Return() := Ast.Variable("");
        case AssignTo(setter) := setter;
    end;
    match target do 
        case UsedDirectly() := do 
            c.append("final "); c.append(compile_type(c, complete_ty)); c.append(" "); c.append(name); c.append(" = (");
        end;
        case AssignTo(Variable(n)) := do 
            c.append(n); c.append(" = (");
        end;
        case Return() := do 
            c.append("return (");
        end;
    end;
    val prv := c.open_scope(env);
    var needs_comma := false;
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(name, ty) := do 
                c.env.insert(name, VariableInfo());
                c.append(compile_type(c, ty)); c.append(" "); c.append(name);
            end;
        end;
        needs_comma := true;
    end; 

    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;

    c.append(") -> ");
    if !body_is_block do 
        c.append("{");
        c.indent(); c.newline();
    end
    
    compile_expr(c, body, Return());
    c.strip_trailing();
    if !body_is_block then do
        c.dedent(); c.newline();
        c.append("};"); c.newline();
    end else do 
        c.append(";"); c.newline();
    end;

    c.close_scope(prv);
    name
end

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := for param in params yield 
    match param do 
        case NormalParam(name, ty) := ty;
    end
end;

fun maybe_upvalue(c : Compiler, name : String) : String := 
    if c.env.has(name) and c.env.get(name).is_upvalue then 
        name + ".value"
    else 
        name;

fun compile_identifier(c : Compiler, fname : String, expected_ty : Ast.Type, target : Target) : String do
    if Ignore() = target do // Identifier has no side effects, so ignore means nothing has to be compiled
        return "";
    end;
    if val Function(args, ret_type) := c.current_env.get(fname).ty then do
        if !c.env.get(fname).is_no_fc_fn do // Value is a first class function already
            // Value might be an upvalue
            return use_with_target(c, maybe_upvalue(c, fname), target); // No lambda has to be created
        end;
        // Value is a first class function and therefore cannot be an upvalue
        val ty := compile_type(c, c.current_env.get(fname).ty);
        var name := "";
        val temp_var := match target do 
            case Return() := Ast.Variable("");
            case UsedDirectly() := do 
                name := c.new_var();
                Ast.Variable(name)
            end;
            case AssignTo(setter) := setter;
        end;
        match target do 
            case Return() := do 
                c.append("return ");
            end;
            case UsedDirectly() := do 
                c.append(ty); c.append(" "); c.append(name); c.append(" = ");
            end;
            case AssignTo(Variable(x)) := do 
                c.append(x); c.append(" = ");
            end;
        end;
        c.append("(");
        val params : String[] := [];
        var needs_comma := false;
        for param in args do 
            if needs_comma do 
                c.append(", ");
            end;
            val arg_name := c.new_var();
            c.append(compile_type(c, param)); c.append(" "); c.append(arg_name);
            params.push(arg_name);
            needs_comma := true;
        end;
        c.append(") -> "); if c.env.get(fname).is_constructor do c.append("new "); end; c.append(fname); c.append("(");
        needs_comma := false;
        for param in params do 
            if needs_comma do 
                c.append(", ");
            end
            c.append(param);
        end;
        c.append(");");
        c.newline();
        name
    end else if val Never() := c.current_env.get(fname).ty then do 
        use_with_target(c, default_value(expected_ty), target)
    end else do 
        // Normal variable, might be an upvalue
        use_with_target(c, maybe_upvalue(c, fname), target)
    end
end

fun create_enqueued_type(c : Compiler, ty : Ast.Type) : String do 
    if val Some(name) := c.get_enqueued_type(ty) then do 
        name 
    end else do 
        val type_name := c.new_var();
        c.enqueue_type(ty, type_name);
        type_name
    end
end

fun compile_call(c : Compiler, callee : Ast.Expr, args : Ast.Expr[], target : Target) : String do 
    val callee_compiled := if val Identifier(name, ?) := callee then do 
        val info := c.env.get(name);
        if info.is_constructor then 
            "new " + name
        else if info.is_no_fc_fn then 
            name 
        else
            compile_expr(c, callee, UsedDirectly()) + ".call"
    end else if val PropertyExpr(obj, name, la, lt, lft) := callee then do 
        if val ModuleAccessed := la.get() then do 
            val Module(path) := Ast.get_as_path(obj) else panic("Unknown module access: "+obj);
            val mod_info := c.all_modules.get(SourceFileGatherer.path_to_module(path));
            val accessed_info := mod_info.get(name);
            val accessed_path := join(".", path);
            if accessed_info.is_constructor 
                then "new "+accessed_path+"."+name
            else if accessed_info.is_no_fc_fn 
                then accessed_path + "." + name 
            else accessed_path + "." + name + ".call" 
        end else do 
            val obj_expr := compile_expr(c, obj, UsedDirectly());
            val obj_ty := lt.get();
            if val ListOf(?) := obj_ty then 
                return builtin_list_method_call(c, obj_expr, name, args, target) // builtin list methods have to be compiled specially
            else 
            if val MethodAccess() := la.get() then 
                 obj_expr + "." + name
            else obj_expr + "." + name  + ".call"
        end
    end else do 
        compile_expr(c, callee, UsedDirectly()) + ".call"
    end;
    val args_compiled := for arg in args yield 
        compile_expr(c, arg, UsedDirectly())
    end;
    var str := callee_compiled + "(";
    var needs_comma := false;
    for arg in args_compiled do 
        if needs_comma do 
            str := str + ", ";
        end;
        str := str + arg;
        needs_comma := true;
    end;
    str := str + ")";
    match target do 
        case Ignore() := do c.append("__ignore("); c.append(str); c.append(");"); c.newline(); "" end;
        case Return() := do 
            return_stmt(c, str)
        end;
        case UsedDirectly() := do
            val tmp := c.new_var();
            c.append("var "+tmp+" = " + str + ";"); c.newline();
            tmp
        end;
        case AssignTo(setter) := do 
            assign(c, setter, str)
        end;
    end
end

fun compile_block(
    c : Compiler, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    t : Ast.Type,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)),
    target : Target) : String 
do 
    var name := "";
    var var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter; 
    end;
    if target = UsedDirectly() do 
        c.append("final "); 
        c.append(compile_type(c, t)); 
        c.append(" "); 
        c.append(name);
        c.append(";"); 
        c.newline(); 
    end;
    c.append("{"); c.indent(); c.newline();
    val prv := c.open_scope(lenv.get());
    val captures := Analyze.analyze_captures(stmts, end_expr);
    for (name, is_captured) in captures.bindings do 
        if is_captured do 
            val info := VariableInfo();
            info.is_upvalue := true;
            c.env.insert(name, info); // Mark as upvalue
        end
    end;
    for stmt in stmts do 
        compile_stmt(c, stmt);
    end;
    if val Some(e) := end_expr then do 
        val resulting_target := match target do 
            case Ignore() := Ignore();
            case Return() := Return();
            case UsedDirectly() := AssignTo(var_name);
            case AssignTo(?) := AssignTo(var_name);
        end;
        val ? := compile_expr(c, e, resulting_target);
    end else do 
        match target do 
            case Ignore() := Ignore();
            case Return() := c.append("return null;");
            case UsedDirectly() := do 
                name := "null"; // Just user null as inline expression 
            end; 
            case AssignTo(setter) := do 
                assign(c, setter, "null");
            end;
        end;
    end;
    c.strip_trailing();
    c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    name
end

fun compile_bin_op(op : Ast.BinOp) : String := match op do 
    case Add() := "+";
    case Sub() := "-";
    case Mul() := "*";
    case Div() := "/";
    case Mod() := "%";
    case LessThan() := "<";
    case LessEqual() := "<=";
    case Equals() := "==";
    case NotEquals() := "!=";
    case GreaterThan() := ">";
    case GreaterEqual() := ">=";
    case And() := "&&";
    case Or() := "||";
    case Xor() := "^";
end;

fun compile_un_op(op : Ast.UnOp) : String := match op do 
    case Plus()  := "+";
    case Minus() := "-";
    case Not()   := "!";
end;

fun compile_if(
    c : Compiler, 
    lt : Util.LateInitialized(Ast.Type),
    cond : Ast.Expr, 
    thenBr : Ast.Expr, 
    elseBr : Ast.Expr,
    target : Target) : String do 
    var name := "";
    val var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter;
    end;
    if target = UsedDirectly() do
        c.append("final "); c.append(compile_type(c, lt.get())); c.append(" "); c.append(name); c.append(";"); c.newline();
    end;
    val prev_buf := c.buf; // Safe buffer before if to backtrack in case the if is not necessare
    c.buf := "";
    val branch_target := match target do 
        case Ignore() := Ignore();
        case Return() := Return();
        case ? := AssignTo(var_name);
    end;
    val cond_expr := compile_expr(c, cond, UsedDirectly());
    val cond_buf := c.buf;
    c.buf := "";
    c.append("if("); c.append(cond_expr); c.append(") {"); c.indent(); c.newline();
    val if_buf := c.buf;
    c.buf := "";
    val thenBrExpr := compile_expr(c, thenBr, branch_target);
    val thenIsIgnored := thenBrExpr = "" and c.buf = "";
    c.strip_trailing();c.dedent();c.newline(); c.append("} else {"); c.indent();c.newline();
    val else_buf := c.buf;
    c.buf := "";
    val elseBrExpr := compile_expr(c, elseBr, branch_target);
    val elseIsIgnored := elseBrExpr = "" and c.buf = "";
    c.strip_trailing();c.dedent(); c.newline(); c.append("}"); c.newline();
    val end_buf := c.buf;
    c.buf := prev_buf; // Restore previous buffer
    if thenIsIgnored and elseIsIgnored and Ignore() = target then do // Both branches can be ignored
        c.append(compile_expr(c, cond, Ignore())); // Recompile condition as ignored
        c.newline();
    end else do 
        c.append(cond_buf + if_buf + else_buf + end_buf); // Create whole branch in buffer
    end;
    name
end

fun compile_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := if c.expect_ref_ty then "Double" else "double";
    case BooleanT() := if c.expect_ref_ty then "Boolean" else "boolean";
    case StringT() := "String";
    case VoidT() := "Void";
    case ListOf(et) := do 
        val pref_expect_ref_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        val result := "ArrayList<"+compile_type(c, et)+">";
        c.expect_ref_ty := pref_expect_ref_ty;
        result
    end;
    case Function(?, ?) := create_enqueued_type(c, t);
    case Tuple(?) := create_enqueued_type(c, t);
    case Name(name, ?) := name; // Classes are compiled with their name
    case ModuleAccess(path, accessed, ?) := join(".", path)+"."+accessed;
    case Never() := "Void";
end;

fun compile_upvalue_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := "NumberUpvalue";
    case BooleanT() := "BooleanUpvalue";
    case ? := "Upvalue<"+compile_type(c, t)+">";
end;

fun compile_enqueued_types(c : Compiler) do 
    while c.types_to_compile != [] do 
        val task := c.types_to_compile.pop();
        compile_task(c, task);
    end
end

fun compile_task(c : Compiler, task : CompilationTask) do 
    match task do 
        case CreateFunctionalInterface(args, ret_ty, name) := do
            c.append("@FunctionalInterface static interface "); c.append(name); c.append(" {");
            c.indent(); c.newline();
            c.append(compile_type(c, ret_ty));
            c.append(" call(");
            var needs_comma := false;
            for arg in args do 
                if needs_comma do 
                    c.append(", ");
                end
                c.append(compile_type(c, arg)); c.append(" ");c.append(c.new_var());
                needs_comma := true;
            end
            c.append(");");
            c.dedent(); c.newline();
            c.append("}");
            c.newline();
            c.compiled_types.push((name, Ast.Function(args, ret_ty)));
        end;
        case CreateTupleType(parts, name) := do 
            c.append("static record "); c.append(name); c.append("(");
            var counter := 0;
            var needs_comma := false;
            for ty in parts do 
                if needs_comma do 
                    c.append(", ");
                end
                c.append(compile_type(c, ty)); c.append(" "); c.append("field"+counter);
                counter := counter + 1;
                needs_comma := true;
            end;
            c.append(") {");
            c.indent(); c.newline();
            c.append("public String toString() {");
            c.indent(); c.newline();
            c.append("StringBuilder builder = new StringBuilder();");
            c.newline();
            c.append("builder.append(\"(\");");
            c.newline();
            needs_comma := false;
            for i in [0..counter] do 
                if needs_comma do 
                    c.append("builder.append(\", \");");
                    c.newline();
                end;
                c.append("builder.append("); c.append("field"+i); c.append(");");
                c.newline();
                needs_comma := true;
            end; 
            c.append("builder.append(\")\");");
            c.newline();
            c.append("return builder.toString();");
            c.dedent(); c.newline();
            c.append("}");
            c.dedent(); c.newline();
            c.append("}");
            c.newline();
        end;
    end;
end

fun assign(c : Compiler, to : Ast.Setter, from : String) : String do
    match to do 
        case Variable(name) := do 
            c.append(maybe_upvalue(c, name));
            c.append(" = ");
            c.append(from);
            c.append(";");
            c.newline();
        end;
        case TupleSetter(parts, t) := do 
            val temp_var := c.new_var();
            c.append("final "); c.append(compile_type(c, t.get())); c.append(" "); c.append(temp_var);
            c.append(" = "); c.append(from); c.append(";"); c.newline();
            for i in [0..parts.length] do 
                assign(c, parts[i], temp_var+".field"+i+"()");
            end;
        end;
        case Property(obj, name, ct) := do 
            val object := compile_expr(c, obj, UsedDirectly());
            c.append(object); c.append("."); c.append(name); c.append(" = "); c.append(from); c.append(";"); c.newline();
        end;
    end;
    ""
end

fun return_stmt(c : Compiler, expr : String) : String do 
    c.append("return "); c.append(expr); c.append(";"); c.newline();
    ""
end 
