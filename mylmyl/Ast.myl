module Ast;

import Env;
import Util;

enum Expr where 
    DesugarableExpr(Mut(Expr)),
    NumberLiteral(Number),
    StringLiteral(String),
    Boolean(Bool),
    NullLiteral(),
    Identifier(String, Util.LateInitialized(Type)),
    BinaryOperation(BinOp, Expr, Expr),
    UnaryOperation(UnOp, Expr),
    FunctionCall(Expr, Expr[]),
    FunctionExpr(Parameter[], Type, Expr, Util.LateInitialized(Env.Env(VarInfo))),
    IfExpr(Util.LateInitialized(Type), Expr, Expr, Expr),
    IfValExpr(Util.LateInitialized(Type), Pattern, Expr, Expr, Expr, 
              Util.LateInitialized(Env.Env(VarInfo)), Util.LateInitialized(Type)),
    MatchExpr(Expr, (Pattern, Expr, Util.LateInitialized(Env.Env(VarInfo)))[], 
              Util.LateInitialized(Type), Util.LateInitialized(Type)),
    ListExpr(Expr[], Util.LateInitialized(Type)),
    RangeExpr(Expr, Expr),
    IndexExpr(Expr, Expr),
    PropertyExpr(Expr, String, Util.LateInitialized(AccessType), Util.LateInitialized(Type), 
                               Util.LateInitialized(Type)),
    TupleExpr(Expr[], Util.LateInitialized(Type)),
    BlockExpr(Stmt[], Util.Optional(Expr), Util.LateInitialized(Type), Util.LateInitialized(Env.Env(VarInfo))),
    WhileExpr(Expr, Expr, Util.LateInitialized(Env.Env(VarInfo)), Util.LateInitialized(Type)),
    WhileValExpr(Pattern, Expr, Expr, Util.LateInitialized(Type), Util.LateInitialized(Env.Env(VarInfo)), Util.LateInitialized(Type)),
    ForExpr(Setter, Expr, Expr, Util.LateInitialized(Env.Env(VarInfo)), Util.LateInitialized(Type), 
                                Util.LateInitialized(Type)),
    WildCardExpression(),
    ReturnExpr(Expr, Util.LateInitialized(Type)),
    Break(Util.LateInitialized(Type)),
    ThisExpr();
end

class Mut(E) where 
    var expr : E;
    new(e : E) do this.expr := e; end

    fun get() : E := this.expr;
    fun set(e : E) do this.expr := e; end;
end

enum Pattern where 
    NumericPattern(Number),
    StringPattern(String),
    BooleanPattern(Bool),
    NamePattern(String),
    WildcardPattern(),
    TuplePattern(Pattern[]),
    ConstructorPattern(String, Pattern[], Util.LateInitialized(EnumConstructor));
end

enum AccessType where 
    FieldAccess(), MethodAccess(), ModuleAccessed();
end

enum BinOp where 
    Add(), Sub(), Mul(), Div(), Mod(), LessThan(), LessEqual(), GreaterEqual(), GreaterThan(), Equals(), NotEquals(), 
    And(), Or(), Xor();
end
enum UnOp where 
    Plus(), Minus(), Not();
end

export enum Stmt where 
    ExprStmt(Expr),
    PrintStmt(Expr),
    SetStatement(Setter, Expr),
    Declaration(Decl),
    EmptyStmt();
end;

export enum Setter where 
    TupleSetter(Setter[], Util.LateInitialized(Type)),
    Variable(String),
    Property(Expr, String, Util.LateInitialized(Type)/* Should always be the Name of the Class */);
end;

export enum BlockPart where 
    Statement(Stmt),
    Expression(Expr);
end

export enum Decl where 
    DesugarableDecl(Mut(Decl)),
    VarDecl(Setter, Util.LateInitialized(Type), Util.Optional(Expr), Bool /* mut */, Bool /* export */),
    ValElseDeclaration(Pattern, Expr, Expr, Bool /* mut */, Bool /* export */, Util.LateInitialized(Type), 
                       Util.LateInitialized(Type), Util.LateInitialized(Env.Env(VarInfo))),
    FunDecl(String, Parameter[], Type, Expr, Bool /* export */, Util.LateInitialized(Env.Env(VarInfo))),
    ClassDecl(String, Decl[], Util.Optional(Constructor), Bool /* export */, Util.LateInitialized(Env.Env(VarInfo))),
    EnumDecl(String, EnumConstructor[], Decl[], Bool /* export */, Util.LateInitialized(Env.Env(VarInfo)));
end;

enum Import where 
    BasicImport(String[]);
end

export class EnumConstructor where 
    val name : String;
    val fields : Type[];
    new(n : String, fs : Type[]) do 
        this.name := n;
        this.fields := fs;
    end
end

export class Constructor where 
    val params : Parameter[];
    val body : Expr;
    val lenv : Util.LateInitialized(Env.Env(VarInfo)) := late_env();

    new(p : Parameter[], b : Expr) do 
        this.params := p;
        this.body := b;
    end;
end;

class VarInfo where 
    val ty : Type;
    val is_mutable : Bool;
    val name : String;
    var is_exported : Bool := false;
    var is_constructor : Bool := false;
    new(m : Bool, t : Type, n : String) do 
        this.is_mutable := m; this.ty := t; this.name := n;
    end
end

enum TyInfo where 
    ClassInfo(String, Env.AList(VarInfo) /* fields */, Env.AList(VarInfo) /* methods */, Bool /* exported */),
    EnumInfo(String, EnumConstructor[], Env.AList(VarInfo) /* methods, doesn't have fields */, Bool /* exported */);
end

enum Parameter where 
    NormalParam(String, Type);
end

export class Program where 
    val imports : Import[] := [];
    val decls : Decl[] := [];
end

enum Type where 
    NumberT(), BooleanT(), StringT(), VoidT(),
    Tuple(Type[]), 
    Name(String, Util.LateInitialized(Env.Env(TyInfo))), // Enviroment the name is defined in
    Function(Type[], Type), ListOf(Type),
    ModuleAccess(String[], String, Util.LateInitialized(Type)), // Fully resolved type at end
    Never();
end

/*

var name_counter : Number := 0;

class Symbol where
    val text : String;
    val id : Number;
    new(text : String) do
        this.text := src;
        this.id := name_counter;
        name_counter := name_counter + 1;
    end
end

*/

export fun late_env() : Util.LateInitialized(Env.Env(VarInfo)) := Util.LateInitialized.[Env.Env(VarInfo)]();
export fun late_type() : Util.LateInitialized(Type) := Util.LateInitialized.[Type]();
export fun late_ty_env() : Util.LateInitialized(Env.Env(TyInfo)) := Util.LateInitialized.[Env.Env(TyInfo)]();

fun get_as_path(e : Expr) : AccessedObjectType := match e do 
    case DesugarableExpr(mute) := get_as_path(mute.get());
    case Identifier(name, ?) := Module([name]);
    case PropertyExpr(path, name, ?, ?, ?) := if val Module(path_until_now) := get_as_path(path) then do 
        path_until_now.push(name);
        Module(path_until_now)
    end else NormalObject();
    case ? := NormalObject();
end;

enum AccessedObjectType where 
    Module(String[]), NormalObject();
end