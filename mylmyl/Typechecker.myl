module Typechecker;

import Ast;
import Env;
import Util;

fun typecheck(ast : Ast.Program) : Env.Env(Ast.VarInfo) do 
    val tc := new Typechecker();
    for decl in ast.decls do 
        check_decl(tc, decl);
    end;
    tc.env
end

class Typechecker where 
    var env : Env.Env(Ast.VarInfo) := Env.Env.[Ast.VarInfo]();
    var ty_env : Env.Env(Ast.TyInfo) := Env.Env.[Ast.TyInfo]();
    var is_in_class : Bool := false;
    fun error[A](message : String) : A := panic(message);
    fun require_assigneable(to : Ast.Type, from : Ast.Type, violating : Ast.Expr) do 
        require_types_exist(this, to);
        require_types_exist(this, from);
        if to != from do 
            this.error.[Void](from+" is not assigneable to "+to+" in expression "+violating);
        end;
    end

    fun open_scope() do 
        this.env := this.env.open_scope();
        this.ty_env := this.ty_env.open_scope();
    end
    fun close_scope() do 
        this.env := this.env.close_scope();
        this.ty_env := this.ty_env.close_scope();
    end

    fun type_of_var(name : String) : Ast.Type := this.env.get(name).ty;
    fun is_var_mutable(name : String) : Bool := this.env.get(name).is_mutable;

    fun type_info_for(name : String) : Ast.TyInfo := this.ty_env.get(name);

    fun var_declared(name : String) : Bool := this.env.has(name);
    fun type_declared(name : String) : Bool := this.ty_env.has(name);

    fun declare(name : String, ty : Ast.Type, m : Bool) := this.env.insert(name, Ast.VarInfo(m, ty, name));
    fun declare_type(name : String, ty_info : Ast.TyInfo) := this.ty_env.insert(name, ty_info);

    fun is_global() : Bool := this.env.outer = Util.None.[Env.Env(Ast.VarInfo)]();
end

fun require_types_exist(tc : Typechecker, ty : Ast.Type) := match ty do 
    case Tuple(parts) := do 
        for part in parts do 
            require_types_exist(tc, part);
        end
    end;
    case Function(params, ret_type) := do 
        for param in params do 
            require_types_exist(tc, param);
        end
        require_types_exist(tc, ret_type);
    end;
    case Name(str) := do 
        if !tc.type_declared(str) do 
            panic("Unknown type "+str);
        end
    end;
    case ? := do end;
end;

fun check_stmt(tc : Typechecker, stmt : Ast.Stmt) := match stmt do 
    case PrintStmt(arg) := do 
        infer(tc, arg);
    end;
    case ExprStmt(arg) := do 
        infer(tc, arg);
    end;
    case Declaration(decl) := check_decl(tc, decl);
    case SetStatement(setter, value) := check_set_stmt(tc, setter, value);
end;

fun check_set_stmt(tc : Typechecker, setter : Ast.Setter, value : Ast.Expr) do 
    val expected_type := infer_setter(tc, setter);
    check(tc, value, expected_type);
    check_mutability(tc, setter);
end

fun check_mutability(tc : Typechecker, setter : Ast.Setter) := match setter do 
    case Variable(name) := do 
        if !tc.is_var_mutable(name) do 
            panic("Error: '"+name+"' is not mutable");
        end;
    end;
    case TupleSetter(parts, ?) := do 
        for part in parts do 
            check_mutability(tc, part);
        end;
    end;
    case Property(obj, name, lt) := do 
        val Name(class_name) := lt.get() else panic("Should be unreachable: Property with non-class-type");
        val ClassInfo(?, fields, methods) := tc.type_info_for(class_name) else panic("Should be unreachable: Non-class info in setter");
        val field_info := fields.get(name);
        if not field_info.is_mutable do 
            panic("Cannot change immutable field "+name+" of class "+class_name);
        end
    end;
end;

fun infer_setter(tc : Typechecker, s : Ast.Setter) : Ast.Type := match s do 
    case Variable(name) := tc.type_of_var(name);
    case TupleSetter(subsetters, lt) := do 
        val parts : Ast.Type[] := [];
        for setter in subsetters do 
            parts.push(infer_setter(tc, setter));
        end;
        val ty := Ast.Tuple(parts);
        lt.init(ty);
        ty
    end;
    case Property(obj, name, lcty) := do
        val obj_ty := infer(tc, obj);
        val Name(class_name) := obj_ty else panic("Cannot set property of non-class-type "+obj_ty);
        lcty.init(obj_ty);
        val class_info := tc.type_info_for(class_name);
        val ClassInfo(?, fields, methods) := class_info else panic("Unimplemented type information in property setter");
        if methods.has(name) do 
            panic("Cannot change a method: method "+name+" of class "+class_name);
        end
        if fields.has(name) then do 
            fields.get(name).ty
        end else panic("Class "+class_name+" has no field called "+name)
    end;
end;

fun check_declaration_setter(tc : Typechecker, setter : Ast.Setter, ty : Ast.Type, mut : Bool) do 
    match setter do 
        case Variable(name) := do 
            if tc.env.has(name) do 
                panic("Variable '"+name+"' is already declared");
            end
            tc.declare(name, ty, mut);
        end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of "+setter);
            end;
            for i in [0..setters.length] do 
                check_declaration_setter(tc, setters[i], parts[i], mut);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot use property as variable declaration: " + setter);
    end;
end

fun check_decl(tc : Typechecker, decl : Ast.Decl) := match decl do 
    case VarDecl(setter, lt, init, mutable, ?) := do 
        if lt.is_init() then do 
            if val Some(e) := init then do 
                check(tc, e, lt.get());
            end else do
                if not mutable do 
                    panic("Immutable variable requires initializer: "+setter);
                end
                if not tc.is_in_class do 
                    panic("Variables outside of classes require a initializer: "+setter);
                end
            end;
        end else do
            if val Some(e) := init then do  
                lt.init(infer(tc, e));
            end else do 
                panic("Require either an initializer or a type annotation for variable "+setter+"\n"
                    + (if not mutable then "Immutable variable requires initializer: "+setter else "")
                    + (if not tc.is_in_class then "Variables outside of classes require a initializer: "+setter else ""));
            end;
        end;
        check_declaration_setter(tc, setter, lt.get(), mutable);
    end;
    case FunDecl(name, params, return_type, body, ?, lenv) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        val fun_type := Ast.Function(param_types(params), return_type);
        if tc.var_declared(name) then do 
            panic("Function already declared: '"+name+"'");
        end else do 
            tc.declare(name, fun_type, false);
        end;
        tc.open_scope();
            for param in params do 
                declare_param(tc, param);
            end;
            check(tc, body, return_type);
            lenv.init(tc.env);
        tc.close_scope();
        if tc.is_global() and name = "main" and return_type != Ast.VoidT() do 
            panic("Main may not return anything other than Void");
        end
        if tc.is_global() and name = "main" and params != [] do 
            panic("Main may not define any parameters");
        end;
    end;
    case ClassDecl(name, members, constructor, exported, lenv) := do 
        tc.declare_type(name, Ast.ClassInfo(
            name, 
            fields_in_class(tc, members),
            methods_in_class(tc, members)
        ));
        tc.open_scope();
            tc.declare("this", Ast.Name(name), false);
            check_body(tc, members);
            val constr_type := check_constructor(tc, constructor, name);
            val body_env := tc.env;
        tc.close_scope();
        lenv.init(body_env);
        
        tc.declare(name, constr_type, false);
    end;
end;

fun fields_in_class(tc : Typechecker, members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case VarDecl(setter, ty, ?, m, ?) := do 
                gather_types(setter, ty.get(), m, types);
            end;
            case ? := do end;
        end;
    end;
    types
end
fun gather_types(setter : Ast.Setter, ty : Ast.Type, mutable : Bool, list : Env.AList(Ast.VarInfo)) do 
    match setter do 
        case Variable(name) := list.insert(name, Ast.VarInfo(mutable, ty, name));
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of field "+setter);
            end;
            for i in [0..setters.length] do 
                gather_types(setters[i], parts[i], mutable, list);
            end;
        end;
        case Property(?, ?, ?) := do end;
    end
end

fun methods_in_class(tc : Typechecker, members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case FunDecl(name, params, ret_ty, body, ?, lenv) := do 
                val fun_ty := Ast.Function(param_types(params), ret_ty);
                types.insert(name, Ast.VarInfo(false, fun_ty, name));
            end;
            case ClassDecl(name, ?, ?, ?, ?) := panic("Error: Do not allow class as member of another class: "+name);
            case ? := do end;
        end;
    end
    types
end

fun check_body(tc : Typechecker, body : Ast.Decl[]) do 
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    for member in body do 
        check_decl(tc, member);
    end;
    tc.is_in_class := prev_in_class;

end

fun check_constructor(tc : Typechecker, constructor : Util.Optional(Ast.Constructor), className : String) : Ast.Type do
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    val result := if val Some(constr) := constructor then do 
        tc.open_scope();
            for param in constr.params do 
                declare_param(tc, param);
            end;
            check(tc, constr.body, Ast.VoidT());
            constr.lenv.init(tc.env);
        tc.close_scope();
        Ast.Function(param_types(constr.params), Ast.Name(className))
    end else do 
        Ast.Function([], Ast.Name(className))
    end;
    tc.is_in_class := prev_in_class;
    result
end

fun declare_param(tc : Typechecker, param : Ast.Parameter) := match param do 
    case NormalParam(name, ty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) then do 
            panic("Parameter already declared: '"+name+"'");
        end else do 
            tc.declare(name, ty, false);
        end
    end;
end;

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := 
    for param in params yield 
        match param do 
            case NormalParam(?, ty) := ty;
        end
    end;

fun check(tc : Typechecker, e : Ast.Expr, t : Ast.Type) := match e do 
    case NumberLiteral(?) := tc.require_assigneable(t, Ast.NumberT(), e);
    case Boolean(?) := tc.require_assigneable(t, Ast.BooleanT(), e);
    case StringLiteral(?) := tc.require_assigneable(t, Ast.StringT(), e);
    case NullLiteral() := tc.require_assigneable(t, Ast.VoidT(), e);
    case ThisExpr() := do 
        if not tc.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        tc.require_assigneable(t, tc.type_of_var("this"), e);
    end;
    case Identifier(name) := do 
        tc.require_assigneable(t, tc.type_of_var(name), e);
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
    end;
    case BinaryOperation(op, lhs, rhs) := tc.require_assigneable(t, infer_binary(tc, op, lhs, rhs), e);
    case UnaryOperation(op, operand) := tc.require_assigneable(t, infer_unary(tc, op, operand), e);
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        linit.init(t);
        check(tc, cond, Ast.BooleanT());
        check(tc, thenBr, t);
        check(tc, elseBr, t);
    end;
    case BlockExpr(stmts, end_expr, lt, lenv) := do 
        check_block(tc, t, stmts, end_expr, e, lenv);
        lt.init(t);
    end;
    case FunctionCall(callee, args) := do 
        val callee_type := infer(tc, callee);
        val Function(param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        tc.require_assigneable(t, ret_type, e);
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(tc, args[i], param_types[i]);
        end
    end;
    case FunctionExpr(params, return_type, body, lenv) := tc.require_assigneable(
        t, 
        infer_function(
            tc, 
            params, 
            return_type, 
            body, 
            lenv), 
        e);
    case TupleExpr(subexprs, lt) := do 
        val Tuple(subtypes) := t else panic("Cannot use expression "+e+" with non-tuple-type "+t);
        lt.init(t);
        if subexprs.length != subtypes.length do 
            panic("Expected tuple of length "+subtypes.length+" in "+e);
        end
        for i in [0..subexprs.length] do 
            check(tc, subexprs[i], subtypes[i]);
        end;
    end;
    case ListExpr(subexprs, lt) := do 
        val ListOf(et) := t else panic("Expected "+t+", got expression of list type: "+e);
        for subexpr in subexprs do 
            check(tc, subexpr, et);
        end;
        lt.init(Ast.ListOf(et));
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do
        val obj_ty := infer(tc, obj);
        lt.init(obj_ty);
        val Name(class_name) := obj_ty else panic("Cannot read property of non-class-type "+obj_ty+"in expression "+e);
        val class_info := tc.type_info_for(class_name);
        val ClassInfo(?, fields, methods) := class_info else panic("Unimplemented type information in property expression");
        if fields.has(name) then do // Read field#
            val ty := fields.get(name).ty;
            tc.require_assigneable(t, ty, e);
            lft.init(ty);
            la.init(Ast.FieldAccess());
        end else if methods.has(name) then do 
            val ty := methods.get(name).ty;
            lft.init(ty);
            tc.require_assigneable(t, ty, e);
            la.init(Ast.MethodAccess());
        end else panic("Class "+class_name+" has no field or method called "+name);
    end;
end;

fun check_block(
    tc : Typechecker, 
    t : Ast.Type, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    total : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)))
do 
    tc.open_scope();
        for stmt in stmts do 
            check_stmt(tc, stmt);
        end;
        if val Some(e) := end_expr then do 
            check(tc, e, t);
        end else do 
            tc.require_assigneable(t, Ast.VoidT(), total);
        end;
        lenv.init(tc.env);
    tc.close_scope();
end

fun infer(t : Typechecker, e : Ast.Expr) : Ast.Type := match e do 
    case NumberLiteral(?) := Ast.NumberT();
    case Boolean(?) := Ast.BooleanT();
    case StringLiteral(?) := Ast.StringT();
    case NullLiteral() := Ast.VoidT();
    case ThisExpr() := do 
        if not t.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        t.type_of_var("this")
    end;
    case Identifier(name) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
        val res := t.type_of_var(name);
        res
    end;
    case BinaryOperation(op, lhs, rhs) := infer_binary(t, op, lhs, rhs);
    case UnaryOperation(op, operand) := infer_unary(t, op, operand);
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        check(t, cond, Ast.BooleanT());
        val ret_type := infer(t, thenBr);
        check(t, elseBr, ret_type);
        linit.init(ret_type);
        ret_type
    end;
    case FunctionExpr(params, return_type, body, lenv) := infer_function(t, params, return_type, body, lenv);
    case BlockExpr(stmts, end_expr, lt, lenv) := infer_block(t, stmts, end_expr, lt, lenv);
    case FunctionCall(callee, args) := do 
        val callee_type := infer(t, callee);
        val Function(param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(t, args[i], param_types[i]);
        end
        ret_type
    end;
    case TupleExpr(subexprs, lt) := do 
        val types : Ast.Type[] := [];
        for expr in subexprs do 
            types.push(infer(t, expr));
        end;
        val resulting := Ast.Tuple(types);
        lt.init(resulting);
        resulting
    end;
    case ListExpr(subexprs, lt) := do 
        val lty : Ast.Type := if subexprs.length = 0 then 
            panic("Cannot infer type of empty list")
        else if subexprs.length = 10 then 
            Ast.ListOf(infer(t, subexprs.first))
        else do 
            val ty := infer(t, subexprs.first);
            for i in [1..subexprs.length] do 
                check(t, subexprs[i], ty);
            end;
            Ast.ListOf(ty)
        end;
        lt.init(lty);
        lty
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do 
        val obj_ty := infer(t, obj);
        lt.init(obj_ty);
        val Name(class_name) := obj_ty else panic("Cannot read property of non-class-type "+obj_ty);
        val class_info := t.type_info_for(class_name);
        val ClassInfo(?, fields, methods) := class_info else panic("Unimplemented: Not class info in property expr");
        if fields.has(name) then do
            la.init(Ast.FieldAccess());
            val ty := fields.get(name).ty;
            lft.init(ty);
            ty
        end else if methods.has(name) then do
            la.init(Ast.MethodAccess());
            val ty := methods.get(name).ty;
            lft.init(ty);
            ty
        end else panic("Class "+class_name+" does not have field or method called "+name)
    end;
end;

fun infer_function(
    t : Typechecker,
    params : Ast.Parameter[], 
    return_type : Ast.Type,
    body : Ast.Expr,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        for param in params do 
            declare_param(t, param);
        end;
        check(t, body, return_type);
        lenv.init(t.env);
    t.close_scope();
    Ast.Function(param_types(params), return_type)
end

fun infer_block(
    t : Typechecker, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    lt : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        for stmt in stmts do 
            check_stmt(t, stmt);
        end
        var result_type := Ast.VoidT();
        if val Some(e) := end_expr then do 
            result_type := infer(t, e);
        end else do end;
        lenv.init(t.env);
    t.close_scope();
    lt.init(result_type);
    result_type
end

fun infer_binary(t : Typechecker, op : Ast.BinOp, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type := match op do 
    case Add() := do 
        val lhs_type := infer(t, lhs);
        match lhs_type do 
            case NumberT() := do 
                check(t, rhs, Ast.NumberT());
                Ast.NumberT()
            end;
            case StringT() := do 
                check(t, rhs, Ast.StringT());
                Ast.StringT()
            end;
            case ? := do 
                t.error.[Ast.Type]("Invalid left type for +: "+lhs_type)
            end;
        end
    end;
    case LessThan() := infer_numeric_comparison(t, lhs, rhs);
    case LessEqual() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterThan() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterEqual() := infer_numeric_comparison(t, lhs, rhs);
    case Equals() := infer_equality(t, lhs, rhs);
    case NotEquals() := infer_equality(t, lhs, rhs);
    case And() := infer_boolean_operator(t, lhs, rhs);
    case Or() := infer_boolean_operator(t, lhs, rhs);
    case Xor() := infer_boolean_operator(t, lhs, rhs);
    case ? := do 
        check(t, lhs, Ast.NumberT());
        check(t, rhs, Ast.NumberT());
        Ast.NumberT()
    end;
end;

fun infer_boolean_operator(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.BooleanT());
    check(t, rhs, Ast.BooleanT());
    Ast.BooleanT()
end

fun infer_numeric_comparison(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.NumberT());
    check(t, rhs, Ast.NumberT());
    Ast.BooleanT()
end

fun infer_equality(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    val compared_type := infer(t, lhs);
    check(t, rhs, compared_type);
    Ast.BooleanT()
end

fun infer_unary(t : Typechecker, op : Ast.UnOp, operand : Ast.Expr) : Ast.Type do 
    val op_type := match op do 
        case Not() := Ast.BooleanT();
        case ? := Ast.NumberT();
    end;
    check(t, operand, op_type);
    op_type 
end
