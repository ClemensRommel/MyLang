module Typechecker;

import Ast;
import Env;
import Util;

fun typecheck(ast : Ast.Program) : Env.Env(Ast.VarInfo) do 
    val tc := new Typechecker();

    declare_builtins(tc);

    for decl in ast.decls do 
        check_decl(tc, decl);
    end;
    tc.env
end

class Typechecker where 
    var env : Env.Env(Ast.VarInfo) := Env.Env.[Ast.VarInfo]();
    var ty_env : Env.Env(Ast.TyInfo) := Env.Env.[Ast.TyInfo]();
    val return_tys : (Bool, Ast.Type)[] := [(false, Ast.Never())]; // Global variables can't return, so push false first
    var is_in_class : Bool := false;
    fun error[A](message : String) : A := panic(message);
    fun require_assigneable(to : Ast.Type, from : Ast.Type, violating_section : Fun() : String) do 
        require_types_exist(this, to);
        require_types_exist(this, from);
        if from = Ast.Never() do return null; end;
        if to != from do
            this.error.[Void](from+" is not assigneable to "+to+" in "+violating_section());
        end;
    end

    fun open_scope() do 
        this.env := this.env.open_scope();
        this.ty_env := this.ty_env.open_scope();
    end
    fun close_scope() do 
        this.env := this.env.close_scope();
        this.ty_env := this.ty_env.close_scope();
    end

    fun type_of_var(name : String) : Ast.Type := this.env.get(name).ty;
    fun is_var_mutable(name : String) : Bool := this.env.get(name).is_mutable;

    fun type_info_for(name : String) : Ast.TyInfo := this.ty_env.get(name);

    fun var_declared(name : String) : Bool := this.env.has(name);
    fun type_declared(name : String) : Bool := this.ty_env.has(name);

    fun declare(name : String, ty : Ast.Type, m : Bool) := this.env.insert(name, Ast.VarInfo(m, ty, name));
    fun declare_type(name : String, ty_info : Ast.TyInfo) := this.ty_env.insert(name, ty_info);

    fun is_global() : Bool := this.env.outer = Util.None.[Env.Env(Ast.VarInfo)]();
end

fun lazy_str(e : Ast.Expr) : Fun() : String := fun() := "" + e;

fun require_types_exist(tc : Typechecker, ty : Ast.Type) := match ty do 
    case Tuple(parts) := do 
        for part in parts do 
            require_types_exist(tc, part);
        end
    end;
    case Function(params, ret_type) := do 
        for param in params do 
            require_types_exist(tc, param);
        end
        require_types_exist(tc, ret_type);
    end;
    case Name(str) := do 
        if !tc.type_declared(str) do 
            panic("Unknown type "+str);
        end
    end;
    case ListOf(elem_ty) := require_types_exist(tc, elem_ty);
    case NumberT() := do end; case BooleanT() := do end; case StringT() := do end; case VoidT() := do end; case Never() := do end;
end;

fun declare_builtins(tc : Typechecker) do 
    tc.declare("panic", Ast.Function([Ast.StringT()], Ast.Never()), false);
end

fun check_stmt(tc : Typechecker, stmt : Ast.Stmt) := match stmt do 
    case PrintStmt(arg) := do 
        infer(tc, arg);
    end;
    case ExprStmt(arg) := do 
        infer(tc, arg);
    end;
    case Declaration(decl) := check_decl(tc, decl);
    case SetStatement(setter, value) := check_set_stmt(tc, setter, value);
end;

fun check_set_stmt(tc : Typechecker, setter : Ast.Setter, value : Ast.Expr) do 
    val expected_type := infer_setter(tc, setter);
    check(tc, value, expected_type);
    check_mutability(tc, setter);
end

fun check_mutability(tc : Typechecker, setter : Ast.Setter) := match setter do 
    case Variable(name) := do 
        if !tc.is_var_mutable(name) do 
            panic("Error: '"+name+"' is not mutable");
        end;
    end;
    case TupleSetter(parts, ?) := do 
        for part in parts do 
            check_mutability(tc, part);
        end;
    end;
    case Property(obj, name, lt) := do 
        val Name(class_name) := lt.get() else panic("Should be unreachable: Property with non-class-type");
        val ClassInfo(?, fields, methods) := tc.type_info_for(class_name) 
            else panic("Should be unreachable: Non-class info in setter");
        val field_info := fields.get(name);
        if not field_info.is_mutable do 
            panic("Cannot change immutable field "+name+" of class "+class_name);
        end
    end;
end;

fun infer_setter(tc : Typechecker, s : Ast.Setter) : Ast.Type := match s do 
    case Variable(name) := tc.type_of_var(name);
    case TupleSetter(subsetters, lt) := do 
        val parts : Ast.Type[] := [];
        for setter in subsetters do 
            parts.push(infer_setter(tc, setter));
        end;
        val ty := Ast.Tuple(parts);
        lt.init(ty);
        ty
    end;
    case Property(obj, name, lcty) := do
        val obj_ty := infer(tc, obj);
        val Name(class_name) := obj_ty else panic("Cannot set property of non-class-type "+obj_ty);
        lcty.init(obj_ty);
        val class_info := tc.type_info_for(class_name);
        val ClassInfo(?, fields, methods) := class_info else panic("Unimplemented type information in property setter");
        if methods.has(name) do 
            panic("Cannot change a method: method "+name+" of class "+class_name);
        end
        if fields.has(name) then do 
            fields.get(name).ty
        end else panic("Class "+class_name+" has no field called "+name)
    end;
end;

fun check_declaration_setter(tc : Typechecker, setter : Ast.Setter, ty : Ast.Type, mut : Bool) do 
    match setter do 
        case Variable(name) := do 
            if tc.env.has(name) do 
                panic("Variable '"+name+"' is already declared");
            end
            tc.declare(name, ty, mut);
        end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of "+setter);
            end;
            for i in [0..setters.length] do 
                check_declaration_setter(tc, setters[i], parts[i], mut);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot use property as variable declaration: " + setter);
    end;
end

fun check_decl(tc : Typechecker, decl : Ast.Decl) := match decl do 
    case VarDecl(setter, lt, init, mutable, ?) := do 
        if lt.is_init() then do 
            if val Some(e) := init then do 
                check(tc, e, lt.get());
            end else do
                if not mutable do 
                    panic("Immutable variable requires initializer: "+setter);
                end
                if not tc.is_in_class do 
                    panic("Variables outside of classes require a initializer: "+setter);
                end
            end;
        end else do
            if val Some(e) := init then do  
                lt.init(infer(tc, e));
            end else do 
                panic("Require either an initializer or a type annotation for variable "+setter+"\n"
                    + (if not mutable then "Immutable variable requires initializer: "+setter else "")
                    + (if not tc.is_in_class then "Variables outside of classes require a initializer: "+setter else ""));
            end;
        end;
        require_types_exist(tc, lt.get());
        check_declaration_setter(tc, setter, lt.get(), mutable);
    end;
    case DesugarableDecl(md) := check_decl(tc, md.get());
    case ValElseDeclaration(pat, matched, else_br, is_mut, is_export, ldecl_ty, lmatched_ty, lenv) := do 
        if ldecl_ty.is_init() then do 
            check_pattern(tc, pat, ldecl_ty.get());
            check(tc, matched, ldecl_ty.get());
            check(tc, else_br, Ast.Never());
            lmatched_ty.init(ldecl_ty.get());
            lenv.init(tc.env);
        end else do 
            val matched_ty := infer(tc, matched);
            lmatched_ty.init(matched_ty);
            ldecl_ty.init(matched_ty);
            check_pattern(tc, pat, matched_ty);
            check(tc, else_br, Ast.Never());
            lenv.init(tc.env);
        end;
    end;
    case FunDecl(name, params, return_type, body, ?, lenv) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        require_types_exist(tc, return_type); // Require all types to exist
        for param in params do 
            match param do 
                case NormalParam(?, ty) := do require_types_exist(tc, ty); end;
            end;
        end;
        val fun_type := Ast.Function(param_types(params), return_type);
        if tc.var_declared(name) then do 
            panic("Function already declared: '"+name+"'");
        end else do 
            tc.declare(name, fun_type, false);
        end;
        tc.open_scope();
            tc.return_tys.push((true, return_type));
            for param in params do 
                declare_param(tc, param);
            end;
            check(tc, body, return_type);
            lenv.init(tc.env);
            tc.return_tys.pop();
        tc.close_scope();
        if tc.is_global() and name = "main" and return_type != Ast.VoidT() do 
            panic("Main may not return anything other than Void");
        end
        if tc.is_global() and name = "main" and params != [] do 
            panic("Main may not define any parameters");
        end;
    end;
    case ClassDecl(name, members, constructor, exported, lenv) := do 
        tc.declare_type(name, Ast.ClassInfo(
            name, 
            fields_in_class(tc, members),
            methods_in_class(tc, members)
        ));
        tc.open_scope();
            tc.return_tys.push((false, Ast.Never()));
            tc.declare("this", Ast.Name(name), false);
            check_body(tc, members);
            val constr_type := check_constructor(tc, constructor, name);
            val body_env := tc.env;
            tc.return_tys.pop();
        tc.close_scope();
        lenv.init(body_env);
        
        tc.declare(name, constr_type, false);
    end;
    case EnumDecl(name, variants, members, is_export, lenv) := do 
        disallow_fields_in_enum(tc, members, name);
        val funs := methods_in_class(tc, members);
        tc.declare_type(name, Ast.EnumInfo(name, variants, funs));
        declare_enum_constructors(tc, name, variants);
        tc.open_scope();
            tc.return_tys.push((false, Ast.Never()));
            tc.declare("this", Ast.Name(name), false);
            check_body(tc, members);
            val body_env := tc.env;
            tc.return_tys.pop();
        tc.close_scope();
        lenv.init(body_env);
    end;
end;

fun declare_enum_constructors(tc : Typechecker, name : String, variants : Ast.EnumConstructor[]) do 
    val enum_ty := Ast.Name(name);
    for constr in variants do 
        for field in constr.fields do 
            require_types_exist(tc, field);
        end
        tc.declare(constr.name, Ast.Function(constr.fields, enum_ty), false);
    end;
end

fun disallow_fields_in_enum(tc : Typechecker, members : Ast.Decl[], name : String) do 
    for member in members do 
        if val VarDecl(setter, ?, ?, ?, ?) := member then do 
            panic("Error: Fields are not allowed as members of enums (in enum "+name+"): "+setter);
        end else do end;
    end;
end

fun fields_in_class(tc : Typechecker, members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case VarDecl(setter, ty, ?, m, ?) := do 
                gather_types(setter, ty.get(), m, types);
            end;
            case ? := do end;
        end;
    end;
    types
end
fun gather_types(setter : Ast.Setter, ty : Ast.Type, mutable : Bool, list : Env.AList(Ast.VarInfo)) do 
    match setter do 
        case Variable(name) := list.insert(name, Ast.VarInfo(mutable, ty, name));
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of field "+setter);
            end;
            for i in [0..setters.length] do 
                gather_types(setters[i], parts[i], mutable, list);
            end;
        end;
        case Property(?, ?, ?) := do end;
    end
end

fun methods_in_class(tc : Typechecker, members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case FunDecl(name, params, ret_ty, body, ?, lenv) := do 
                val fun_ty := Ast.Function(param_types(params), ret_ty);
                types.insert(name, Ast.VarInfo(false, fun_ty, name));
            end;
            case ClassDecl(name, ?, ?, ?, ?) := panic("Error: Do not allow class as member of another class or enum: "+name);
            case EnumDecl(name, ?, ?, ?, ?) := panic("Error: Do not allow enum as member of another class or enum: "+name);
            case ? := do end;
        end;
    end
    types
end

fun check_body(tc : Typechecker, body : Ast.Decl[]) do 
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    for member in body do 
        check_decl(tc, member);
    end;
    tc.is_in_class := prev_in_class;

end

fun check_constructor(tc : Typechecker, constructor : Util.Optional(Ast.Constructor), className : String) : Ast.Type do
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    val result := if val Some(constr) := constructor then do 
        tc.open_scope();
            for param in constr.params do 
                declare_param(tc, param);
            end;
            check(tc, constr.body, Ast.VoidT());
            constr.lenv.init(tc.env);
        tc.close_scope();
        Ast.Function(param_types(constr.params), Ast.Name(className))
    end else do 
        Ast.Function([], Ast.Name(className))
    end;
    tc.is_in_class := prev_in_class;
    result
end

fun declare_param(tc : Typechecker, param : Ast.Parameter) := match param do 
    case NormalParam(name, ty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) then do 
            panic("Parameter already declared: '"+name+"'");
        end else do 
            tc.declare(name, ty, false);
        end
    end;
end;

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := 
    for param in params yield 
        match param do 
            case NormalParam(?, ty) := ty;
        end
    end;

fun check(tc : Typechecker, e : Ast.Expr, t : Ast.Type) := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := check(tc, content.get(), t);
    case NumberLiteral(?) := tc.require_assigneable(t, Ast.NumberT(), lazy_str(e));
    case Boolean(?) := tc.require_assigneable(t, Ast.BooleanT(), lazy_str(e));
    case StringLiteral(?) := tc.require_assigneable(t, Ast.StringT(), lazy_str(e));
    case NullLiteral() := tc.require_assigneable(t, Ast.VoidT(), lazy_str(e));
    case ThisExpr() := do 
        if not tc.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        tc.require_assigneable(t, tc.type_of_var("this"), lazy_str(e));
    end;
    case Identifier(name, lty) := do 
        lty.init(t);
        tc.require_assigneable(t, tc.type_of_var(name), lazy_str(e));
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
    end;
    case BinaryOperation(op, lhs, rhs) := tc.require_assigneable(t, infer_binary(tc, op, lhs, rhs), lazy_str(e));
    case UnaryOperation(op, operand) := tc.require_assigneable(t, infer_unary(tc, op, operand), lazy_str(e));
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        linit.init(t);
        check(tc, cond, Ast.BooleanT());
        check(tc, thenBr, t);
        check(tc, elseBr, t);
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(tc, matched);
        lmatchty.init(matched_ty);
        tc.open_scope();
            check_pattern(tc, pat, matched_ty);
            check(tc, thenBr, t);
            lrety.init(t);
            lenv.init(tc.env);
        tc.close_scope();
        check(tc, elseBr, t);
    end;
    case BlockExpr(stmts, end_expr, lt, lenv) := do 
        check_block(tc, t, stmts, end_expr, e, lenv);
        lt.init(t);
    end;
    case ForExpr(setter, iterated, body, lenv, lt, lit) := check_for(tc, t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := check_while(tc, t, cond, body, lenv, lty);
    case FunctionCall(callee, args) := do 
        val callee_type := infer(tc, callee);
        val Function(param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        tc.require_assigneable(t, ret_type, lazy_str(e));
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(tc, args[i], param_types[i]);
        end
    end;
    case FunctionExpr(params, return_type, body, lenv) := tc.require_assigneable(
        t, 
        infer_function(
            tc, 
            params, 
            return_type, 
            body, 
            lenv), 
        lazy_str(e));
    case TupleExpr(subexprs, lt) := do 
        val Tuple(subtypes) := t else panic("Cannot use expression "+e+" with non-tuple-type "+t);
        lt.init(t);
        if subexprs.length != subtypes.length do 
            panic("Expected tuple of length "+subtypes.length+" in "+e);
        end
        for i in [0..subexprs.length] do 
            check(tc, subexprs[i], subtypes[i]);
        end;
    end;
    case ListExpr(subexprs, lt) := do 
        val ListOf(et) := t else panic("Expected "+t+", got expression of list type: "+e);
        for subexpr in subexprs do 
            check(tc, subexpr, et);
        end;
        lt.init(Ast.ListOf(et));
    end;
    case RangeExpr(start, end_expr) := do
        check(tc, start, Ast.NumberT());
        check(tc, end_expr, Ast.NumberT());
        tc.require_assigneable(t, Ast.ListOf(Ast.NumberT()), lazy_str(e));
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do
        val obj_ty := infer(tc, obj);
        lt.init(obj_ty);

        val (member_ty, acc_ty) := get_property_ty(tc, name, obj_ty, e);
        lft.init(member_ty);
        la.init(acc_ty);
        tc.require_assigneable(t, member_ty, lazy_str(e))
    end;
    case IndexExpr(lst, idx) := do
        check(tc, idx, Ast.NumberT());
        check(tc, lst, Ast.ListOf(t));
    end;
    case MatchExpr(matched, arms, lmty, lty) := do
        val matched_ty := infer(tc, matched);
        lmty.init(matched_ty);
        for (pattern, expr, lenv) in arms do
            tc.open_scope(); 
                check_pattern(tc, pattern, matched_ty);
                check(tc, expr, t);
                lenv.init(tc.env);
            tc.close_scope();
        end;
        lty.init(t);
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(t);
        val (can_return, return_ty) := tc.return_tys.last;
        if !can_return do panic("Cannot return outside of functions or methods: "+e) end
        check(tc, ret, return_ty);
    end;
end;

fun check_pattern(tc : Typechecker, pattern : Ast.Pattern, matched_ty : Ast.Type) do 
    fun pat_str() : String := "" + pattern;
    match pattern do 
        case NumericPattern(?) := do 
            tc.require_assigneable(Ast.NumberT(), matched_ty, pat_str);
        end;
        case StringPattern(?) := do 
            tc.require_assigneable(Ast.StringT(), matched_ty, pat_str);
        end;
        case BooleanPattern(?) := do 
            tc.require_assigneable(Ast.BooleanT(), matched_ty, pat_str);
        end;
        case NamePattern(name) := do 
            tc.declare(name, matched_ty, false);
        end;
        case WildcardPattern() := do end; // Wildcard is ok for everything
        case TuplePattern(patterns) := do 
            if val Tuple(parts) := matched_ty then do
                if parts.length != patterns.length do 
                    panic("Expected tuple of length "+patterns.length+", got tuple of "+parts.length+" in pattern "+pat_str());
                end;
                for i in [0..parts.length] do 
                    check_pattern(tc, patterns[i], parts[i]);
                end;
            end else do 
                panic("Cannot match on non-tuple-type "+matched_ty+" in pattern "+pattern);
            end;
        end;
        case ConstructorPattern(name, subpatterns, lconstr) := do 
            val Name(enum_name) := matched_ty else panic("Cannot match on non-enum-type "+matched_ty+" in "+pattern);
            val EnumInfo(?, constructors, methods) := tc.type_info_for(enum_name) 
                else panic("Cannot match on class type "+matched_ty+"in "+pattern);
            for constr in constructors do 
                if constr.name = name do 
                    lconstr.init(constr);
                    val constr_params := constr.fields;
                    if constr_params.length != subpatterns.length do 
                        panic("Expected "+constr_params.length+" parameters, got "+subpatterns.length+" in "+pattern);
                    end;
                    for i in [0..constr_params.length] do 
                        check_pattern(tc, subpatterns[i], constr_params[i]);
                    end;
                    return null;
                end;
            end;
            panic("Enum "+enum_name+" has no constructor of name "+name);
        end;
    end;
end

fun get_property_ty(tc : Typechecker, name : String, ty : Ast.Type, e : Ast.Expr) : (Ast.Type, Ast.AccessType) := match ty do  
    case Name(class_name) := do
        val class_info := tc.type_info_for(class_name);
        match class_info do 
            case ClassInfo(?, fields, methods) := do 
                if fields.has(name) then do 
                    val ty := fields.get(name).ty;
                    (ty, Ast.FieldAccess())
                end else if methods.has(name) then do 
                    val ty := methods.get(name).ty;
                    (ty, Ast.MethodAccess())
                end else panic("Type "+class_name+" has no field or method called "+name)
            end;
            case EnumInfo(?, ?, methods) := do 
                if methods.has(name) then do 
                    (methods.get(name).ty, Ast.MethodAccess())
                end else panic("Type "+class_name+" has no method called "+name)
            end;
        end
    end;
    case ListOf(elem_ty) := builtin_list_property(elem_ty, name, e);
    case ? := panic("Cannot read property of non-class-type "+ty+"in expression "+e);
end;

fun builtin_list_property(elem_ty : Ast.Type, name : String, e : Ast.Expr) : (Ast.Type, Ast.AccessType) := match name do 
    case "length" := (Ast.NumberT(), Ast.FieldAccess());
    case "first" := (elem_ty, Ast.FieldAccess());
    case "last" := (elem_ty, Ast.FieldAccess());
    case "push" := (Ast.Function([elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "pop" := (Ast.Function([], elem_ty), Ast.MethodAccess());
    // Peekt auf das letzte element. für das erste kann first verwendet werden
    case "peek" := (Ast.Function([], elem_ty), Ast.MethodAccess()); 
    case "dequeue" := (Ast.Function([], elem_ty), Ast.MethodAccess()); // Entfernt das erste element
    case "prepend" := (Ast.Function([elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "append" := (Ast.Function([Ast.ListOf(elem_ty)], Ast.VoidT()), Ast.MethodAccess());
end;

fun check_block(
    tc : Typechecker, 
    t : Ast.Type, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    total : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)))
do 
    tc.open_scope();
        for stmt in stmts do 
            check_stmt(tc, stmt);
        end;
        if val Some(e) := end_expr then do 
            check(tc, e, t);
        end else do 
            tc.require_assigneable(t, Ast.VoidT(), lazy_str(total));
        end;
        lenv.init(tc.env);
    tc.close_scope();
end

fun check_for(
    tc : Typechecker, 
    result_ty : Ast.Type,
    setter : Ast.Setter, 
    iterated : Ast.Expr,
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, setter, elem_ty, false);
        if val VoidT() := result_ty then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := result_ty then do 
            check(tc, body, elem_ty);
        end else do 
            val body_ty := infer(tc, body);
            tc.error.[Void]("Expected "+result_ty+", got "+Ast.ListOf(body_ty));
        end;
        lenv.init(tc.env);
        lt.init(result_ty);
    tc.close_scope();
end

fun check_while(
    tc : Typechecker,  
    expected : Ast.Type, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        if val VoidT() := expected then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := expected then do 
            check(tc, body, elem_ty);
        end else do 
            val elem_ty := infer(tc, body);
            tc.error.[Void]("Expected "+expected+", got "+Ast.ListOf(elem_ty)+" in "+ Ast.WhileExpr(cond, body, lenv, lty));
        end;
        lty.init(expected); // The resulting type of the entire expression, not the element type
        lenv.init(tc.env);
    tc.close_scope();
end

fun infer(t : Typechecker, e : Ast.Expr) : Ast.Type := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := infer(t, content.get());
    case NumberLiteral(?) := Ast.NumberT();
    case Boolean(?) := Ast.BooleanT();
    case StringLiteral(?) := Ast.StringT();
    case NullLiteral() := Ast.VoidT();
    case ThisExpr() := do 
        if not t.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        t.type_of_var("this")
    end;
    case Identifier(name, lty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
        val res := t.type_of_var(name);
        lty.init(res);
        res
    end;
    case BinaryOperation(op, lhs, rhs) := infer_binary(t, op, lhs, rhs);
    case UnaryOperation(op, operand) := infer_unary(t, op, operand);
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        check(t, cond, Ast.BooleanT());
        val ret_type := infer(t, thenBr);
        check(t, elseBr, ret_type);
        linit.init(ret_type);
        ret_type
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(t, matched);
        lmatchty.init(matched_ty);
        t.open_scope();
            check_pattern(t, pat, matched_ty);
            val resulting_ty := infer(t, thenBr);
            lrety.init(resulting_ty);
            lenv.init(t.env);
        t.close_scope();
        check(t, elseBr, resulting_ty);
        resulting_ty
    end;
    case FunctionExpr(params, return_type, body, lenv) := infer_function(t, params, return_type, body, lenv);
    case BlockExpr(stmts, end_expr, lt, lenv) := infer_block(t, stmts, end_expr, lt, lenv);
    case ForExpr(setter, iterated, body, lenv, lt, lit) := infer_for(t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := infer_while(t, cond, body, lenv, lty);
    case FunctionCall(callee, args) := do 
        val callee_type := infer(t, callee);
        val Function(param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(t, args[i], param_types[i]);
        end
        ret_type
    end;
    case TupleExpr(subexprs, lt) := do 
        val types : Ast.Type[] := [];
        for expr in subexprs do 
            types.push(infer(t, expr));
        end;
        val resulting := Ast.Tuple(types);
        lt.init(resulting);
        resulting
    end;
    case ListExpr(subexprs, lt) := do 
        val lty : Ast.Type := if subexprs.length = 0 then 
            panic("Cannot infer type of empty list")
        else if subexprs.length = 10 then 
            Ast.ListOf(infer(t, subexprs.first))
        else do 
            val ty := infer(t, subexprs.first);
            for i in [1..subexprs.length] do 
                check(t, subexprs[i], ty);
            end;
            Ast.ListOf(ty)
        end;
        lt.init(lty);
        lty
    end;
    case RangeExpr(start, end_expr) := do 
        check(t, start, Ast.NumberT());
        check(t, end_expr, Ast.NumberT());
        Ast.ListOf(Ast.NumberT())
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do 
        val obj_ty := infer(t, obj);
        lt.init(obj_ty);

        val (member_ty, acc_ty) := get_property_ty(t, name, obj_ty, e);
        lft.init(member_ty);
        la.init(acc_ty);
        member_ty
    end;
    case IndexExpr(lst, idx) := do
        check(t, idx, Ast.NumberT());
        val list_ty := infer(t, lst);
        val ListOf(et) := list_ty else panic("Require indexed object to be a list, not "+list_ty+" in "+e);
        et
    end;
    case MatchExpr(matched, arms, lmty, lty) := do 
        val matched_ty := infer(t, matched);
        if arms.length = 0 do 
            panic("Cannot infer type of match with out arms: "+e);
        end;
        lmty.init(matched_ty);
        var resulting := Util.None.[Ast.Type]();
        for (pattern, expr, lenv) in arms do 
            t.open_scope();
                check_pattern(t, pattern, matched_ty);
                fun infer_match_ty() do 
                    val ty := infer(t, expr);
                    resulting := Util.Some.[Ast.Type](ty);
                end
                if val Some(ty) := resulting then do 
                    if val VoidT() := ty then do 
                        infer_match_ty();
                    end else do 
                        check(t, expr, ty);
                    end;
                end else do 
                    infer_match_ty();
                end;
                lenv.init(t.env);
            t.close_scope();
        end;
        if val Some(t) := resulting then do 
            lty.init(t);
            t
        end else do 
            panic("Could not infer resulting type of "+e)
        end
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(Ast.Never());
        val (can_return, return_ty) := t.return_tys.last;
        if !can_return do panic("Cannot return outside of functions and methods: "+e); end;
        check(t, ret, return_ty);
        Ast.Never()
    end;
end;

fun infer_function(
    t : Typechecker,
    params : Ast.Parameter[], 
    return_type : Ast.Type,
    body : Ast.Expr,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        for param in params do 
            declare_param(t, param);
        end;
        check(t, body, return_type);
        lenv.init(t.env);
    t.close_scope();
    Ast.Function(param_types(params), return_type)
end

fun infer_block(
    t : Typechecker, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    lt : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        for stmt in stmts do 
            check_stmt(t, stmt);
        end
        var result_type := Ast.VoidT();
        if val Some(e) := end_expr then do 
            result_type := infer(t, e);
        end else do end;
        lenv.init(t.env);
    t.close_scope();
    lt.init(result_type);
    result_type
end

fun infer_for(
    tc : Typechecker, 
    loop_var : Ast.Setter, 
    iterated : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, loop_var, elem_ty, false);
        val resulting_elem_ty := infer(tc, body);
        lenv.init(tc.env);
    tc.close_scope();
    val resulting := Ast.ListOf(resulting_elem_ty);
    lt.init(resulting);
    resulting
end

fun infer_while(
    tc : Typechecker, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        val elem_ty := infer(tc, body);
        val resulting := Ast.ListOf(elem_ty);
        lenv.init(tc.env);
        lty.init(resulting);
    tc.close_scope();
    resulting
end

fun infer_binary(t : Typechecker, op : Ast.BinOp, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type := match op do 
    case Add() := do 
        val lhs_type := infer(t, lhs);
        match lhs_type do 
            case NumberT() := do 
                check(t, rhs, Ast.NumberT());
                Ast.NumberT()
            end;
            case StringT() := do 
                check(t, rhs, Ast.StringT());
                Ast.StringT()
            end;
            case ? := do 
                t.error.[Ast.Type]("Invalid left type for +: "+lhs_type)
            end;
        end
    end;
    case LessThan() := infer_numeric_comparison(t, lhs, rhs);
    case LessEqual() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterThan() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterEqual() := infer_numeric_comparison(t, lhs, rhs);
    case Equals() := infer_equality(t, lhs, rhs);
    case NotEquals() := infer_equality(t, lhs, rhs);
    case And() := infer_boolean_operator(t, lhs, rhs);
    case Or() := infer_boolean_operator(t, lhs, rhs);
    case Xor() := infer_boolean_operator(t, lhs, rhs);
    case ? := do 
        check(t, lhs, Ast.NumberT());
        check(t, rhs, Ast.NumberT());
        Ast.NumberT()
    end;
end;

fun infer_boolean_operator(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.BooleanT());
    check(t, rhs, Ast.BooleanT());
    Ast.BooleanT()
end

fun infer_numeric_comparison(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.NumberT());
    check(t, rhs, Ast.NumberT());
    Ast.BooleanT()
end

fun infer_equality(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    val compared_type := infer(t, lhs);
    check(t, rhs, compared_type);
    Ast.BooleanT()
end

fun infer_unary(t : Typechecker, op : Ast.UnOp, operand : Ast.Expr) : Ast.Type do 
    val op_type := match op do 
        case Not() := Ast.BooleanT();
        case ? := Ast.NumberT();
    end;
    check(t, operand, op_type);
    op_type 
end
