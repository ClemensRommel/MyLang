module Typechecker;

import Ast;
import Env;
import Util;
import SourceFileGatherer;

fun typecheck(file : SourceFileGatherer.SourceFile, other_files : Env.AList(SourceFileGatherer.SourceFile)) do 
    val tc := new Typechecker(file);

    declare_builtins(tc);

    add_imports(tc, file.ast.imports, other_files);

    for decl in file.ast.decls do 
        check_decl(tc, decl);
    end;
    file.globals_env.init(tc.env);
end

fun add_imports(tc : Typechecker, imports : Ast.Import[], other_files : Env.AList(SourceFileGatherer.SourceFile)) do 
    for imported in imports do 
        match imported do 
            case BasicImport(path) := do
                val path := SourceFileGatherer.path_to(imported);
                val file := other_files.get(path);
                tc.imported_modules.insert(path, (file.globals_env.get(), file.types_env.get()));
            end;
        end;
    end
end

fun declare_globals(file : SourceFileGatherer.SourceFile) do 
    file.globals_env.init(Env.Env.[Ast.VarInfo]());
    file.types_env.init(Env.Env.[Ast.TyInfo]());
    declare_functions_and_types(file); // Need to do functions and types first,
    declare_global_variables(file);    // as information about enum constructors is needed for val-else
end

fun declare_global_variables(file : SourceFileGatherer.SourceFile) do
    fun declare_global_variable(decl : Ast.Decl) do 
        match decl do 
            case VarDecl(setter, tyd, ?, mutable, exported) := do 
                if !tyd.is_init() do 
                    panic("Error: Top level declaration of "+setter+"requires type declaration");
                end;
                declare_setter(file, setter, tyd.get(), mutable, exported);
            end;
            case ValElseDeclaration(pat, ?, ?, mutable, exported, lty, ?, ?) := do 
                if !lty.is_init() do 
                    panic("Error: Top level declaration of"+pat+"requires type declaration");
                end;
                declare_pattern(file, pat, lty.get(), mutable, exported);
            end;
            case DesugarableDecl(mutdecl) := declare_global_variable(mutdecl.get());
            case FunDecl(?, ?, ?, ?, ?, ?, ?) := do end;
            case ClassDecl(?, ?, ?, ?, ?) := do end;
            case EnumDecl(?, ?, ?, ?, ?) := do end;
        end;
    end;
    for decl in file.ast.decls do 
        declare_global_variable(decl);
    end;
end

fun declare_functions_and_types(file : SourceFileGatherer.SourceFile) do 
    fun declare_function_and_type(decl : Ast.Decl) do 
        match decl do 
            case DesugarableDecl(mutdecl) := declare_function_and_type(mutdecl.get());
            case VarDecl(setter, tyd, ?, mutable, exported) := do end;
            case ValElseDeclaration(pat, ?, ?, mutable, exported, lty, ?, ?) := do end;
            case FunDecl(name, typarams, parameters, return_ty, ?, exported, ?) := do
                val ty := Ast.Function(typarams, param_types(parameters), return_ty);
                val info := Ast.VarInfo(false, ty, name);
                info.is_exported := exported;
                file.globals_env.get().insert(name, info);
            end;
            case ClassDecl(name, body, constr, exported, ?) := do 
                val info := Ast.ClassInfo(
                    name, 
                    fields_in_class(body),
                    methods_in_class(body),
                    exported
                );
                file.types_env.get().insert(name, info);
                val constr_ty := if val Some(con) := constr 
                    // TODO: Typparameter handlen
                    then Ast.Function([], param_types(con.params), Ast.Name(name, file.types_env))
                    else Ast.Function([], [], Ast.Name(name, file.types_env));
                val varinf := Ast.VarInfo(false, constr_ty, name);
                varinf.is_constructor := true;
                varinf.is_exported := exported;
                file.globals_env.get().insert(name, varinf);
            end;
            case EnumDecl(name, constructors, members, exported, ?) := do
                val funs := methods_in_class(members);
                file.types_env.get().insert(name, Ast.EnumInfo(name, constructors, funs, exported));
                for constr in constructors do 
                    // TODO: Typparameter handlen
                    val info := Ast.VarInfo(false, Ast.Function([], constr.fields, Ast.Name(name, file.types_env)), constr.name);
                    info.is_constructor := true;
                    info.is_exported := exported;
                    file.globals_env.get().insert(constr.name, info);
                end;
            end;
        end;
    end;
    for decl in file.ast.decls do 
        declare_function_and_type(decl);
    end;
end

fun declare_setter(file : SourceFileGatherer.SourceFile, setter : Ast.Setter, ty : Ast.Type, mutable : Bool, exported : Bool) do 
    match setter do 
        case Variable(name) := do 
            val info := Ast.VarInfo(mutable, ty, name);
            info.is_exported := exported;
            file.globals_env.get().insert(name, info);
        end;
        case WildcardSetter() := do end;
        case Property(?, ?, ?) := panic("Error: top level declaration cannot be property");
        case TupleSetter(parts, lty) := do 
            if val Tuple(tys) := ty then do 
                if tys.length = parts.length do 
                    for i in [0..tys.length] do 
                        declare_setter(file, parts[i], tys[i], mutable, exported);
                    end;
                end;
            end else do end; // Error will be detected by typechecker
        end;
    end;
end

fun declare_pattern(file : SourceFileGatherer.SourceFile, pat : Ast.Pattern, ty : Ast.Type, mutable : Bool, exported : Bool) do 
    match pat do 
        case NumericPattern(?) := do end;
        case StringPattern(?) := do end;
        case BooleanPattern(?) := do end;
        case NamePattern(name) := do 
            val info := Ast.VarInfo(mutable, ty, name);
            info.is_exported := exported;
            file.globals_env.get().insert(name, info);
        end;
        case WildcardPattern() := do end;
        case TuplePattern(pats) := do 
            if val Tuple(tys) := ty then do 
                if tys.length = pats.length do 
                    for i in [0..tys.length] do 
                        declare_pattern(file, pats[i], tys[i], mutable, exported);
                    end;
                end;
            end else do end;
        end;
        case ConstructorPattern(constr, patterns, lenumconstr) := do 
            //TODO: Correct name lookup
            val Name(enum_name, ltype_env) := ty else return null; // All enums must be represented by names
            val EnumInfo(name, constructors, methods, exported) := ltype_env.get().get(enum_name) else return null;
            for enum_constr in constructors do 
                if enum_constr.name = constr do // Found correct constructor
                    if enum_constr.fields.length = patterns.length do 
                        for i in [0..patterns.length] do 
                            declare_pattern(file, patterns[i], enum_constr.fields[i], mutable, exported);
                        end;
                    end;
                end;
            end;
        end;
    end;
end

class Typechecker where 
    var env : Env.Env(Ast.VarInfo);
    var ty_env : Env.Env(Ast.TyInfo);
    val return_tys : (Bool, Ast.Type)[] := [(false, Ast.Never())]; // Global variables can't return, so push false first
    val in_loops : Bool[] := [false];
    var is_in_class : Bool := false;
    var scope_depth := 0; // 0 means global

    val imported_modules : Env.AList((Env.Env(Ast.VarInfo), Env.Env(Ast.TyInfo))) 
                        := Env.AList.[(Env.Env(Ast.VarInfo), Env.Env(Ast.TyInfo))]();

    new(file : SourceFileGatherer.SourceFile) do 
        this.env := file.globals_env.get();
        this.ty_env := file.types_env.get();
    end

    fun error[A](message : String) : A := panic(message);
    fun require_assigneable(to : Ast.Type, from : Ast.Type, violating_section : Fun() : String) do 
        require_types_exist(this, to);
        require_types_exist(this, from);
        if from = Ast.Never() do return null; end;
        if !types_equal(to, from) do
            this.error.[Void](from+" is not assigneable to "+to+" in "+violating_section());
        end;
    end

    fun require_kind(to : Ast.Kind, from : Ast.Kind, violating : Ast.Type) do 
        if from != to do 
            match to do 
                case ConcreteType() := panic("Expected concrete type, got generic type"+to+" in"+violating);
                case GenericType(parts, part) := panic("Expected generic type"+to+", got concrete type in "+violating);
            end;
        end
    end

    fun open_scope() do 
        this.env := this.env.open_scope();
        this.ty_env := this.ty_env.open_scope();
        this.scope_depth := this.scope_depth + 1;
    end
    fun close_scope() do 
        this.env := this.env.close_scope();
        this.ty_env := this.ty_env.close_scope();
        this.scope_depth := this.scope_depth - 1;
    end

    fun type_of_var(name : String) : Ast.Type := this.env.get(name).ty;
    fun is_var_mutable(name : String) : Bool := this.env.get(name).is_mutable;

    fun type_info_for(name : String) : Ast.TyInfo := this.ty_env.get(name);

    fun var_declared(name : String) : Bool := this.env.has(name);
    fun type_declared(name : String) : Bool := this.ty_env.has(name);

    fun declare(name : String, ty : Ast.Type, m : Bool) do 
        if this.scope_depth > 0 do // Top level names are already declared
            this.env.insert(name, Ast.VarInfo(m, ty, name));
        end;
    end
    fun declare_type(name : String, ty_info : Ast.TyInfo) := this.ty_env.insert(name, ty_info);

    fun is_global() : Bool := this.env.outer = Util.None.[Env.Env(Ast.VarInfo)]();
end

fun types_equal(to : Ast.Type, from : Ast.Type) : Bool := match (to, from) do 
    case (NumberT(), NumberT()) := true;
    case (Any(), ?) := true; // Can assign everything to any
    case (BooleanT(), BooleanT()) := true;
    case (StringT(), StringT()) := true;
    case (VoidT(), VoidT()) := true;
    case (Tuple(tys1), Tuple(tys2)) := if tys1.length = tys2.length then true 
        else do 
            for i in [0..tys1.length] do 
                if !types_equal(tys1[i], tys2[i]) do 
                    return false;
                end;
            end;
            true
        end;
    case (Name(name1, lenv1), Name(name2, lenv2)) := name1 = name2 
        and if lenv1.is_init() and lenv2.is_init() 
            then lenv1.get() = lenv2.get()
            else panic("Cannot compare names from unknown namespace for equality: "+name1+", "+name2);
    case (Function(typparams1, args1, retty1), (Function(typparams2, args2, retty2))) := types_equal(retty1, retty2)
        and (if typparams1.length != 0 or typparams2.length != 0 then panic("Cannot decide equality of types with type parameters") else true)
        and args1.length = args2.length 
        and do 
            for i in [0..args1.length] do 
                if !types_equal(args1[i], args2[i]) do return false end;
            end;
            true
        end;
    case (ListOf(elem_ty1), ListOf(elem_ty2)) := types_equal(elem_ty1, elem_ty2);
    case (Never(), Never()) := true;
    case (ModuleAccess(?, ?, lty), other_ty) := if lty.is_init() then types_equal(lty.get(), other_ty) else false;
    case (other_ty, ModuleAccess(?, ?, lty)) := if lty.is_init() then types_equal(other_ty, lty.get()) else false;
    case ? := false;
end;

fun lazy_str(e : Ast.Expr) : Fun() : String := fun() := "" + e;

fun require_types_exist(tc : Typechecker, ty : Ast.Type) := match ty do 
    case Tuple(parts) := do 
        for part in parts do 
            require_types_exist(tc, part);
        end
    end;
    // TODO: typparameter
    case Function(type_params, params, ret_type) := do 
        for param in params do 
            require_types_exist(tc, param);
        end
        require_types_exist(tc, ret_type);
    end;
    // TODO: Correct name lookup
    case Name(str, ltypes_env) := do 
        if !ltypes_env.get().has(str) do 
            panic("Unknown type "+str);
        end
    end;
    case ModuleAccess(?, ?, ?) := do end;
    case ListOf(elem_ty) := require_types_exist(tc, elem_ty);
    case NumberT() := do end; case BooleanT() := do end; case StringT() := do end; case VoidT() := do end; case Never() := do end;
    case Any() := do end;
end;

fun declare_builtins(tc : Typechecker) do 
    tc.env.insert("panic", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.Never()), "panic"));
    tc.env.insert("print", Ast.VarInfo(false, Ast.Function([], [Ast.StringT()], Ast.VoidT()), "print"));
end

fun check_stmt(tc : Typechecker, stmt : Ast.Stmt) := match stmt do 
    case ExprStmt(arg) := do 
        infer(tc, arg);
    end;
    case IfStmt(cond, body) := do 
        check(tc, cond, Ast.BooleanT());
        check(tc, body, Ast.VoidT());
    end;
    case Declaration(decl) := check_decl(tc, decl);
    case SetStatement(setter, value) := check_set_stmt(tc, setter, value);
    case EmptyStmt() := do end;
end;

fun check_set_stmt(tc : Typechecker, setter : Ast.Setter, value : Ast.Expr) do 
    val expected_type := infer_setter(tc, setter);
    check(tc, value, expected_type);
    check_mutability(tc, setter);
end

fun check_mutability(tc : Typechecker, setter : Ast.Setter) := match setter do 
    case Variable(name) := do 
        if !tc.is_var_mutable(name) do 
            panic("Error: '"+name+"' is not mutable");
        end;
    end;
    case WildcardSetter() := do end;
    case TupleSetter(parts, ?) := do 
        for part in parts do 
            check_mutability(tc, part);
        end;
    end;
    case Property(obj, name, lt) := do 
        //TODO: Correct name lookup
        val ClassInfo(class_name, fields, methods, ?) := info_for(tc, lt.get(), fun(ty) := "Cannot reassign to property "+name+" of non_class_type"+ty)
            else panic("Should be unreachable: Non-class info in setter");
        val field_info := fields.get(name);
        if not field_info.is_mutable do 
            panic("Cannot change immutable field "+name+" of class "+class_name);
        end
    end;
end;

fun infer_setter(tc : Typechecker, s : Ast.Setter) : Ast.Type := match s do 
    case Variable(name) := tc.type_of_var(name);
    case WildcardSetter() := do panic("Cannot infer wildcard setter") end;
    case TupleSetter(subsetters, lt) := do 
        val parts : Ast.Type[] := [];
        for setter in subsetters do 
            parts.push(infer_setter(tc, setter));
        end;
        val ty := Ast.Tuple(parts);
        lt.init(ty);
        ty
    end;
    case Property(obj, name, lcty) := do
        val obj_ty := infer(tc, obj);
        // TODO: Correct name lookup
        val ClassInfo(name, fields, method) := info_for(tc, obj_ty, fun(ty) := "Cannot assign to property "+name+" of non-class-type"+ty);
        val Name(class_name, lty_env) := obj_ty else panic("Cannot set property of non-class-type "+obj_ty);
        lcty.init(obj_ty);
        val class_info := lty_env.get().get(class_name);
        val ClassInfo(?, fields, methods, ?) := class_info else panic("Unimplemented type information in property setter");
        if methods.has(name) do 
            panic("Cannot change a method: method "+name+" of class "+class_name);
        end
        if fields.has(name) then do 
            fields.get(name).ty
        end else panic("Class "+class_name+" has no field called "+name)
    end;
end;

fun check_declaration_setter(tc : Typechecker, setter : Ast.Setter, ty : Ast.Type, mut : Bool) do 
    match setter do 
        case Variable(name) := do 
            if tc.env.has(name) and tc.scope_depth > 0 do 
                panic("Variable '"+name+"' is already declared");
            end
            tc.declare(name, ty, mut);
        end;
        case WildcardSetter() := do end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of "+setter);
            end;
            for i in [0..setters.length] do 
                check_declaration_setter(tc, setters[i], parts[i], mut);
            end;
        end;
        case Property(?, ?, ?) := panic("Cannot use property as variable declaration: " + setter);
    end;
end

fun check_decl(tc : Typechecker, decl : Ast.Decl) := match decl do 
    case VarDecl(setter, lt, init, mutable, ?) := do 
        if lt.is_init() then do 
            check_kind(tc, lt.get(), Ast.ConcreteType());
            val ty := resolve(tc, lt.get());
            if val Some(e) := init then do 
                check(tc, e, ty);
            end else do
                if not mutable do 
                    panic("Immutable variable requires initializer: "+setter);
                end
                if not tc.is_in_class do 
                    panic("Variables outside of classes require a initializer: "+setter);
                end
            end;
        end else do
            if val Some(e) := init then do  
                lt.init(infer(tc, e)); // Infer always returns a concrete type
            end else do 
                panic("Require either an initializer or a type annotation for variable "+setter+"\n"
                    + (if not mutable then "Immutable variable requires initializer: "+setter else "")
                    + (if not tc.is_in_class then "Variables outside of classes require a initializer: "+setter else ""));
            end;
        end;
        require_types_exist(tc, lt.get());
        check_declaration_setter(tc, setter, lt.get(), mutable);
    end;
    case DesugarableDecl(md) := check_decl(tc, md.get());
    case ValElseDeclaration(pat, matched, else_br, is_mut, is_export, ldecl_ty, lmatched_ty, lenv) := do 
        if ldecl_ty.is_init() then do 
            check_kind(tc, ldecl_ty.get(), Ast.ConcreteType());
            val ty := resolve(tc, ldecl_ty.get());
            check_pattern(tc, pat, ty);
            check(tc, matched, ty);
            check(tc, else_br, Ast.Never());
            lmatched_ty.init(ty);
            lenv.init(tc.env);
        end else do 
            val matched_ty := infer(tc, matched); // Infer always returns a concrete type
            lmatched_ty.init(matched_ty);
            ldecl_ty.init(matched_ty);
            check_pattern(tc, pat, matched_ty);
            check(tc, else_br, Ast.Never());
            lenv.init(tc.env);
        end;
    end;
    case FunDecl(name, typarams, params, return_type, body, ?, lenv) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) and tc.scope_depth > 0  do 
            panic("Function already declared: '"+name+"'");
        end;
        tc.open_scope();
            for param in typarams do 
                if tc.ty_env.has(param.name) do 
                    panic("Type name already declared: "+param.name);
                end
                tc.declare_type(param.name, Ast.TypeParameterInfo(param.name));
            end
            check_kind(tc, return_type, Ast.ConcreteType());
            val resolved_ret_ty := resolve(tc, return_type);
            val fun_type := Ast.Function(typarams, for ty in param_types(params) yield resolve(tc, ty) end, resolved_ret_ty);
        tc.close_scope();
        tc.declare(name, fun_type, false);
        tc.open_scope();
            for param in typarams do //Redeclare type parameters for body
                tc.declare_type(param.name, Ast.TypeParameterInfo(param.name));
            end
            tc.in_loops.push(false);
            tc.return_tys.push((true, resolved_ret_ty));
            for param in params do 
                declare_param(tc, param);
            end;
            check(tc, body, resolved_ret_ty);
            lenv.init(tc.env);
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.close_scope();
        tc.declare(name, fun_type, false);
        if tc.is_global() and name = "main" and return_type != Ast.VoidT() do 
            panic("Main may not return anything other than Void");
        end
        if tc.is_global() and name = "main" and params != [] do 
            panic("Main may not define any parameters");
        end;
    end;
    case ClassDecl(name, members, constructor, exported, lenv) := do 
        tc.declare_type(name, Ast.ClassInfo(
            name, 
            fields_in_class(members),
            methods_in_class(members),
            exported
        ));
        tc.open_scope();
            tc.in_loops.push(false);
            tc.return_tys.push((false, Ast.Never()));
            tc.declare("this", Ast.Name(name, Util.wrap_linit.[Env.Env(Ast.TyInfo)](tc.ty_env)), false);
            check_body(tc, members);
            val constr_type := check_constructor(tc, constructor, name);
            val body_env := tc.env;
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.close_scope();
        lenv.init(body_env);
        
        tc.declare(name, constr_type, false);
    end;
    case EnumDecl(name, variants, members, is_export, lenv) := do 
        disallow_fields_in_enum(tc, members, name);
        val funs := methods_in_class(members);
        tc.declare_type(name, Ast.EnumInfo(name, variants, funs, is_export));
        declare_enum_constructors(tc, name, variants);
        tc.open_scope();
            tc.in_loops.push(false);
            tc.return_tys.push((false, Ast.Never()));
            tc.declare("this", Ast.Name(name, Util.wrap_linit.[Env.Env(Ast.TyInfo)](tc.ty_env)), false);
            check_body(tc, members);
            val body_env := tc.env;
            tc.return_tys.pop();
            tc.in_loops.pop();
        tc.close_scope();
        lenv.init(body_env);
    end;
end;

fun declare_enum_constructors(tc : Typechecker, name : String, variants : Ast.EnumConstructor[]) do 
    val enum_ty := Ast.Name(name, Util.wrap_linit.[Env.Env(Ast.TyInfo)](tc.ty_env));
    for constr in variants do 
        for field in constr.fields do 
            check_kind(tc, field, Ast.ConcreteType());
            require_types_exist(tc, field);
            resolve(tc, field);
        end
        //TODO: Generics
        tc.declare(constr.name, Ast.Function([], constr.fields, enum_ty), false);
    end;
end

fun disallow_fields_in_enum(tc : Typechecker, members : Ast.Decl[], name : String) do 
    for member in members do 
        if val VarDecl(setter, ?, ?, ?, ?) := member then do 
            panic("Error: Fields are not allowed as members of enums (in enum "+name+"): "+setter);
        end else do end;
    end;
end

fun fields_in_class(members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case VarDecl(setter, ty, ?, m, ?) := do 
                gather_types(setter, ty.get(), m, types);
            end;
            case ? := do end;
        end;
    end;
    types
end
fun gather_types(setter : Ast.Setter, ty : Ast.Type, mutable : Bool, list : Env.AList(Ast.VarInfo)) do 
    match setter do 
        case Variable(name) := list.insert(name, Ast.VarInfo(mutable, ty, name));
        case WildcardSetter() := do end;
        case TupleSetter(setters, lt) := do 
            lt.init(ty);
            val Tuple(parts) := ty else panic("Require type "+ty+" to be a tuple in declaration of "+setter);
            if parts.length != setters.length do 
                panic("Expected tuple of length "+parts.length+" in declaration of field "+setter);
            end;
            for i in [0..setters.length] do 
                gather_types(setters[i], parts[i], mutable, list);
            end;
        end;
        case Property(?, ?, ?) := do end;
    end
end

fun methods_in_class(members : Ast.Decl[]) : Env.AList(Ast.VarInfo) do 
    val types : Env.AList(Ast.VarInfo) := Env.AList.[Ast.VarInfo]();
    for member in members do 
        match member do 
            case FunDecl(name, typarams, params, ret_ty, body, ?, lenv) := do
                val fun_ty := Ast.Function(typarams, param_types(params), ret_ty);
                types.insert(name, Ast.VarInfo(false, fun_ty, name));
            end;
            case ClassDecl(name, ?, ?, ?, ?) := panic("Error: Do not allow class as member of another class or enum: "+name);
            case EnumDecl(name, ?, ?, ?, ?) := panic("Error: Do not allow enum as member of another class or enum: "+name);
            case ? := do end;
        end;
    end
    types
end

fun check_body(tc : Typechecker, body : Ast.Decl[]) do 
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    for member in body do 
        check_decl(tc, member);
    end;
    tc.is_in_class := prev_in_class;

end

fun check_constructor(tc : Typechecker, constructor : Util.Optional(Ast.Constructor), className : String) : Ast.Type do
    val prev_in_class := tc.is_in_class;
    tc.is_in_class := true;
    val result := if val Some(constr) := constructor then do 
        tc.open_scope();
            for param in constr.params do 
                declare_param(tc, param);
            end;
            check(tc, constr.body, Ast.VoidT());
            constr.lenv.init(tc.env);
        tc.close_scope();
        // TODO: Generics
        Ast.Function([], param_types(constr.params), Ast.Name(className, Util.wrap_linit.[Env.Env(Ast.TyInfo)](tc.ty_env)))
    end else do 
        Ast.Function([], [], Ast.Name(className, Util.wrap_linit.[Env.Env(Ast.TyInfo)](tc.ty_env)))
    end;
    tc.is_in_class := prev_in_class;
    result
end

fun declare_param(tc : Typechecker, param : Ast.Parameter) := match param do 
    case NormalParam(name, ty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end
        if tc.var_declared(name) then do 
            panic("Parameter already declared: '"+name+"'");
        end else do 
            check_kind(tc, ty, Ast.ConcreteType());
            resolve(tc, ty);
            tc.declare(name, ty, false);
        end
    end;
end;

fun info_for(tc : Typechecker, ty : Ast.Type, error_message : Fun(Ast.Type) : String) : Ast.TyInfo do 
    match ty do 
        case Name(name, lenv) := lenv.get().get(name);
        case ModuleAccess(path, name, lty) := info_for(tc, lty.get(), fun(other_ty) := error_message(ty));
        case ? := panic(error_message(ty));
    end
end

// resolve funktioniert 체ber side effects (d.h. der parameter wird ver채ndert),
// gibt den parameter aber zur체ck
// Macht auch das was require_types_exist tut
fun resolve(tc : Typechecker, ty : Ast.Type) : Ast.Type do 
    match ty do 
        case NumberT() := do end;
        case Any() := do end;
        case BooleanT() := do end;
        case StringT() := do end;
        case VoidT() := do end;
        case Tuple(parts) := do for part in parts do resolve(tc, part) end; end;
        case Name(name, lenv) := do 
            if !lenv.is_init() do // Name belongs to current scope
                if !tc.ty_env.has(name) do panic("Unknown type "+name); end
                lenv.init(tc.ty_env.env_defined_in(name));
            end;
            if !lenv.get().has(name) do // Typ existiert nicht im ziel / derzeitigen scope
                panic("Unknown type "+name);
            end
        end;
        //TODO: Generics
        case Function(typarams, params, ret_ty) := do 
            for param in params do resolve(tc, param); end;
            resolve(tc, ret_ty);
        end;
        case ListOf(tys) := do resolve(tc, tys); end;
        case ModuleAccess(path, name, laccessed) := if laccessed.is_init() then do end else do 
            val file_path := SourceFileGatherer.path_to_module(path);
            if !tc.imported_modules.has(file_path) do
                panic("Unknown module "+join(".", path)+" in "+ty);
            end;
            val (globals_env, types_env) := tc.imported_modules.get(file_path);
            if !types_env.has(name) do  // Type is not declared
                panic("Module "+join(".", path)+" does not declare "+name);
            end
            val ty_info := types_env.get(name); 
            if !is_type_exported(ty_info) do  // Type is not visible from this module
                panic("Module "+join(".", path)+" does not export "+name);
            end
            laccessed.init(Ast.Name(name, Util.wrap_linit.[Env.Env(Ast.TyInfo)](types_env)));
        end;
        case Never() := do end;
    end;
    ty
end

fun is_type_exported(info : Ast.TyInfo) : Bool := match info do 
    case ClassInfo(?, ?, ?, exported) := exported;
    case EnumInfo(?, ?, ?, exported) := exported;
end;

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := 
    for param in params yield 
        match param do 
            case NormalParam(?, ty) := ty;
        end
    end;

fun check(tc : Typechecker, e : Ast.Expr, t : Ast.Type) := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := check(tc, content.get(), t);
    case NumberLiteral(?) := tc.require_assigneable(t, Ast.NumberT(), lazy_str(e));
    case Boolean(?) := tc.require_assigneable(t, Ast.BooleanT(), lazy_str(e));
    case StringLiteral(?) := tc.require_assigneable(t, Ast.StringT(), lazy_str(e));
    case NullLiteral() := tc.require_assigneable(t, Ast.VoidT(), lazy_str(e));
    case ThisExpr() := do 
        if not tc.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        tc.require_assigneable(t, tc.type_of_var("this"), lazy_str(e));
    end;
    case Identifier(name, lty) := do 
        lty.init(t);
        tc.require_assigneable(t, tc.type_of_var(name), lazy_str(e));
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
    end;
    case BinaryOperation(op, lhs, rhs) := tc.require_assigneable(t, infer_binary(tc, op, lhs, rhs), lazy_str(e));
    case UnaryOperation(op, operand) := tc.require_assigneable(t, infer_unary(tc, op, operand), lazy_str(e));
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        linit.init(t);
        check(tc, cond, Ast.BooleanT());
        check(tc, thenBr, t);
        check(tc, elseBr, t);
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(tc, matched);
        lmatchty.init(matched_ty);
        tc.open_scope();
            check_pattern(tc, pat, matched_ty);
            check(tc, thenBr, t);
            lrety.init(t);
            lenv.init(tc.env);
        tc.close_scope();
        check(tc, elseBr, t);
    end;
    case BlockExpr(stmts, end_expr, lt, lenv) := do 
        check_block(tc, t, stmts, end_expr, e, lenv);
        lt.init(t);
    end;
    case ForExpr(setter, iterated, body, lenv, lt, lit) := check_for(tc, t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := check_while(tc, t, cond, body, lenv, lty);
    case WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty) := check_while_val(tc, t, pat, matched, body, lmatched_ty, lenv, lty);
    case FunctionCall(callee, args) := do 
        val callee_type := infer(tc, callee);
        // TODO: Generics
        val Function(typarams, param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        tc.require_assigneable(t, ret_type, lazy_str(e));
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(tc, args[i], param_types[i]);
        end
    end;
    case InstantiationExpr(instantiated, typarams, lty) := tc.require_assigneable(t, infer(tc, e), lazy_str(e));
    case FunctionExpr(params, return_type, body, lenv) := tc.require_assigneable(
        t, 
        infer_function(
            tc, 
            params, 
            return_type, 
            body,
            lenv),
        lazy_str(e));
    case TupleExpr(subexprs, lt) := do 
        val Tuple(subtypes) := t else panic("Cannot use expression "+e+" with non-tuple-type "+t);
        lt.init(t);
        if subexprs.length != subtypes.length do 
            panic("Expected tuple of length "+subtypes.length+" in "+e);
        end
        for i in [0..subexprs.length] do 
            check(tc, subexprs[i], subtypes[i]);
        end;
    end;
    case ListExpr(subexprs, lt) := do 
        val ListOf(et) := t else panic("Expected "+t+", got expression of list type: "+e);
        for subexpr in subexprs do 
            check(tc, subexpr, et);
        end;
        lt.init(Ast.ListOf(et));
    end;
    case RangeExpr(start, end_expr) := do
        check(tc, start, Ast.NumberT());
        check(tc, end_expr, Ast.NumberT());
        tc.require_assigneable(t, Ast.ListOf(Ast.NumberT()), lazy_str(e));
    end;
    case PropertyExpr(obj, name, la, lt, lft) := do
        val infered_type := infer(tc, e);
        tc.require_assigneable(t, infered_type, lazy_str(e));
    end;
    case IndexExpr(lst, idx) := do
        check(tc, idx, Ast.NumberT());
        check(tc, lst, Ast.ListOf(t));
    end;
    case MatchExpr(matched, arms, lmty, lty) := do
        val matched_ty := infer(tc, matched);
        lmty.init(matched_ty);
        for (pattern, expr, lenv) in arms do
            tc.open_scope(); 
                check_pattern(tc, pattern, matched_ty);
                check(tc, expr, t);
                lenv.init(tc.env);
            tc.close_scope();
        end;
        lty.init(t);
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(t);
        val (can_return, return_ty) := tc.return_tys.last;
        if !can_return do panic("Cannot return outside of functions or methods: "+e) end
        check(tc, ret, return_ty);
    end;
    case Break(lty) := do 
        if !tc.in_loops.last do panic("Cannot break outside of loops"); end;
        lty.init(t);
    end;
end;

fun check_pattern(tc : Typechecker, pattern : Ast.Pattern, matched_ty : Ast.Type) do 
    fun pat_str() : String := "" + pattern;
    match pattern do 
        case NumericPattern(?) := do 
            tc.require_assigneable(Ast.NumberT(), matched_ty, pat_str);
        end;
        case StringPattern(?) := do 
            tc.require_assigneable(Ast.StringT(), matched_ty, pat_str);
        end;
        case BooleanPattern(?) := do 
            tc.require_assigneable(Ast.BooleanT(), matched_ty, pat_str);
        end;
        case NamePattern(name) := do 
            tc.declare(name, matched_ty, false);
        end;
        case WildcardPattern() := do end; // Wildcard is ok for everything
        case TuplePattern(patterns) := do 
            if val Tuple(parts) := matched_ty then do
                if parts.length != patterns.length do 
                    panic("Expected tuple of length "+patterns.length+", got tuple of "+parts.length+" in pattern "+pat_str());
                end;
                for i in [0..parts.length] do 
                    check_pattern(tc, patterns[i], parts[i]);
                end;
            end else do 
                panic("Cannot match on non-tuple-type "+matched_ty+" in pattern "+pattern);
            end;
        end;
        case ConstructorPattern(name, subpatterns, lconstr) := do 
            //TODO: Correct name lookup
            val EnumInfo(enum_name, constructors, methods, exported) := info_for(tc, matched_ty, fun(ty) := "Cannot match on non-enum-type "+matched_ty+" in "+pattern)
                else panic("Cannot match on class type "+matched_ty+"in "+pattern);
            for constr in constructors do 
                if constr.name = name do 
                    lconstr.init(constr);
                    val constr_params := constr.fields;
                    if constr_params.length != subpatterns.length do 
                        panic("Expected "+constr_params.length+" parameters, got "+subpatterns.length+" in "+pattern);
                    end;
                    for i in [0..constr_params.length] do 
                        check_pattern(tc, subpatterns[i], constr_params[i]);
                    end;
                    return null;
                end;
            end;
            panic("Enum "+enum_name+" has no constructor of name "+name);
        end;
    end;
end

fun get_property_ty(tc : Typechecker, name : String, ty : Ast.Type, e : Ast.Expr) : (Ast.Type, Ast.AccessType) := match ty do  
    // TODO: Correct name lookup
    case ListOf(elem_ty) := builtin_list_property(elem_ty, name, e);
    case ? := get_property_of_info(info_for(tc, ty, fun(ty) := "Cannot read property of non-class-type "+ty+"in expression "+e), name, e);
end;

fun get_property_of_info(class_info : Ast.TyInfo, name : String, e : Ast.Expr) : (Ast.Type, Ast.AccessType) do 
    match class_info do 
        case ClassInfo(class_name, fields, methods, exported) := do 
            if fields.has(name) then do 
                val ty := fields.get(name).ty;
                (ty, Ast.FieldAccess())
            end else if methods.has(name) then do 
                val ty := methods.get(name).ty;
                (ty, Ast.MethodAccess())
            end else panic("Type "+class_name+" has no field or method called "+name)
        end;
        case EnumInfo(enum_name, ?, methods, exported) := do 
            if methods.has(name) then do 
                (methods.get(name).ty, Ast.MethodAccess())
            end else panic("Type "+enum_name+" has no method called "+name)
        end;
    end
end

fun builtin_list_property(elem_ty : Ast.Type, name : String, e : Ast.Expr) : (Ast.Type, Ast.AccessType) := match name do 
    case "length" := (Ast.NumberT(), Ast.FieldAccess());
    case "first" := (elem_ty, Ast.FieldAccess());
    case "last" := (elem_ty, Ast.FieldAccess());
    case "push" := (Ast.Function([], [elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "pop" := (Ast.Function([], [], elem_ty), Ast.MethodAccess());
    // Peekt auf das letzte element. f체r das erste kann first verwendet werden
    case "peek" := (Ast.Function([], [], elem_ty), Ast.MethodAccess()); 
    case "dequeue" := (Ast.Function([], [], elem_ty), Ast.MethodAccess()); // Entfernt das erste element
    case "prepend" := (Ast.Function([], [elem_ty], Ast.VoidT()), Ast.MethodAccess());
    case "append" := (Ast.Function([], [Ast.ListOf(elem_ty)], Ast.VoidT()), Ast.MethodAccess());
end;

fun check_block(
    tc : Typechecker, 
    t : Ast.Type, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    total : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)))
do 
    tc.open_scope();
        for stmt in stmts do 
            check_stmt(tc, stmt);
        end;
        if val Some(e) := end_expr then do 
            check(tc, e, t);
        end else do 
            tc.require_assigneable(t, Ast.VoidT(), lazy_str(total));
        end;
        lenv.init(tc.env);
    tc.close_scope();
end

fun check_for(
    tc : Typechecker, 
    result_ty : Ast.Type,
    setter : Ast.Setter, 
    iterated : Ast.Expr,
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        tc.in_loops.push(true);
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, setter, elem_ty, false);
        if val VoidT() := result_ty then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := result_ty then do 
            check(tc, body, elem_ty);
        end else do 
            val body_ty := infer(tc, body);
            tc.error.[Void]("Expected "+result_ty+", got "+Ast.ListOf(body_ty));
        end;
        lenv.init(tc.env);
        lt.init(result_ty);
        tc.in_loops.pop();
    tc.close_scope();
end

fun check_while(
    tc : Typechecker,  
    expected : Ast.Type, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        tc.in_loops.push(true);
        if val VoidT() := expected then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := expected then do 
            check(tc, body, elem_ty);
        end else do 
            val elem_ty := infer(tc, body);
            tc.error.[Void]("Expected "+expected+", got "+Ast.ListOf(elem_ty)+" in "+ Ast.WhileExpr(cond, body, lenv, lty));
        end;
        lty.init(expected); // The resulting type of the entire expression, not the element type
        lenv.init(tc.env);
        tc.in_loops.pop();
    tc.close_scope();
end

fun check_while_val(
    tc : Typechecker, 
    expected : Ast.Type, 
    pat : Ast.Pattern, 
    matched : Ast.Expr, 
    body : Ast.Expr, 
    lmatched_ty : Util.LateInitialized(Ast.Type), 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) 
do 
    val matched_ty := infer(tc, matched);
    lmatched_ty.init(matched_ty);
    tc.open_scope();
        tc.in_loops.push(true);
        check_pattern(tc, pat, matched_ty);
        if val VoidT() := expected then do 
            check(tc, body, Ast.VoidT());
        end else if val ListOf(elem_ty) := expected then do
            check(tc, body, elem_ty);
        end else do 
            val elem_ty := infer(tc, body);
            tc.error.[Void]("Expected "+expected+", got "+Ast.ListOf(elem_ty)+" in "+Ast.WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty));
        end;
        lty.init(expected);
        lenv.init(tc.env);
        tc.in_loops.pop();
    tc.close_scope();
end

// Return type is always fully resolved
fun infer(t : Typechecker, e : Ast.Expr) : Ast.Type := match e do 
    case WildCardExpression() := panic("Error: ? is not a valid expression");
    case DesugarableExpr(content) := infer(t, content.get());
    case NumberLiteral(?) := Ast.NumberT();
    case Boolean(?) := Ast.BooleanT();
    case StringLiteral(?) := Ast.StringT();
    case NullLiteral() := Ast.VoidT();
    case ThisExpr() := do 
        if not t.is_in_class do 
            panic("Cannot use 'this' outside of a class");
        end
        t.type_of_var("this")
    end;
    case Identifier(name, lty) := do 
        if matches(name, "__.*") do 
            panic("Names may not start with __: '"+name+"'")
        end;
        val res := t.type_of_var(name);
        lty.init(res);
        res
    end;
    case BinaryOperation(op, lhs, rhs) := infer_binary(t, op, lhs, rhs);
    case UnaryOperation(op, operand) := infer_unary(t, op, operand);
    case IfExpr(linit, cond, thenBr, elseBr) := do 
        check(t, cond, Ast.BooleanT());
        val ret_type := infer(t, thenBr);
        check(t, elseBr, ret_type);
        linit.init(ret_type);
        ret_type
    end;
    case IfValExpr(lrety, pat, matched, thenBr, elseBr, lenv, lmatchty) := do 
        val matched_ty := infer(t, matched);
        lmatchty.init(matched_ty);
        t.open_scope();
            check_pattern(t, pat, matched_ty);
            val resulting_ty := infer(t, thenBr);
            lrety.init(resulting_ty);
            lenv.init(t.env);
        t.close_scope();
        check(t, elseBr, resulting_ty);
        resulting_ty
    end;
    case FunctionExpr(params, return_type, body, lenv) := infer_function(t, params, return_type, body, lenv);
    case BlockExpr(stmts, end_expr, lt, lenv) := infer_block(t, stmts, end_expr, lt, lenv);
    case ForExpr(setter, iterated, body, lenv, lt, lit) := infer_for(t, setter, iterated, body, lenv, lt, lit);
    case WhileExpr(cond, body, lenv, lty) := infer_while(t, cond, body, lenv, lty);
    case WhileValExpr(pat, matched, body, lmatched_ty, lenv, lty) := infer_while_val(t, pat, matched, body, lmatched_ty, lenv, lty);
    case FunctionCall(callee, args) := do 
        val callee_type := infer(t, callee);
        // TODO: Generics
        val Function(typarams, param_types, ret_type) := callee_type else do 
            panic("Cannot call non-function-type "+callee_type+" in "+e)
        end;
        if param_types.length != args.length do 
            panic("Error: tried to call function "+callee+" with "+args.length+
                " parameters, but "+callee+" expects "+param_types.length+" parameters");
        end;
        for i in [0..args.length] do 
            check(t, args[i], param_types[i]);
        end
        ret_type
    end;
    case InstantiationExpr(instantiated, typarams, lty) := do 
        val instantiated_ty := infer(t, instantiated);
        val Function(expected_typarams, valparams, retty) := instantiated_ty 
            else panic("Cannot instantiate non-generic type: "+instantiated_ty);
        if typarams.length != expected_typarams.length do 
            panic("Error: Expected "+expected_typarams.length
                  +" type parameters, got "+typarams.length+" type parameters in"+e);
        end 
        val typaram_substitutes : Env.AList(Ast.Type) := Env.AList.[Ast.Type]();
        for i in [0..typarams.length] do 
            typaram_substitutes.insert(expected_typarams[i].name, typarams[i]);
        end
        val sty := substitute(instantiated_ty, typaram_substitutes);
        lty.init(sty);
        sty
    end;
    case TupleExpr(subexprs, lt) := do 
        val types : Ast.Type[] := [];
        for expr in subexprs do 
            types.push(infer(t, expr));
        end;
        val resulting := Ast.Tuple(types);
        lt.init(resulting);
        resulting
    end;
    case ListExpr(subexprs, lt) := do 
        val lty : Ast.Type := if subexprs.length = 0 then 
            panic("Cannot infer type of empty list")
        else if subexprs.length = 10 then 
            Ast.ListOf(infer(t, subexprs.first))
        else do 
            val ty := infer(t, subexprs.first);
            for i in [1..subexprs.length] do 
                check(t, subexprs[i], ty);
            end;
            Ast.ListOf(ty)
        end;
        lt.init(lty);
        lty
    end;
    case RangeExpr(start, end_expr) := do 
        check(t, start, Ast.NumberT());
        check(t, end_expr, Ast.NumberT());
        Ast.ListOf(Ast.NumberT())
    end;
    case PropertyExpr(obj, name, la, lt, lft) := if val Module(path) := accessed_object(t, obj) then do  
        val (accessed_globals, ?) := t.imported_modules.get(SourceFileGatherer.path_to_module(path));
        la.init(Ast.ModuleAccessed());
        lt.init(Ast.Never());
        if !accessed_globals.has(name) do 
            panic("Module "+join(".", path)+" does not declare "+name);
        end;
        val accessed := accessed_globals.get(name);
        if !accessed.is_exported do 
            panic("Module "+join(".", path)+" does not export "+name);
        end
        lft.init(accessed.ty);
        accessed.ty
    end else do 
        val obj_ty := infer(t, obj);
        lt.init(obj_ty);

        val (member_ty, acc_ty) := get_property_ty(t, name, obj_ty, e);
        lft.init(member_ty);
        la.init(acc_ty);
        member_ty
    end;
    case IndexExpr(lst, idx) := do
        check(t, idx, Ast.NumberT());
        val list_ty := infer(t, lst);
        val ListOf(et) := list_ty else panic("Require indexed object to be a list, not "+list_ty+" in "+e);
        et
    end;
    case MatchExpr(matched, arms, lmty, lty) := do 
        val matched_ty := infer(t, matched);
        if arms.length = 0 do 
            panic("Cannot infer type of match with out arms: "+e);
        end;
        lmty.init(matched_ty);
        var resulting := Util.None.[Ast.Type]();
        for (pattern, expr, lenv) in arms do 
            t.open_scope();
                check_pattern(t, pattern, matched_ty);
                fun infer_match_ty() do 
                    val ty := infer(t, expr);
                    resulting := Util.Some.[Ast.Type](ty);
                end
                if val Some(ty) := resulting then do 
                    if val VoidT() := ty then do 
                        infer_match_ty();
                    end else do 
                        check(t, expr, ty);
                    end;
                end else do 
                    infer_match_ty();
                end;
                lenv.init(t.env);
            t.close_scope();
        end;
        if val Some(t) := resulting then do 
            lty.init(t);
            t
        end else do 
            panic("Could not infer resulting type of "+e)
        end
    end;
    case ReturnExpr(ret, lty) := do 
        lty.init(Ast.Never());
        val (can_return, return_ty) := t.return_tys.last;
        if !can_return do panic("Cannot return outside of functions and methods: "+e); end;
        check(t, ret, return_ty);
        Ast.Never()
    end;
    case Break(lty) := do 
        if !t.in_loops.last do panic("Cannot break outside of loops"); end;
        lty.init(Ast.Never());
        Ast.Never()
    end;
end;

fun substitute(ty : Ast.Type, substitutes : Env.AList(Ast.Type)) : Ast.Type := match ty do 
    case NumberT() := ty;
    case Any() := ty;
    case BooleanT() := ty;
    case StringT() := ty;
    case VoidT() := ty;
    case Tuple(tys) := Ast.Tuple(for t in tys yield substitute(t, substitutes) end);
    // tylevelparams has to be either [] or the types we substitute, because you cant return generic functions
    case Function(tylevelparams, argtypes, rettype) := 
        Ast.Function([], 
                     for t in argtypes yield substitute(t, substitutes) end, 
                     substitute(rettype, substitutes));
    case ListOf(elem_ty) := Ast.ListOf(substitute(elem_ty, substitutes));
    case ModuleAccess(?, ?, ?) := ty;
    case Never() := ty;
    case Name(name, lenv) := if substitutes.has(name) 
            then substitutes.get(name)
            else ty; // Not a type parameter to be replaced, leave it alone
end;

fun accessed_object(tc : Typechecker, expr : Ast.Expr) : Ast.AccessedObjectType do 
    val Module(path) := Ast.get_as_path(expr) else return Ast.NormalObject(); // Expression has to be a path
    if tc.imported_modules.has(SourceFileGatherer.path_to_module(path)) then // Expression is an imported object
        Ast.Module(path)
    else 
        Ast.NormalObject()
end

fun infer_function(
    t : Typechecker,
    params : Ast.Parameter[], 
    return_type : Ast.Type,
    body : Ast.Expr,
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        t.in_loops.push(false);
        for param in params do 
            declare_param(t, param);
        end;
        check_kind(t, return_type, Ast.ConcreteType());
        check(t, body, return_type);
        lenv.init(t.env);
        t.in_loops.pop();
    t.close_scope();
    Ast.Function([], param_types(params), return_type)
end

fun infer_block(
    t : Typechecker, 
    stmts : Ast.Stmt[], 
    end_expr : Util.Optional(Ast.Expr),
    lt : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo))) : Ast.Type
do 
    t.open_scope();
        for stmt in stmts do 
            check_stmt(t, stmt);
        end
        var result_type := Ast.VoidT();
        if val Some(e) := end_expr then do 
            result_type := infer(t, e);
        end else do end;
        lenv.init(t.env);
    t.close_scope();
    lt.init(result_type);
    result_type
end

fun infer_for(
    tc : Typechecker, 
    loop_var : Ast.Setter, 
    iterated : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lt : Util.LateInitialized(Ast.Type),
    lit : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    val iterated_ty := infer(tc, iterated);
    tc.open_scope();
        tc.in_loops.push(true);
        val ListOf(elem_ty) := iterated_ty else panic("Cannot iterate non-list-type "+iterated_ty);
        lit.init(elem_ty);
        check_declaration_setter(tc, loop_var, elem_ty, false);
        val resulting_elem_ty := infer(tc, body);
        lenv.init(tc.env);
        tc.in_loops.pop();
    tc.close_scope();
    val resulting := Ast.ListOf(resulting_elem_ty);
    lt.init(resulting);
    resulting
end

fun infer_while(
    tc : Typechecker, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) : Ast.Type 
do 
    check(tc, cond, Ast.BooleanT());
    tc.open_scope();
        tc.in_loops.push(true);
        val elem_ty := infer(tc, body);
        val resulting := Ast.ListOf(elem_ty);
        lenv.init(tc.env);
        lty.init(resulting);
        tc.in_loops.pop();
    tc.close_scope();
    resulting
end

fun infer_while_val(
    tc : Typechecker,
    pat : Ast.Pattern,
    matched : Ast.Expr,
    body : Ast.Expr,
    lmatched_ty : Util.LateInitialized(Ast.Type),
    lenv : Util.LateInitialized(Env.Env(Ast.VarInfo)), 
    lty : Util.LateInitialized(Ast.Type)) : Ast.Type
do 
    val matched := infer(tc, matched);
    lmatched_ty.init(matched);
    tc.open_scope();
        tc.in_loops.push(true);
        check_pattern(tc, pat, matched);
        val elem_ty := infer(tc, body);
        val resulting := Ast.ListOf(elem_ty);
        lenv.init(tc.env);
        lty.init(resulting);
        tc.in_loops.pop();
    tc.close_scope();
    resulting
end

fun infer_binary(t : Typechecker, op : Ast.BinOp, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type := match op do 
    case Add() := do 
        val lhs_type := infer(t, lhs);
        match lhs_type do 
            case NumberT() := do 
                check(t, rhs, Ast.NumberT());
                Ast.NumberT()
            end;
            case StringT() := do 
                check(t, rhs, Ast.Any());
                Ast.StringT()
            end;
            case ? := do 
                t.error.[Ast.Type]("Invalid left type for +: "+lhs_type)
            end;
        end
    end;
    case LessThan() := infer_numeric_comparison(t, lhs, rhs);
    case LessEqual() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterThan() := infer_numeric_comparison(t, lhs, rhs);
    case GreaterEqual() := infer_numeric_comparison(t, lhs, rhs);
    case Equals() := infer_equality(t, lhs, rhs);
    case NotEquals() := infer_equality(t, lhs, rhs);
    case And() := infer_boolean_operator(t, lhs, rhs);
    case Or() := infer_boolean_operator(t, lhs, rhs);
    case Xor() := infer_boolean_operator(t, lhs, rhs);
    case ? := do 
        check(t, lhs, Ast.NumberT());
        check(t, rhs, Ast.NumberT());
        Ast.NumberT()
    end;
end;

fun infer_boolean_operator(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.BooleanT());
    check(t, rhs, Ast.BooleanT());
    Ast.BooleanT()
end

fun infer_numeric_comparison(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    check(t, lhs, Ast.NumberT());
    check(t, rhs, Ast.NumberT());
    Ast.BooleanT()
end

fun infer_equality(t : Typechecker, lhs : Ast.Expr, rhs : Ast.Expr) : Ast.Type do 
    val compared_type := infer(t, lhs);
    check(t, rhs, compared_type);
    Ast.BooleanT()
end

fun infer_unary(t : Typechecker, op : Ast.UnOp, operand : Ast.Expr) : Ast.Type do 
    val op_type := match op do 
        case Not() := Ast.BooleanT();
        case ? := Ast.NumberT();
    end;
    check(t, operand, op_type);
    op_type 
end

fun check_kind(tc : Typechecker, ty : Ast.Type, kind : Ast.Kind) do 
    match ty do 
        case NumberT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case BooleanT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case StringT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case VoidT() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case Any() := tc.require_kind(kind, Ast.ConcreteType(), ty);
        case Function(typarams, params, ret_ty) := do 
            tc.open_scope();
                for param in typarams do 
                    tc.declare_type(param.name, Ast.TypeParameterInfo(param.name));
                end
                for param in params do 
                    check_kind(tc, param, Ast.ConcreteType());
                end
                check_kind(tc, ret_ty, Ast.ConcreteType());
            tc.close_scope();
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case ListOf(elem_type) := do 
            check_kind(tc, elem_type, Ast.ConcreteType());
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Never() := do 
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Tuple(parts) := do 
            for part in parts do 
                check_kind(tc, part, Ast.ConcreteType());
            end;
            tc.require_kind(kind, Ast.ConcreteType(), ty);
        end;
        case Name(name, lenv) := do
            val variable_kind := kind_of(tc, ty);
            tc.require_kind(kind, variable_kind, ty);
        end;
        case ModuleAccess(path, name, lty) := do 
            val member_kind := kind_of(tc, ty);
            tc.require_kind(kind, member_kind, ty);
        end;
    end
end

fun kind_of(tc : Typechecker, ty : Ast.Type) : Ast.Kind do
    match resolve(tc, ty) do 
        case NumberT() := Ast.ConcreteType();
        case BooleanT() := Ast.ConcreteType();
        case StringT() := Ast.ConcreteType();
        case VoidT() := Ast.ConcreteType();
        case Any() := Ast.ConcreteType();
        case Tuple(tys) := Ast.ConcreteType();
        case Name(name, lenv) := do 
            val info := info_for(tc, ty, fun(this_ty) := "Cannot infer kind of type "+this_ty);
            val kind := kind_of_info(tc, info);
            kind
        end;
        case ModuleAccess(?, ?, lty) := kind_of(tc, lty.get());
    end
end

fun kind_of_info(tc : Typechecker, info : Ast.TyInfo) : Ast.Kind := match info do 
    case TypeParameterInfo(?) := Ast.ConcreteType(); // Type parameters cannot be generic (no higher kinded types)
    case ClassInfo(name, fields, methods, exported) := Ast.ConcreteType(); // TODO: Classes cannot be generic yet
    case EnumInfo(name, constructors, methods, exported) := Ast.ConcreteType(); // TODO: Enums cannot be generic yet
end;