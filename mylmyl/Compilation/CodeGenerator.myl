module Compilation.CodeGenerator;

import Ast := Syntax.Ast;
import Env := Syntax.Env;
import Analyze := Typechecking.Analyze;
import Util;
import SFG := IO.SourceFileGatherer;
import CB := Compilation.CodeBuffers;

class Compiler where 
    var buf : CB.StringBuffer := CB.StringBuffer();
    var name_gen : CB.NameGenerator;
    val sfg : SFG.SFGatherer;

    var is_class : Bool := true;
    var is_static : Bool := true;
    var is_generated_interface : Bool := false;
    var expect_ref_ty : Bool := false; // Wether we're currently compiling a type that is a type parameter

    val ungenerated_types : CB.UncreatedTypes;

    var current_env : Ast.Namespace;

    var env : Env.Env(VariableInfo) := Env.Env.[VariableInfo]();

    val all_modules : Env.AList(Env.Env(VariableInfo));

    val loop_labels : String[] := [];

    val generated_module_path : String;

    new(globals : Ast.Namespace, 
        nameg : CB.NameGenerator, 
        modules : Env.AList(Env.Env(VariableInfo)), 
        gen_mod_path : String,
        uncreated_types : CB.UncreatedTypes,
        the_sfg : SFG.SFGatherer,
        file : SFG.SourceFile) 
    do 
        this.sfg := the_sfg;
        this.current_env := globals;
        this.name_gen := nameg;
        this.all_modules := modules;
        this.generated_module_path := gen_mod_path;
        this.ungenerated_types := uncreated_types;
    end

    fun append(str : String) do
        this.buf.append(str);
    end

    fun newline() do 
        this.buf.newline();
    end

    fun indent() do 
        this.buf.indent();
    end
    
    fun dedent() do 
        this.buf.dedent();
    end

    fun strip_trailing() do 
        this.buf.strip_trailing();
    end

    fun new_var() : String := this.name_gen.next_name();

    fun enqueue_type(t : Ast.Type, type_name : String) do 
        this.ungenerated_types.enqueue_type(t, type_name);
    end
    
    fun get_enqueued_type(t : Ast.Type) : Optional(String) do
        this.ungenerated_types.get_enqueued_type(t)
    end

    fun open_scope(new_env : Ast.Namespace) : ScopeInfo do 
        val previous_is_class := this.is_class;
        val previous_is_static := this.is_static;
        val previous_env := this.current_env;
        val previous_is_generated_interface := this.is_generated_interface;
        this.current_env := new_env;
        this.env := this.env.open_scope();
        this.is_class := false;
        this.is_static := false;
        this.is_generated_interface := false;
        ScopeInfo(previous_is_class, previous_env, previous_is_static, previous_is_generated_interface)
    end

    fun close_scope(sci : ScopeInfo) do 
        this.is_static := sci.previous_is_static;
        this.is_class := sci.previous_is_class;
        this.current_env := sci.previous_env;
        this.is_generated_interface := sci.previous_is_generated_interface;
        this.env := this.env.close_scope();
    end
end

class ScopeInfo where 
    val previous_is_class : Bool;
    val previous_env : Ast.Namespace;
    val previous_is_static : Bool;
    val previous_is_generated_interface : Bool;
    new(pic : Bool, penv : Ast.Namespace, pis : Bool, pigi : Bool) do 
        this.previous_is_class := pic;
        this.previous_env := penv;
        this.previous_is_static := pis;
        this.previous_is_generated_interface := pigi;
    end
end



enum Target where 
    Ignore(), UsedDirectly(), Return(), AssignTo(Ast.Setter);
end

class VariableInfo where 
    val defined_file : String[];
    var is_no_fc_fn : Bool := false;
    var is_constructor : Bool := false;
    var is_upvalue : Bool := false;
    new(mod_path : String[]) do 
        this.defined_file := mod_path;
    end
end

fun declare_builtins(c : Compiler) do 
    val p := c.current_env.module_path;
    c.env.insert("panic", do val panic_info := VariableInfo(p); panic_info.is_no_fc_fn := true; panic_info end);
    c.env.insert("print", do val print_info := VariableInfo(p); print_info.is_no_fc_fn := true; print_info end);
    c.env.insert("args", do val args_info := VariableInfo(p); args_info.is_no_fc_fn := true; args_info end);
    c.env.insert("join", do val join_info := VariableInfo(p); join_info.is_no_fc_fn := true; join_info end);
    c.env.insert("split", do val split_info := VariableInfo(p); split_info.is_no_fc_fn := true; split_info end);
    c.env.insert("number", do val number_info := VariableInfo(p); number_info.is_no_fc_fn := true; number_info end);
    c.env.insert("len", do val len_info := VariableInfo(p); len_info.is_no_fc_fn := true; len_info end);
    c.env.insert("strip", do val strip_info := VariableInfo(p); strip_info.is_no_fc_fn := true; strip_info end);
    c.env.insert("matches", do val match_info := VariableInfo(p); match_info.is_no_fc_fn := true; match_info end);
    c.env.insert("openFile", do val of_info := VariableInfo(p); of_info.is_no_fc_fn := true; of_info end);
    c.env.insert("writeToFile", do val write_info := VariableInfo(p); write_info.is_no_fc_fn := true; write_info end);
    c.env.insert("isNull", do val isn_info := VariableInfo(p); isn_info.is_no_fc_fn := true; isn_info end);
    c.env.insert("replace", do val repl_info := VariableInfo(p); repl_info.is_no_fc_fn := true; repl_info end);
    c.env.insert("move_line_up", do val move_info := VariableInfo(p); move_info.is_no_fc_fn := true; move_info end);
end

fun gather_global_variable_info(files : Env.AList(SFG.SourceFile)) : Env.AList(Env.Env(VariableInfo)) do 
    val list := Env.AList.[Env.Env(VariableInfo)]();
    for (?, file) in files.bindings do 
        val env := Env.Env.[VariableInfo]();
        gather_variable_info(env, file.ast.decls, file.names.module_path);
        list.insert(file.path, env);
    end;
    list
end

fun compile(
    file : SFG.SourceFile, 
    name_gen : CB.NameGenerator, 
    infos : Env.AList(Env.Env(VariableInfo)), 
    generated_path : String[], 
    ungenerated_types : CB.UncreatedTypes,
    the_sfg : SFG.SFGatherer) : String 
do 
    val path_parts := split(file.path, "/"); // Parts of path
    val file_name_parts := split(path_parts.last, "\\."); // Name before extension
    val file_name := file_name_parts.first;
    val generated_prefix := split(the_sfg.file_prefix, "/");
    val generated_prefix_str := 
        join(".", generated_prefix) 
        + (if generated_prefix.length > 0 then "." else "");
    val c := Compiler(
        file.names, name_gen, 
        infos, generated_prefix_str + join(".", generated_path), 
        ungenerated_types, the_sfg, file);
    c.env := infos.get(file.path);
    declare_builtins(c);
    if  file.path != SFG.std_implicit_path do add_implicit_imports(c, infos.get(SFG.std_implicit_path)); end;
    declare_package(c, path_parts);
    import_implicits(c);

    c.append("import ");
    val output_path_parts := split(the_sfg.file_prefix, "/");
    c.append(join(".", output_path_parts));
    if output_path_parts.length > 0 do c.append("."); end;
    c.append(join(".", generated_path)); c.append(";"); c.newline();
    
    compile_imports(c, file.ast.imports, output_path_parts);
    c.append("public class _"+file_name+" {");
    c.indent(); c.newline();
    for decl in file.ast.decls do 
        compile_decl(c, decl);
    end;
    c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.buf.buf
end

fun add_implicit_imports(c : Compiler, file : Env.Env(VariableInfo)) do 
    for (name, info) in file.bindings.bindings do 
        c.env.insert(name, info);
    end
end

fun gather_variable_info(env : Env.Env(VariableInfo), decls : Ast.Decl[], p : String[]) do 
    fun gather_info(decl : Ast.Decl) do 
        match decl do 
            case DesugarableDecl(mutdecl) := gather_info(mutdecl.get());
            case EmptyDecl() := do end;
            case FunDecl(name, typarams, ?, ?, ?, ?, ?) := do 
                val info := VariableInfo(p);
                info.is_no_fc_fn := true; // Global functions cant be lambdas
                env.insert(name, info);
            end;
            case ClassDecl(name, ?, ?, ?, ?, ?) := do 
                val info := VariableInfo(p);
                info.is_constructor := true;
                info.is_no_fc_fn := true;
                env.insert(name, info);
            end;
            case EnumDecl(?, ?, constrs, ?, ?, ?) := do 
                for constr in constrs do 
                    val info := VariableInfo(p);
                    info.is_constructor := true;
                    info.is_no_fc_fn := true;
                    env.insert(constr.name, info);
                end;
            end;
            case VarDecl(setter, ?, ?, ?, ?) := do 
                gather_info_for_setter(env, setter, p);
            end;
            case ValElseDeclaration(pat, ?, ?, ?, ?, ?, ?, ?) := do 
                gather_info_for_pattern(env, pat, p);
            end;
        end;
    end
    for decl in decls do 
        gather_info(decl);
    end
end

fun gather_info_for_setter(env : Env.Env(VariableInfo), setter : Ast.Setter, p : String[]) do 
    match setter do 
        case Variable(name) := do env.insert(name, VariableInfo(p)); end; //Globals cant be upvalues
        case WildcardSetter() := do end;
        case TupleSetter(parts, ?) := do for part in parts do gather_info_for_setter(env, part, p); end; end;
        case Property(?, ?, ?) := do end;
    end;
end

fun gather_info_for_pattern(env : Env.Env(VariableInfo), pat : Ast.Pattern, p : String[]) do 
    match pat do 
        case NumericPattern(?) := do end;
        case StringPattern(?) := do end;
        case BooleanPattern(?) := do end;
        case NamePattern(name) := do env.insert(name, VariableInfo(p)); end;
        case WildcardPattern() := do end;
        case TuplePattern(parts) := do for part in parts do gather_info_for_pattern(env, part, p); end; end;
        case ConstructorPattern(?, parts, ? , lenum_ty, linf) := do for part in parts do gather_info_for_pattern(env, part, p); end; end;
    end;
end;

fun declare_package(c : Compiler, path : String[]) do 
    if path.length > 1 do 
        c.append("package ");
        var need_dot := false;
        for i in [0..path.length - 1] do 
            if need_dot do c.append("."); end;
            c.append(path[i]);
            need_dot := true;
        end;
        c.append(";"); c.newline(); 
        c.newline();
    end
end

fun import_implicits(c : Compiler) do 
    c.append("import static std.runtime.Functions.*;");
    c.newline();
    c.append("import std.runtime.*;");
    c.newline();
    c.newline();
    c.append("import java.util.ArrayList;");
    c.newline();

    c.newline();
end

fun compile_imports(c : Compiler, imports : Ast.Import[], path_parts : String[]) do 
    fun compile_basic_import(parts : String[]) do 
        if parts.length > 1 then do // Classes without package before them dont need to be imported
            c.append("import ");
            var needs_dot := false;
            for part in path_parts do 
                if needs_dot do c.append("."); end;
                c.append(part);
                needs_dot := true;
            end;
            for j in [0..parts.length-1] do 
                if needs_dot do c.append("."); end;
                val part := parts[j];
                c.append(part);
                needs_dot := true;
            end;
            c.append("._"); c.append(parts[parts.length-1]);
            c.append(";"); c.newline();
        end else do 
            c.append("import ");
            var needs_dot := false;
            for part in path_parts do 
                if needs_dot do c.append("."); end;
                c.append(part);
                needs_dot := true;
            end;
            if needs_dot do c.append("."); end;
            if parts[0]!= "_" do c.append("_"); end; // Not a generated file
            c.append(parts[0]);
            c.append(";");
            c.newline();
        end;
    end
    for i in imports do 
        match i do 
            case BasicImport(parts) := do 
                compile_basic_import(parts);
            end;
            case AliasImport(alias, parts) := do 
                compile_basic_import(parts); // TODO: Alias deklarieren
            end;
        end;
    end;
    c.newline();
end

fun compile_stmt(c : Compiler, stmt : Ast.Stmt) := match stmt do 
    case ExprStmt(expr) := do 
        val arg := compile_expr(c, expr, Ignore());
    end;
    case IfStmt(cond, body) := do 
        val cond_compiled := compile_expr(c, cond, UsedDirectly());
        c.append("if("); c.append(cond_compiled); c.append(") {"); c.indent(); c.newline();
        compile_expr(c, body, Ignore());
        c.dedent(); c.newline();
        c.append("}");
    end;
    case EmptyStmt() := do end;
    case Declaration(decl) := compile_decl(c, decl);
    case SetStatement(setter, expr) := do compile_expr(c, expr, AssignTo(setter)); end;
end;

fun compile_decl(c : Compiler, decl : Ast.Decl) := match decl do 
    case DesugarableDecl(md) := compile_decl(c, md.get());
    case EmptyDecl() := do end;
    case VarDecl(setter, lt, init, mutable, ?) := compile_var_decl(c, setter, lt, init, mutable);
    case FunDecl(name, typarams, params, return_type, body, ?, lenv) := compile_fun_decl(c, name, typarams, params, return_type, body, lenv);
    case ClassDecl(name, targs, members, opt_constr, ?, lenv) := compile_class_decl(c, name, targs, members, opt_constr, lenv.get());
    case EnumDecl(name, targs, variants, members, ?, lenv) := compile_enum_decl(c, name, targs, variants, members, lenv.get());
end;

fun compile_enum_decl(c : Compiler, name : String, targs: Ast.TypeParameter[], variants : Ast.EnumConstructor[], members : Ast.Decl[], env : Ast.Namespace) do 
    val prefix := (if c.is_class then "public " else "") + (if c.is_static then "static " else "");
    c.append(prefix);
    c.append(" sealed interface "); c.append(name);
    if targs.length > 0 do 
        c.append("<");
        var need_comma := false;
        for arg in targs do 
            if need_comma do c.append(", "); end;
            c.append(arg.name);
            need_comma := true;
        end;
        c.append(">");
    end;
    c.append(" {");
    c.indent(); c.newline();
    val prv := c.open_scope(env);
    c.is_class := true;
    c.is_generated_interface := true;
    for member in members do 
        compile_decl(c, member);
    end;
    c.strip_trailing(); c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    for variant in variants do 
        compile_enum_variant(c, name, targs, prefix, variant);
    end;
end

fun compile_enum_variant(c : Compiler, name : String, targs : Ast.TypeParameter[], prefix : String, variant : Ast.EnumConstructor) do 
    c.append(prefix); c.append(" record "); c.append(variant.name); 
    if targs.length > 0 do 
        c.append("<");
        var need_comma := false;
        for arg in targs do 
            if need_comma do c.append(", "); end;
            c.append(arg.name);
            need_comma := true;
        end;
        c.append(">");
    end;
    c.append("(");
    var i := 0;
    var need_comma := false;
    for field in variant.fields do 
        if need_comma do c.append(", "); end;
        c.append(compile_type(c, field)); c.append(" __field"+i); 
        i := i + 1; need_comma := true; 
    end; 
    c.append(") implements "); c.append(name); 

    if targs.length > 0 do 
        c.append("<");
        var need_sep := false;
        for arg in targs do 
            if need_sep do c.append(", "); end;
            c.append(arg.name);
            need_sep := true;
        end;
        c.append(">");
    end;
    
    c.append(" {");
    c.indent(); c.newline();
    c.append("@Override public String toString() {"); c.indent(); c.newline();
        c.append("StringBuilder __builder = new StringBuilder();"); c.newline();
        c.append("__builder.append(\""+variant.name+"(\");"); c.newline();
        var needs_comma := false;
        for field_index in [0..variant.fields.length] do 
            if needs_comma do c.append("__builder.append(\", \");"); end;
            c.append("__builder.append(__field"+field_index+"());"); c.newline();
            needs_comma := true;
        end;
        c.append("__builder.append(\")\");"); c.newline();
        c.append("return __builder.toString();"); c.dedent(); c.newline();
        c.append("} "); c.dedent(); c.newline();
    c.append("}"); c.newline();
    val info := VariableInfo(c.current_env.module_path);
    info.is_constructor := true;
    info.is_no_fc_fn := true;
    c.env.insert(variant.name, info);
end

fun compile_class_decl(
    c : Compiler, 
    name : String, 
    targs: Ast.TypeParameter[],
    members : Ast.Decl[], 
    constr : Optional(Ast.Constructor), 
    env : Ast.Namespace) 
do
    if c.is_class do 
        c.append("public ");
    end;
    if c.is_static do 
        c.append("static ");
    end
    c.append("class "+name);
    if targs.length > 0 do 
        c.append("<");
        var need_comma := false;
        for arg in targs do 
            if need_comma do c.append(", "); end;
            c.append(arg.name);
            need_comma := true;
        end;
        c.append(">");
    end;
    c.append(" {");
    c.indent(); c.newline();
    val info := VariableInfo(c.current_env.module_path);
    info.is_constructor := true;
    info.is_no_fc_fn := true;
    c.env.insert(name, info);
    val prv := c.open_scope(env);
    c.is_class := true;
    for member in members do 
        compile_decl(c, member);
    end;
    compile_constructor(c, constr, name);
    c.strip_trailing(); c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    
end

fun compile_constructor(c : Compiler, constr : Optional(Ast.Constructor), name : String) do
    val Some(construct) := constr else return null;
    c.append("public "+name);
    c.append("(");
    var needs_comma := false;
    for param in construct.params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(param_name, ty) := do 
                val info := VariableInfo(c.current_env.module_path);
                c.env.insert(param_name, info);
                c.append(compile_type(c, ty)); c.append(" "+param_name);
            end;
        end;
        needs_comma := true;
    end;
    c.append(") ");
    compile_expr(c, construct.body, Ignore());
end

fun compile_variables(
    c : Compiler, 
    setter : Ast.Setter, 
    ty : Ast.Type, 
    is_global : Bool, 
    mutable : Bool, 
    is_upvalue : Bool) 
do 
    match setter do 
        case Variable(name) := do 
            if c.is_class do c.append("public "); end;
            if c.is_static do c.append("static "); end;
            if !mutable do c.append("final "); end;
            val info := VariableInfo(c.current_env.module_path);
            info.is_upvalue := is_upvalue;
            c.env.insert(name, info);
            val ty_compiled := if is_upvalue then compile_upvalue_type(c, ty) else compile_type(c, ty);
            c.append(ty_compiled); c.append(" "); c.append(name); 
            if is_upvalue do 
                c.append(" = new ");
                c.append(ty_compiled);
                c.append("()");
            end;
            c.append(";");
            c.newline();
        end;
        case WildcardSetter() := do end;
        case TupleSetter(parts, ?) := do 
            val Tuple(types) := ty else panic("Non-tuple type in tuple setter "+setter);
            for i in [0..parts.length] do 
                compile_variables(c, parts[i], types[i], is_global, mutable, is_upvalue);
            end;
        end;
        case Property(?, ?, ?) := panic("Unreachable: Cannot assign to field of object in declaration");
    end;
end

fun compile_var_decl(
    c : Compiler, 
    setter : Ast.Setter, 
    lt : Util.LateInitialized(Ast.Type), 
    init_mut : Optional(Ast.Expr), 
    mutable : Bool) 
do
    val init := if val Some(e) := init_mut then Some.[Ast.Expr](e) else None.[Ast.Expr]();
    if c.is_class then do
        compile_variables(c, setter, lt.get(), true, mutable, false);
        if val Some(e) := init then do 
            if c.is_static do c.append("static "); end;
            c.append("{");
            c.indent(); c.newline();
            val initializer := compile_expr(c, e, AssignTo(setter));
            c.strip_trailing();
            c.dedent(); c.newline();
            c.append("}");
        end else do end;
        c.newline();
        // Global variables are not pre-analyzed for captures, because they cannot be captured
    end else do
        val is_upvalue := setter_is_upvalue(c, setter);
        compile_variables(c, setter, lt.get(), false, mutable, is_upvalue);
        if val Some(e) := init then do
            compile_expr(c, e, AssignTo(setter));
        end else do end;
    end;
    declare_variables(c, setter);
end

fun declare_variables(c : Compiler, setter : Ast.Setter) do 
    match setter do 
        case Variable(name) := c.env.insert_if_missing(name, VariableInfo(c.current_env.module_path));
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                declare_variables(c, part);
            end;
        end;
        case WildcardSetter() := do end;
        case Property(?, ?, ?) := panic("Cannot declare property as variable: Unreachable");
    end;
end

fun setter_is_upvalue(c : Compiler, setter : Ast.Setter) : Bool :=
    match setter do 
        case Variable(name) := c.env.has(name) and c.env.get(name).is_upvalue;
        case TupleSetter(parts, ?) := do 
            for part in parts do 
                if setter_is_upvalue(c, part) do return true end;
            end;
            false
        end;
        case WildcardSetter() := false;
        case Property(?, ?, ?) := false;
    end;

fun compile_fun_decl(
    c : Compiler, 
    name : String, 
    typarams : Ast.TypeParameter[],
    params : Ast.Parameter[], 
    return_type : Ast.Type, 
    body : Ast.Expr,
    lenv : Util.LateInitialized(Ast.Namespace))
do 
    val info := VariableInfo(c.current_env.module_path);
    info.is_no_fc_fn := c.is_class; // Local functions cannot be compiled directly but to lambdas
    c.env.insert(name, info); // Functions can never be captured, so unconditionally insert info
    val is_main := c.is_static and name = "main" and return_type = Ast.VoidT();
    if c.is_class then do 
        c.append("public ");
        if c.is_static do c.append("static "); end; 
        if c.is_generated_interface do c.append("default "); end;
        if typarams.length != 0 do 
            c.append("<");
            var needs_comma := false;
            for param in typarams do 
                if needs_comma do c.append(", "); end;
                c.append(param.name);
                needs_comma := true;
            end;
            c.append("> ");
        end
        if is_main then do 
            c.append("void");
        end else do
            c.append(compile_type(c, return_type)); 
        end;
        c.append(" ");
    end else do
        val ty := c.current_env.values.get(name).ty;
        //TODO generische lokale funktionen
        if val Function(?, ?, ?) := ty then do end 
               else panic("Unreachable: Function is being compiled that has non-function-type");
        if Analyze.mentions_var(body, name) then do // Check if body mentions name (means its recursive)
            info.is_upvalue := true; // Recursive local functions have to be compiled as upvalues due to being compiled as lambdas
            c.append("final "); c.append(compile_upvalue_type(c, ty)); c.append(name); 
            c.append(" = "); c.append("new Upvalue<>();"); c.newline();
        end else do
            c.append("final " + compile_type(c, ty) + " ");
        end;
    end;
    c.append(maybe_upvalue(c, name, ""));
    if !c.is_class do 
        c.append(" = ");
    end
    c.append("(");
    var needs_comma := false;
    val prev_expect_ref_ty := c.expect_ref_ty;
    c.expect_ref_ty := !c.is_class; // If we're not in a class, we're compiling to a lambda
    val params_to_be_added : (String, VariableInfo)[] := [];
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(param_name, ty) := do 
                params_to_be_added.push((param_name, VariableInfo(c.current_env.module_path)));
                c.append(compile_type(c, ty)); c.append(" "); c.append(param_name);
            end;
        end;
        needs_comma := true;
    end;
    c.expect_ref_ty := prev_expect_ref_ty;
    c.append(") ");
    if !c.is_class do 
        c.append("-> ");
    end;
    
    val prv := c.open_scope(lenv.get());
    c.is_class := false;
    c.is_static := false;
    for (n, i) in params_to_be_added do 
        c.env.insert(n, i);
    end;
    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;
    if !body_is_block do c.append(" {"); c.indent(); c.newline(); end;
    val body_compiled := compile_expr(c, body, if is_main then Ignore() else Return());
    c.strip_trailing();
    if !body_is_block do c.dedent(); c.newline(); c.append("}"); end;
    c.newline();
    c.close_scope(prv);
    if is_main do 
        c.append("
    public static void main(String[] args) {
        __init_runtime(args);
        main();
    }");
        c.newline();
    end;
    if !c.is_class do 
        c.append(";");
        c.newline();
    end;
end

// For side-effect-free expressions that dont write to the compiler but only return strings
fun use_with_target(c : Compiler, expr : String, target : Target) : String do 
    match target do 
        case Ignore() := ""; 
        case UsedDirectly() := expr;
        case AssignTo(setter) := do 
            assign(c, setter, expr)
        end;
        case Return() := do 
            return_stmt(c, expr)
        end;
    end
end

fun escape_string(str : String) : String do 
    var resulting := str;
    resulting := replace(resulting, "\\", "\\\\");
    resulting := replace(resulting, "\n", "\\n");
    resulting := replace(resulting, "\t", "\\t");
    resulting := replace(resulting, "\r", "\\r");
    resulting := replace(resulting, "\"", "\\\"");
    resulting := replace(resulting, "\0", "\\0");
    resulting := "\"" + resulting + "\"";
    resulting
end

fun compile_expr(c : Compiler, expr : Ast.Expr, target : Target) : String := match expr do 
    case DesugarableExpr(content) := compile_expr(c, content.get(), target);
    case NumberLiteral(n) := use_with_target(c, if n % 1 = 0 then "" + n + ".0" else ""+n, target);
    case StringLiteral(str) := do 
        use_with_target(c, escape_string(str), target)
    end;
    case ThisExpr() := use_with_target(c, "this", target);
    case TupleExpr(subexprs, lt) := compile_tuple(c, subexprs, lt.get(), target);
    case ListExpr(subexprs, lt) := compile_list_literal(c, subexprs, lt.get(), target);
    case RangeExpr(start, end_expr) := compile_range_expr(c, start, end_expr, target);
    case Boolean(b) := use_with_target(c, if b then "true" else "false", target);
    case NullLiteral() := use_with_target(c, "null", target);
    case Identifier(name, lty) := compile_identifier(c, name, lty.get(), target);
    case BinaryOperation(op, left, right) := compile_binary(c, op, left, right, target);
    case UnaryOperation(op, operand) := compile_unary(c, op, operand, target);
    case IfExpr(lt, cond, thenBr, elseBr) := compile_if(c, lt, cond, thenBr, elseBr, target);
    case BlockExpr(stmts, end_expr, lt, lenv) := compile_block(c, stmts, end_expr, lt.get(), lenv, target);
    case ForExpr(loop_var, iterated, body, lenv, lt, lit) := compile_for(c, loop_var, 
                                                                         iterated, body, 
                                                                         lenv.get(), lt.get(), lit.get(), 
                                                                         target);
    case WhileExpr(cond, body, lenv, lty) := compile_while(c, cond, body, lenv.get(), lty.get(), target);
    case FunctionCall(callee, call_args) := compile_call(c, callee, call_args, target);
    case InstantiationExpr(instantiated, type_args, lresult_ty) := compile_instantiated(c, instantiated, type_args, lresult_ty.get(), target); // Compiler can either infer it or go back here
    case FunctionExpr(params, return_type, body, lenv) := compile_function_expr(c, params, return_type, body, lenv.get(), target);
    case PropertyExpr(obj, name, la, lt, lft) := compile_property(c, obj, name, la.get(), lt.get(), lft.get(), target);
    case IndexExpr(lst, idx, llist_ty) := compile_index(c, lst, idx, llist_ty.get(), target);
    case MatchExpr(matched, arms, lmatchty, lretty) := compile_match(c, matched, arms, lmatchty.get(), lretty.get(), target);
    case ReturnExpr(ret, lty) := compile_return(c, ret, lty.get(), target);
    case Break(lty) := compile_break(c, lty.get(), target);
end;

fun compile_instantiated(c : Compiler, instantiated : Ast.Expr, typarams : Ast.Type[], resulting_type : Ast.Type, target : Target) : String do
    val Function(?, param_tys, ret_type) := resulting_type else panic("Generic non-function type: "+resulting_type);
    c.append("final "); c.append(compile_type(c, resulting_type)); c.append(" ");
    val variable := c.new_var();
    c.append(variable); c.append(" = "); 
    val param_vars := for ty in param_tys yield c.new_var() end;
    c.append("("); 
    var needs_comma := false;
    for i in [0..param_tys.length] do 
        if needs_comma do c.append(", "); end;
        c.append(compile_type(c, param_tys[i]));c.append(" "); c.append(param_vars[i]);
        needs_comma := true;
    end;
    c.append(") -> {");
    // TODO: objekte sollten außerhalb kompiliert werden
    val prv := c.open_scope(c.current_env);
        for i in [0..param_vars.length] do 
            c.env.insert(param_vars[i], VariableInfo(c.current_env.module_path));
            c.current_env.values.insert(param_vars[i], Ast.VarInfo(false, param_tys[i], param_vars[i], c.current_env));
        end;
        compile_expr(c, 
            Ast.FunctionCall(
                instantiated, 
                for i in [0..param_vars.length] 
                    yield Ast.Identifier(param_vars[i], Util.wrap_linit.[Ast.Type](param_tys[i])) end), 
            Return());
    c.append("};");
    c.close_scope(prv);
    use_with_target(c, variable, target)
end

fun compile_break(c : Compiler, expected_ty : Ast.Type, target : Target) : String do 
    c.append("if(true) break "+c.loop_labels.last+";"); c.newline();
    use_with_target(c, default_value(expected_ty), target)
end

fun compile_return(c : Compiler, ret : Ast.Expr, needed_ty : Ast.Type, target : Target) : String do 
    c.append("if(true) {"); c.indent(); c.newline();
    compile_expr(c, ret, Return()); c.dedent(); c.newline();
    c.append("}");
    use_with_target(c, default_value(needed_ty), target)
end

fun default_value(ty : Ast.Type) : String := match ty do 
        case NumberT() := "0.0"; 
        case Any() := "null";
        case BooleanT() := "false"; 
        case StringT() := "\"\""; 
        case VoidT() := "null";
        case Tuple(?) := "null"; 
        case Name(?, ?) := "null"; // Types that are refered to by name are objects, so nullable
        case Function(?, ?, ?) := "null"; 
        case ListOf(?) := "null"; 
        case Never() := "null";
    end;

fun compile_match(
    c : Compiler, 
    matched : Ast.Expr, 
    arms : (Ast.Pattern, Ast.Expr, Util.LateInitialized(Ast.Namespace))[], 
    matched_ty : Ast.Type, 
    ret_ty : Ast.Type, 
    target : Target) : String 
do 
    val matched_compiled := compile_expr(c, matched, UsedDirectly());
    val arm_target := if val UsedDirectly() := target then do 
        val temp_var := c.new_var();
        c.append("final "); c.append(compile_type(c, ret_ty)); c.append(" "); c.append(temp_var); c.append(";"); c.newline();
        AssignTo(Ast.Variable(temp_var))
    end else target;
    c.append("switch("); 
    if val NumberT() := matched_ty then do 
        c.append("(Double) "); 
    end else do end; 
    c.append(matched_compiled); c.append(") {"); c.indent(); c.newline();
    var had_unconditional_pattern := false;
    for (patt, expr, lenv) in arms do 
        val prv := c.open_scope(lenv.get());
        match patt do case NamePattern(?) := do had_unconditional_pattern := true; end; case WildcardPattern() := do had_unconditional_pattern := true; end; case ? := do end; end; 
        c.append("case "); compile_pattern(c, patt, matched_ty); c.append(" -> {"); c.indent(); c.newline(); 
        compile_expr(c, expr, arm_target); c.strip_trailing(); 
        c.dedent(); c.newline(); c.append("}"); c.newline();
        c.close_scope(prv);
    end;
    if !had_unconditional_pattern do c.append("default -> { panic(\"Inexhaustive match: \"+"+matched_compiled+"); throw new RuntimeException();}"); c.newline(); end;
    c.dedent(); c.newline(); c.append("}"); c.newline();
    if val UsedDirectly() := target then do 
        val AssignTo(Variable(temp)) := arm_target else panic("Unreachable: Invalid arm target");
        temp
    end else ""
end;

fun compile_pattern(c : Compiler, pattern : Ast.Pattern, matched_ty : Ast.Type) do 
    if val StringPattern(str) := pattern then do 
        c.append(escape_string(str));
    end else if val BooleanPattern(b) := pattern then do 
        c.append(""+b);
    end else if val NumericPattern(n) := pattern then do 
        val temp := c.new_var();
        c.append("Double "+temp+" when "+temp+" == "+n);
    end else if val NamePattern(n) := pattern then do 
        val info := VariableInfo(c.current_env.module_path);
        c.env.insert(n, info);
        val prv_box_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        c.append(compile_type(c, matched_ty)); c.append(" "); c.append(n);
        c.expect_ref_ty := prv_box_ty;
    end else do 
        val guard_queue : String[] := [];
        compile_complex_pattern(c, pattern, guard_queue, matched_ty);
        if guard_queue.length > 0 do 
            c.append(" when ");
            var needs_and := false;
            for guard in guard_queue do 
                if needs_and do c.append(" && "); end;
                c.append(guard);
                needs_and := true;
            end
        end
    end;
end

fun compile_complex_pattern(
    c : Compiler, 
    pattern : Ast.Pattern, 
    guard_queue : String[], 
    matched_ty : Ast.Type) := match pattern do 
    case NumericPattern(n) := do 
        val variable := c.new_var(); 
        c.append("var "+variable); 
        guard_queue.push(variable+" == "+n); 
    end;
    case StringPattern(str) := do 
        val variable := c.new_var();
        c.append("String "+variable);
        guard_queue.push(variable+".equals("+escape_string(str)+")");
    end;
    case BooleanPattern(b) := do 
        val variable := c.new_var();
        c.append(compile_type(c, matched_ty)+" "+variable);
        guard_queue.push(if b then variable else "!"+variable);
    end;
    case NamePattern(n) := do 
        val info := VariableInfo(c.current_env.module_path);
        c.env.insert(n, info);
        c.append(compile_type(c, matched_ty)+" "+n);
    end;
    case WildcardPattern() := c.append(compile_type(c, matched_ty)+" "+c.new_var());
    case ConstructorPattern(name, subpatterns, constr, lenum_ty, linf) := do 
        val enum_info := linf.get();
        val scope := Ast.scope_of_info(enum_info, c.current_env); // Just any namespace, won't be use
        val full_name := name_in_module(c, name, scope);
        c.append(full_name); 

        if val Applied(t, to) := lenum_ty.get() then do 
            if to.length > 0 do 
                c.append("<");
                var need_comma := false;
                for ty in to do 
                    if need_comma do c.append(", "); end;
                    c.append(compile_type(c, ty));
                    need_comma := true;
                end;
                c.append(">");
            end;
        end else do end;
        
        c.append("(");
        var needs_comma := false;
        for i in [0..subpatterns.length] do 
            if needs_comma do c.append(", ");  end;
            compile_complex_pattern(c, subpatterns[i], guard_queue, constr.get().fields[i]);
            needs_comma := true;
        end;
        c.append(")");
    end;
    case TuplePattern(subpatterns) := do 
        c.append(compile_type(c, matched_ty));
        c.append("(");
        var needs_comma := false;
        val Tuple(subtys) := matched_ty else panic("No tuple type in tuple pattern");
        for i in [0..subpatterns.length] do 
            if needs_comma do c.append(", "); end;
            compile_complex_pattern(c, subpatterns[i], guard_queue, subtys[i]);
            needs_comma := true;
        end;
        c.append(")");
    end;
end;

fun compile_range_expr(c : Compiler, start : Ast.Expr, end_expr : Ast.Expr, target : Target) : String do
    if val Ignore() := target then do 
        compile_expr(c, start, Ignore());
        compile_expr(c, end_expr, Ignore());
        ""
    end else do 
        val start_compiled := compile_expr(c, start, UsedDirectly());
        val end_compiled := compile_expr(c, end_expr, UsedDirectly());
        use_with_target(c, "__range("+start_compiled+", "+end_compiled+")", target)
    end
end

fun compile_for(
    c : Compiler, 
    loop_var : Ast.Setter, 
    iterated : Ast.Expr, 
    body : Ast.Expr, 
    env : Ast.Namespace, 
    result_ty : Ast.Type, 
    iterated_elem_ty : Ast.Type,
    target : Target) : String 
do 
    val internal_loop_var := c.new_var();
    val list_var := if target != Ignore() and result_ty != Ast.VoidT() then do 
        val res_var := c.new_var();
        c.append("final "); c.append(compile_type(c, result_ty)); c.append(" "+res_var+";"); c.newline();
        res_var
    end else "";
    if target != Ignore() and result_ty != Ast.VoidT() do 
        assign(c, Ast.Variable(list_var), "new ArrayList<>()");
    end

    val loop_label := c.new_var();
    c.loop_labels.push(loop_label);

    if val RangeExpr(start_expr, end_expr) := iterated then do 
        val start_var := c.new_var();
        c.append("final double "+start_var+";"); compile_expr(c, start_expr, AssignTo(Ast.Variable(start_var)));
        val end_var := c.new_var();
        c.append("final double "+end_var+";"); compile_expr(c, end_expr, AssignTo(Ast.Variable(end_var)));
        c.append("if("+start_var+" < "+end_var+") "); c.newline();
        c.append(loop_label+": for(double "+internal_loop_var+" = "+start_var+"; "); 
        c.append(internal_loop_var+ " < "+end_var+"; "+internal_loop_var+"++) {");
        c.indent(); c.newline();
    end else do 
        val iterated_compiled := compile_expr(c, iterated, UsedDirectly());
        c.append(loop_label+": for(var "+internal_loop_var+" : "+iterated_compiled+") {"); c.indent(); c.newline();
    end;
        val prv := c.open_scope(env);
        val BlockExpr(stmts, end_expr, ?, ?) := body else panic("Internal error: non-block-expression as body of for");
        // Dont have to scan loop variables for captures as they aren't mutable
        val captures := Analyze.analyze_captures(stmts, end_expr); 
        for (name, is_captured) in captures.bindings do 
            if is_captured do 
                val info := VariableInfo(c.current_env.module_path);
                info.is_upvalue := true;
                c.env.insert(name, info); // Mark as upvalue
            end
        end;
        compile_variables(c, loop_var, iterated_elem_ty, false, false, false);
        assign(c, loop_var, internal_loop_var);
        val result := compile_expr(c, body, if val Ignore() := target then Ignore() else UsedDirectly());
        if target != Ignore() and result_ty != Ast.VoidT() do 
            c.append(list_var); c.append(".add("+result+");"); c.newline();
        end
        c.close_scope(prv);
        c.dedent(); c.newline();
    c.append("}");
    c.loop_labels.pop();
    c.newline();
    use_with_target(c, if result_ty = Ast.VoidT() then "null" else list_var, target)
end

fun compile_while(
    c : Compiler, 
    cond : Ast.Expr, 
    body : Ast.Expr, 
    env : Ast.Namespace, 
    result_ty : Ast.Type, 
    target : Target) : String 
do 
    val list_var := if target != Ignore() and result_ty != Ast.VoidT() then do 
        val res_var := c.new_var();
        c.append("final "); c.append(compile_type(c, result_ty)); c.append(" "+res_var+";"); c.newline();
        res_var
    end else "";
    if target != Ignore() and result_ty != Ast.VoidT() do 
        assign(c, Ast.Variable(list_var), "new ArrayList<>()");
    end
    val loop_label := c.new_var();
    c.loop_labels.push(loop_label);
    c.append(loop_label+": while(true) {"); c.indent(); c.newline();
        val cond_compiled := compile_expr(c, cond, UsedDirectly());
        if val Boolean(b) := cond then do if !b do c.append("break;"); end; end else do c.append("if(!"+cond_compiled+") { break; }"); c.newline(); end;
        val prv := c.open_scope(env);
        val BlockExpr(stmts, end_expr, ?, ?) := body else panic("Internal error: non-block-expression as body of while");
        val captures := Analyze.analyze_captures(stmts, end_expr); // There are no loop variables
        for (name, is_captured) in captures.bindings do 
            if is_captured do 
                val info := VariableInfo(c.current_env.module_path);
                info.is_upvalue := true;
                c.env.insert(name, info); // Mark as upvalue
            end
        end;
        val result := compile_expr(c, body, if val Ignore() := target then Ignore() else UsedDirectly());
        if target != Ignore() and result_ty != Ast.VoidT() do 
            c.append(list_var); c.append(".add("+result+");"); c.newline();
        end
        c.close_scope(prv);
        c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.loop_labels.pop();
    use_with_target(c, if result_ty = Ast.VoidT() then "null" else list_var, target)
end

fun compile_index(c : Compiler, lst : Ast.Expr, idx : Ast.Expr, list_ty : Ast.Type, target : Target) : String do
    if val Ignore() := target then do
        compile_expr(c, lst, Ignore());
        compile_expr(c, idx, Ignore());
        ""
    end else do
        val indexed := compile_expr(c, lst, UsedDirectly());
        val index := compile_expr(c, idx, UsedDirectly());
        val compiled := match list_ty do 
            case StringT() := "Character.toString("+indexed+".charAt(__toIndex("+index+")))"; 
            case ? := indexed+".get(__toIndex("+index+"))" ;
        end;
        use_with_target(c, compiled, target)
    end
end

fun compile_list_literal(c : Compiler, exprs : Ast.Expr[], lty : Ast.Type, target : Target) : String do 
    if val Ignore() := target then do 
        for expr in exprs do 
            compile_expr(c, expr, Ignore());
        end;
        ""
    end else do 
        val Variable(name) := if val AssignTo(s) := target then s else Ast.Variable(c.new_var()) 
                                else panic("invalid target for lists: "+target);
        if val AssignTo(?) := target then do end else do 
            val compiled_ty := compile_type(c, lty);
            c.append(compiled_ty); c.append(" ");
        end;
        c.append(name+" = new ArrayList<>("+exprs.length+");"); c.newline();
        for expr in exprs do 
            val field := compile_expr(c, expr, UsedDirectly());
            c.append(""+name+".add("+field+");"); c.newline();
        end;
        if val AssignTo(?) := target then "" else use_with_target(c, name, target)
    end
end

fun compile_property(
    c : Compiler, 
    obj : Ast.Expr,
    name : String, 
    at : Ast.AccessType, 
    obj_ty : Ast.Type, 
    field_ty : Ast.Type, 
    target : Target) : String 
do 
    if target = Ignore() then do 
        compile_expr(c, obj, target)
    end else do // Target cannot be Ignore
        match at do 
            case FieldAccess() := do
                val subexpr := compile_expr(c, obj, UsedDirectly());
                val fieldAccess := if val ListOf(?) := obj_ty 
                    then builtin_list_property(name, subexpr) 
                    else subexpr + "." + name;
                use_with_target(c, fieldAccess, target)
            end;
            case MethodAccess() := do 
                val temp_var := c.new_var();
                c.append("final "); c.append(compile_type(c, obj_ty)); c.append(" "); c.append(temp_var); c.append(";"); c.newline();
                compile_expr(c, obj, AssignTo(Ast.Variable(temp_var)));
                val methodAccess := if val ListOf(?) := obj_ty 
                    then builtin_list_method(c, temp_var, name) 
                    else temp_var + "::"+name; // Create method reference. Let java create lambda
                match target do 
                    case AssignTo(s) := assign(c, s, methodAccess);
                    case Return() := return_stmt(c, methodAccess);
                    case UsedDirectly() := do 
                        val resulting_var := c.new_var();
                        c.append("final "); c.append(compile_type(c, field_ty)); c.append(" "); c.append(resulting_var); 
                        c.append(" = "); c.append(methodAccess); c.append(";"); c.newline();
                        resulting_var
                    end;
                end
            end;
            case ModuleAccessed() := do 
                val nmsp := namespace_for_path(c, obj);
                val mod_info := var_info_for_namespace(c, nmsp);
                val accessed_info := mod_info.get(name);
                val accessed_path := SFG.path_to_generated_module(c.sfg, nmsp.module_path, false);
                val access_compiled := if accessed_info.is_constructor 
                    then accessed_path+"."+name+"::new"
                    else if accessed_info.is_no_fc_fn
                        then accessed_path+"::"+name 
                        else accessed_path+"."+name;
                use_with_target(c, access_compiled, target)
            end;
        end
    end
end

fun mod_info_for_path(c : Compiler, obj : Ast.Expr) : Env.Env(VariableInfo) do 
    val mod_namespace := namespace_for_path(c, obj);
    var_info_for_namespace(c, mod_namespace)
end
fun namespace_for_path(c : Compiler, obj : Ast.Expr) : Ast.Namespace do 
    val Module(path) := Ast.get_as_path(obj) else panic("Unknown module access: "+obj);
    namespace_for_path_parts(c, path)
end

fun namespace_for_path_parts(c : Compiler, path : String[]) : Ast.Namespace := 
    if path.length = 1 and c.current_env.imported_modules.has(path[0]) 
        then c.current_env.imported_modules.get(path[0]) 
        else c.current_env.imported_modules.get(
            join("/", path) + ".myl");
fun var_info_for_namespace(c : Compiler, nmscp : Ast.Namespace) : Env.Env(VariableInfo) do 
    val file_path := SFG.path_to_module(nmscp.module_path);
    c.all_modules.get(file_path)
end

fun builtin_list_property(name : String, subexpr : String) : String := match name do 
    case "length" := "(double) ("+subexpr+".size())";
    case "first" := subexpr+".get(0)";
    case "last" := subexpr+".get("+subexpr+".size() - 1)";
end;

fun builtin_list_method(c : Compiler, tempvar : String, method : String) : String := match method do 
    case "push" := do 
        val arg := c.new_var();
        "(var "+arg+") -> {"+tempvar+".add("+arg+"); return null;}"
    end;
    case "pop" := "() -> "+tempvar+".remove("+tempvar+".size() - 1)";
    case "peek" := "() -> "+tempvar+".get("+tempvar+".size() - 1)";
    case "dequeue" := "() -> "+tempvar+".remove(0)";
    case "prepend" := do 
        val arg := c.new_var();
        "(var "+arg+") -> "+tempvar+".add(0, "+arg+")"
    end;
    case "append" := do 
        val arg := c.new_var();
        "(var "+arg+") -> "+tempvar+".addAll("+arg+")"
    end;
end;

fun builtin_list_method_call(c : Compiler, obj : String, acc : String, call_args : Ast.Expr[], target : Target) : String do 
    val args_compiled : String[] := for arg in call_args yield 
        compile_expr(c, arg, UsedDirectly())
    end;

    val res_expr := match acc do 
        case "push" := obj+".add("+(args_compiled[0]+")");
        case "pop" := obj+".remove("+obj+".size() - 1)";
        case "peek" := obj+".get("+obj+".size() - 1)";
        case "dequeue" := obj+".remove(0)";
        case "prepend" := obj+".add(0, "+(args_compiled[0]+")");
        case "append" := obj+".addAll("+(args_compiled[0]+")");
    end;

    match target do 
        case Ignore() := do 
            c.append(res_expr); c.append(";");
            c.newline();
            ""
        end;
        case Return() := return_stmt(c, res_expr);
        case UsedDirectly() := do 
            val temp_var := c.new_var();
            c.append("var "+temp_var+" = "+res_expr+";"); c.newline();
            temp_var
        end;
        case AssignTo(s) := assign(c, s, res_expr);
    end
end

fun compile_tuple(c : Compiler, subexprs : Ast.Expr[], ty : Ast.Type, target : Target) : String do 
    val subexpr_target := match target do 
        case Ignore() := Ignore();
        case ? := UsedDirectly();
    end;
    val exprs := for expr in subexprs yield compile_expr(c, expr, subexpr_target) end;
    if target = Ignore() do 
        return "";
    end
    // Name of the corresponding tuple type (will be created and will have a constructor)
    val tuple_type := compile_type(c, ty); 
    var name := "";
    val setter := if val AssignTo(s) := target then s else do 
        name := c.new_var();
        c.append("final "+tuple_type+" "+name+";");
        c.newline();
        Ast.Variable(name)
    end;
    var buf := "new "+tuple_type+"(";
    var needs_comma := false;
    for expr in exprs do 
        if needs_comma do 
            buf := buf + ", ";
        end 
        buf := buf + expr;
        needs_comma := true;
    end;
    buf := buf + ")";
    assign(c, setter, buf);
    if val Return() := target then do 
        c.append("return "); c.append(name); c.append(";"); c.newline();
        ""
    end else name
end

fun compile_binary(
    c : Compiler, 
    op : Ast.BinOp, 
    left : Ast.Expr,
    right : Ast.Expr,
    target : Target
) : String 
do 
    if is_lazy_op(op) do 
        return compile_lazy_binary(c, op, left, right, target);
    end
    if Ignore() = target do // Don't need to compile the operation 
        compile_expr(c, left, Ignore());
        compile_expr(c, right, Ignore());
        return "";
    end;
    val operation := do 
        val lhs := compile_expr(c, left, UsedDirectly());
        val rhs := compile_expr(c, right, UsedDirectly());
        compile_bin_op(op, lhs, rhs)
    end;
    match target do 
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
        case UsedDirectly() := "(" + operation + ")";
    end
end

fun is_lazy_op(op : Ast.BinOp) : Bool := match op do case And() := true; case Or() := true; case ? := false; end;

fun compile_lazy_binary(c : Compiler, op : Ast.BinOp, left : Ast.Expr, right : Ast.Expr, target : Target) : String do 
    val prefix := if val And() := op then "" else "!";
    val default_result := if val And() := op then "false" else "true";
    val lft := compile_expr(c, left, UsedDirectly());
    match target do
        case Ignore() := do 
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, Ignore());
            c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
        case Return() := do
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, Return()); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            c.append("return "+default_result+";"); c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
        case UsedDirectly() := do 
            val res_var := c.new_var();
            c.append("final boolean "+res_var+";"); c.newline();
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, AssignTo(Ast.Variable(res_var))); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            c.append(res_var + " =  "+default_result+";"); c.dedent(); c.newline();
            c.append("}"); c.newline();
            res_var
        end;
        case AssignTo(to) := do 
            c.append("if("+prefix+lft+") {"); c.indent(); c.newline();
            compile_expr(c, right, target); c.dedent(); c.newline();
            c.append("} else {"); c.indent(); c.newline();
            assign(c, to, default_result); c.dedent(); c.newline();
            c.append("}"); c.newline();
            ""
        end;
    end
end

fun compile_unary(c : Compiler, op : Ast.UnOp, operand : Ast.Expr, target : Target) : String do 
    if target = Ignore() do 
        compile_expr(c, operand, Ignore());
        return "";
    end;
    val operation := do 
        val operand_comp := compile_expr(c, operand, UsedDirectly());
        val op_c := compile_un_op(op);
        op_c + operand_comp
    end;
    match target do 
        case UsedDirectly() := "(" + operation + ")";
        case Return() := do 
            return_stmt(c, operation)
        end;
        case AssignTo(setter) := do 
            assign(c, setter, operation)
        end;
    end
end

fun compile_function_expr(
    c : Compiler,
    params : Ast.Parameter[],
    return_type : Ast.Type,
    body : Ast.Expr,
    env : Ast.Namespace,
    target : Target) : String
do 
    if Ignore() = target do return ""; end;
    val complete_ty := Ast.Function([], param_types(params), return_type);
    var name := "";
    val temp_var := match target do 
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case Return() := Ast.Variable("");
        case AssignTo(setter) := setter;
    end;
    match target do 
        case UsedDirectly() := do 
            c.append("final "); c.append(compile_type(c, complete_ty)); c.append(" "); c.append(name); c.append(" = (");
        end;
        case AssignTo(Variable(n)) := do 
            c.append(n); c.append(" = (");
        end;
        case Return() := do 
            c.append("return (");
        end;
    end;
    val prv := c.open_scope(env);
    var needs_comma := false;
    val prev_expect_ref_ty := c.expect_ref_ty;
    c.expect_ref_ty := true;
    for param in params do 
        if needs_comma do 
            c.append(", ");
        end;
        match param do 
            case NormalParam(param_name, ty) := do 
                c.env.insert(param_name, VariableInfo(c.current_env.module_path));
                c.append(compile_type(c, ty)); c.append(" "); c.append(param_name);
            end;
        end;
        needs_comma := true;
    end; 
    c.expect_ref_ty := prev_expect_ref_ty;

    val body_is_block := if val BlockExpr(?, ?, ?, ?) := body then true else false;

    c.append(") -> ");
    if !body_is_block do 
        c.append("{");
        c.indent(); c.newline();
    end
    
    compile_expr(c, body, Return());
    c.strip_trailing();
    if !body_is_block then do
        c.dedent(); c.newline();
        c.append("};"); c.newline();
    end else do 
        c.append(";"); c.newline();
    end;

    c.close_scope(prv);
    name
end

fun param_types(params : Ast.Parameter[]) : Ast.Type[] := for param in params yield 
    match param do 
        case NormalParam(name, ty) := ty;
    end
end;

fun maybe_upvalue(c : Compiler, name : String, extra_path : String) : String := 
    if c.env.has(name) and c.env.get(name).is_upvalue then 
        extra_path + name + ".value"
    else 
        extra_path + name;

fun compile_identifier(c : Compiler, fname : String, expected_ty : Ast.Type, target : Target) : String do
    if Ignore() = target do // Identifier has no side effects, so ignore means nothing has to be compiled
        return "";
    end;
    val defined_file := c.env.get(fname).defined_file;
    val current_file := c.current_env.module_path;
    val path := if defined_file != current_file 
            then SFG.path_to_generated_module(c.sfg, defined_file, false)+"."
            else "";
    if val Function(type_params, arg_tys, ret_type) := c.current_env.values.get(fname).ty then do
        if !c.env.get(fname).is_no_fc_fn do // Value is a first class function already
            // Value might be an upvalue
            return use_with_target(c, maybe_upvalue(c, fname, path), target); // No lambda has to be created
        end;
        // Value is a first class function and therefore cannot be an upvalue
        val ty := compile_type(c, c.current_env.values.get(fname).ty);
        var name := "";
        val temp_var := match target do
            case Return() := Ast.Variable("");
            case UsedDirectly() := do 
                name := c.new_var();
                Ast.Variable(name)
            end;
            case AssignTo(setter) := setter;
        end;
        match target do 
            case Return() := do 
                c.append("return ");
            end;
            case UsedDirectly() := do 
                c.append(ty); c.append(" "); c.append(name); c.append(" = ");
            end;
            case AssignTo(Variable(x)) := do 
                c.append(x); c.append(" = ");
            end;
        end;
        c.append("(");
        val params : String[] := [];
        var needs_comma := false;
        for param in arg_tys do 
            if needs_comma do 
                c.append(", ");
            end;
            val arg_name := c.new_var();
            c.append(compile_type(c, param)); c.append(" "); c.append(arg_name);
            params.push(arg_name);
            needs_comma := true;
        end;
        c.append(") -> "); if c.env.get(fname).is_constructor do c.append("new "); end; 
        c.append(path+fname); c.append("(");
        needs_comma := false;
        for param in params do 
            if needs_comma do 
                c.append(", ");
            end
            c.append(param);
        end;
        c.append(");");
        c.newline();
        name
    end else if val Never() := c.current_env.values.get(fname).ty then do 
        use_with_target(c, default_value(expected_ty), target)
    end else do 
        // Normal variable, might be an upvalue
        use_with_target(c, maybe_upvalue(c, fname, path), target)
    end
end

fun create_enqueued_type(c : Compiler, ty : Ast.Type) : String do 
    if val Some(name) := c.get_enqueued_type(ty) then do 
        name 
    end else do 
        val type_name := c.new_var();
        c.enqueue_type(ty, type_name);
        type_name
    end
end

fun compile_call(c : Compiler, callee : Ast.Expr, call_args : Ast.Expr[], target : Target) : String do 
    var is_builtin_list_method := false;
    fun compile_callee(called : Ast.Expr) : String := match called do 
        case Identifier(name, lty) := do 
            val info := c.env.get(name);
            val defined_file := info.defined_file;
            val current_file := c.current_env.module_path;
            val path := if defined_file != current_file 
                then SFG.path_to_generated_module(c.sfg, defined_file, false) + "."
                else "";
            if info.is_constructor then 
                "new " + path + name
            else if info.is_no_fc_fn then do 
                path + name 
            end else
                compile_expr(c, called, UsedDirectly()) + ".call"
        end;
        case InstantiationExpr(instantiated, ?, ?) := do 
            compile_callee(instantiated) // Type parameters inferred by java
        end;
        case PropertyExpr(obj, name, la, lt, lft) := do 
            if val ModuleAccessed() := la.get() then do 
                val nmscp := namespace_for_path(c, obj);
                val mod_info := var_info_for_namespace(c, nmscp);
                val accessed_info := mod_info.get(name);
                val accessed_path := SFG.path_to_generated_module(c.sfg, nmscp.module_path, false);
                if accessed_info.is_constructor 
                    then "new "+accessed_path+"."+name
                else if accessed_info.is_no_fc_fn 
                    then accessed_path + "." + name 
                else accessed_path + "." + name + ".call" 
            end else do 
                val obj_expr := compile_expr(c, obj, UsedDirectly());
                val obj_ty := lt.get();
                if val ListOf(?) := obj_ty then do
                    is_builtin_list_method := true;
                    return builtin_list_method_call(c, obj_expr, name, call_args, target) // builtin list methods have to be compiled specially
                end else 
                if val MethodAccess() := la.get() then 
                     obj_expr + "." + name
                else obj_expr + "." + name  + ".call"
            end
        end;
        case ? := compile_expr(c, called, UsedDirectly()) + ".call";
    end;
    val callee_compiled : String := compile_callee(callee);
    if is_builtin_list_method do return callee_compiled; end;
    val args_compiled := for arg in call_args yield 
        compile_expr(c, arg, UsedDirectly())
    end;
    var str := callee_compiled + "(";
    var needs_comma := false;
    for arg in args_compiled do 
        if needs_comma do 
            str := str + ", ";
        end;
        str := str + arg;
        needs_comma := true;
    end;
    str := str + ")";
    match target do 
        case Ignore() := do if str != "()" do c.append("__ignore("); c.append(str); c.append(");"); c.newline(); end; "" end;
        case Return() := do 
            return_stmt(c, str)
        end;
        case UsedDirectly() := do
            val tmp := c.new_var();
            c.append("var "+tmp+" = " + str + ";"); c.newline();
            tmp
        end;
        case AssignTo(setter) := do 
            assign(c, setter, str)
        end;
    end
end

fun compile_block(
    c : Compiler, 
    stmts : Ast.Stmt[], 
    end_expr : Optional(Ast.Expr),
    t : Ast.Type,
    lenv : Util.LateInitialized(Ast.Namespace),
    target : Target) : String 
do 
    var name := "";
    var var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter; 
    end;
    if target = UsedDirectly() do 
        c.append("final "); 
        c.append(compile_type(c, t)); 
        c.append(" "); 
        c.append(name);
        c.append(";"); 
        c.newline(); 
    end;
    c.append("{"); c.indent(); c.newline();
    val prv := c.open_scope(lenv.get());
    val captures := Analyze.analyze_captures(stmts, end_expr);
    for (binding_name, is_captured) in captures.bindings do 
        if is_captured do 
            val info := VariableInfo(c.current_env.module_path);
            info.is_upvalue := true;
            c.env.insert(binding_name, info); // Mark as upvalue
        end
    end;
    for stmt in stmts do 
        compile_stmt(c, stmt);
    end;
    if val Some(e) := end_expr then do 
        val resulting_target := match target do 
            case Ignore() := Ignore();
            case Return() := Return();
            case UsedDirectly() := AssignTo(var_name);
            case AssignTo(?) := AssignTo(var_name);
        end;
        compile_expr(c, e, resulting_target);
    end else do 
        match target do 
            case Ignore() := do end;
            case Return() := do c.append("return null;"); end;
            case UsedDirectly() := do 
                name := "null"; // Just user null as inline expression 
            end; 
            case AssignTo(setter) := do 
                assign(c, setter, "null");
            end;
        end;
    end;
    c.strip_trailing();
    c.dedent(); c.newline();
    c.append("}");
    c.newline();
    c.close_scope(prv);
    name
end

fun compile_bin_op(op : Ast.BinOp, lhs : String, rhs : String) : String := match op do 
    case Add(lty) := match lty.get() do 
        case NumberT() := lhs + "+" + rhs;
        case StringT() := "__stringify("+lhs+")+__stringify("+rhs+")";
    end;
    case Sub() := lhs + "-" + rhs;
    case Mul() := lhs + "*" + rhs;
    case Div() := lhs + "/" + rhs;
    case Mod() := lhs + "%" + rhs;
    case LessThan() := lhs + "<" + rhs;
    case LessEqual() := lhs + "<=" + rhs;
    case Equals() := "__equal("+lhs+", "+rhs+")";
    case NotEquals() := "!__equal("+lhs+", "+rhs+")";
    case GreaterThan() := lhs + ">" + rhs;
    case GreaterEqual() := lhs + ">=" + rhs;
    case And() := lhs + "&&" + rhs;
    case Or() := lhs + "||" + rhs;
    case Xor() := lhs + "^" + rhs;
end;

fun compile_un_op(op : Ast.UnOp) : String := match op do 
    case Plus()  := "+";
    case Minus() := "-";
    case Not()   := "!";
end;

fun compile_if(
    c : Compiler, 
    lt : Util.LateInitialized(Ast.Type),
    cond : Ast.Expr, 
    thenBr : Ast.Expr, 
    elseBr : Ast.Expr,
    target : Target) : String do 
    var name := "";
    val var_name := match target do 
        case Ignore() := Ast.Variable("");
        case Return() := Ast.Variable("");
        case UsedDirectly() := do 
            name := c.new_var();
            Ast.Variable(name)
        end;
        case AssignTo(setter) := setter;
    end;
    if target = UsedDirectly() do
        c.append("final "); c.append(compile_type(c, lt.get())); c.append(" "); c.append(name); c.append(";"); c.newline();
    end;
    val prev_buf := c.buf.buf; // Safe buffer before if to backtrack in case the if is not necessare
    c.buf.buf := "";
    val branch_target := match target do 
        case Ignore() := Ignore();
        case Return() := Return();
        case ? := AssignTo(var_name);
    end;
    val cond_expr := compile_expr(c, cond, UsedDirectly());
    val cond_buf := c.buf.buf;
    c.buf.buf := "";
    c.append("if("); c.append(cond_expr); c.append(") {"); c.indent(); c.newline();
    val if_buf := c.buf.buf;
    c.buf.buf := "";
    val thenBrExpr := compile_expr(c, thenBr, branch_target);
    val thenIsIgnored := thenBrExpr = "" and c.buf.buf = "";
    c.strip_trailing();c.dedent();c.newline(); c.append("} else {"); c.indent();c.newline();
    val else_buf := c.buf.buf;
    c.buf.buf := "";
    val elseBrExpr := compile_expr(c, elseBr, branch_target);
    val elseIsIgnored := elseBrExpr = "" and c.buf.buf = "";
    c.strip_trailing();c.dedent(); c.newline(); c.append("}"); c.newline();
    val end_buf := c.buf.buf;
    c.buf.buf := prev_buf; // Restore previous buffer
    if thenIsIgnored and elseIsIgnored and Ignore() = target then do // Both branches can be ignored
        c.append(compile_expr(c, cond, Ignore())); // Recompile condition as ignored
        c.newline();
    end else do 
        c.append(cond_buf + if_buf + else_buf + end_buf); // Create whole branch in buffer
    end;
    name
end

fun compile_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := if c.expect_ref_ty then "Double" else "double";
    case Any() := "Object";
    case BooleanT() := if c.expect_ref_ty then "Boolean" else "boolean";
    case StringT() := "String";
    case VoidT() := "Void";
    case ListOf(et) := do 
        val pref_expect_ref_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        val result := "ArrayList<"+compile_type(c, et)+">";
        c.expect_ref_ty := pref_expect_ref_ty;
        result
    end;
    case Function(?, arg_tys, ret) := do 
        var ty := create_enqueued_type(c, t);
        ty := ty+"<";
        var need_comma := false;
        val pref_expect_ref_ty := c.expect_ref_ty;
        c.expect_ref_ty := true;
        for arg in arg_tys do 
            if need_comma do ty := ty + ", "; end
            ty := ty + compile_type(c, arg);
            need_comma := true;
        end;
        if need_comma do ty := ty + ", "; end
        ty := ty + compile_type(c, ret);
        ty := ty + ">";
        c.expect_ref_ty := pref_expect_ref_ty;
        c.generated_module_path + "." + ty
    end;
    case Tuple(parts) := do 
        var ty := create_enqueued_type(c, t);
        if parts.length != 0 do 
            val pref_expect_ref_ty := c.expect_ref_ty;
            c.expect_ref_ty := true;
            ty := ty + "<";
            var need_comma := false;
            for part in parts do 
                if need_comma do ty := ty + ", "; end
                ty := ty + compile_type(c, part);
                need_comma := true;
            end;
            ty := ty + ">";
            c.expect_ref_ty := pref_expect_ref_ty;
        end;
        c.generated_module_path + "." + ty
    end;
    case Name(name, lnspc) := do 
        name_in_module(c, name, lnspc.get())
    end; // Classes are compiled with their name
    case ModuleAccess(given_path, accessed, lty) := do 
        val nmscp := scope_of_name(lty.get());
        val path := nmscp.module_path;
        SFG.path_to_generated_module(c.sfg, path, false)+"."+accessed
    end;
    case Applied(ap, tys) := do 
        var ty := compile_type(c, ap);
        if tys.length > 0 do 
            val pref_expect_ref_ty := c.expect_ref_ty;
            c.expect_ref_ty := true;
            ty := ty + "<";
            var need_comma := false;
            for at in tys do 
                if need_comma do ty := ty + ", "; end;
                ty := ty + compile_type(c, at);
                need_comma := true;
            end;
            ty := ty + ">";
            c.expect_ref_ty := pref_expect_ref_ty;
        end
        ty
    end;
    case Never() := "Void";
end;

fun scope_of_name(name : Ast.Type) : Ast.Namespace := match name do 
    case Name(n, ln) := ln.get();
end;

fun name_in_module(c : Compiler, name : String, scope : Ast.Namespace) : String do 
    val name_file := scope.module_path;
    val this_file := c.current_env.module_path;
    if name_file = this_file then 
        name 
    else do 
        var prefix := "";
        var need_sep := false;
        for i in [0..name_file.length - 1] do 
            if need_sep do prefix := prefix + "."; end;
            val part := name_file[i];
            prefix := prefix + part;
            need_sep := true;
        end;
        if need_sep do prefix := prefix + "."; end;
        val last_part := name_file[name_file.length - 1];
        prefix := prefix + "_" + last_part;
        if name_file.length > 0 
            then prefix + "." + name 
            else name
    end
end

fun compile_upvalue_type(c : Compiler, t : Ast.Type) : String := match t do 
    case NumberT() := "NumberUpvalue";
    case BooleanT() := "BooleanUpvalue";
    case ? := "Upvalue<"+compile_type(c, t)+">";
end;

fun assign(c : Compiler, to : Ast.Setter, from : String) : String do
    match to do 
        case Variable(name) := do 
            if from = "()" do panic("Got just ()"); end;
            c.append(maybe_upvalue(c, name, ""));
            c.append(" = ");
            c.append(from);
            c.append(";");
            c.newline();
        end;
        case WildcardSetter() := do c.append("__ignore("+from+");"); c.newline(); end;
        case TupleSetter(parts, t) := do 
            val temp_var := c.new_var();
            c.append("final "); c.append(compile_type(c, t.get())); c.append(" "); c.append(temp_var);
            c.append(" = "); c.append(from); c.append(";"); c.newline();
            for i in [0..parts.length] do 
                assign(c, parts[i], temp_var+".field"+i+"()");
            end;
        end;
        case IndexSetter(obj, idx) := do 
            val list := compile_expr(c, obj, UsedDirectly());
            val idx_compiled := compile_expr(c, idx, UsedDirectly());
            c.append(list+".set(__toIndex("+idx_compiled+"), "+from+");"); c.newline();
        end;
        case Property(obj, name, ct) := do 
            val object := compile_expr(c, obj, UsedDirectly());
            c.append(object); c.append("."); c.append(name); c.append(" = "); c.append(from); c.append(";"); c.newline();
        end;
    end;
    ""
end

fun return_stmt(c : Compiler, expr : String) : String do 
    c.append("return "); c.append(expr); c.append(";"); c.newline();
    ""
end 
